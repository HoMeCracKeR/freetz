#!/bin/busybox sh

#
# (c) 2014 freetz.org
#

DOS2UNIX="busybox dos2unix"
GETOPT="busybox getopt"
GREP="busybox grep"
SED="busybox sed"
TR="busybox tr"

SELF=$(basename "$0")

usage() {
	local to_usage= to_help=
	case "${SELF}" in
		*2tsv|*2csv|*2xml)
			;;
		*)
			to_usage=" <-t|--to tsv|csv|xml>"
			to_help=$'\n'"    -t|--to     tsv|csv|xml                      output format, default: tsv"
			;;
	esac
cat << EOF
Usage: ${SELF} [-h|--help] [-b|--book <active|bookid1,bookid2,...|all>] [-m|--method <pbd|cat>|-]${to_usage}
    -h|--help                                    print this help and exit
    -b|--book   active|bookid1,bookid2,...|all   phonebooks to export, default: active
    -m|--method pbd|cat|-                        phonebook read method, default: pbd
                                                  * pbd --exportbook <bookid>
                                                  * cat /var/flash/phonebook
                                                  * stdin${to_help}
EOF
}

linearize() {
	$TR $'\n' ' '
}

# prerequisite: input is linearized
normalize_whitespaces() {
	$SED -r -e '{
		s,\t, ,g             # replace tabs with spaces
		s/[ ]{2,}/ /g        # replace multiple spaces with a single one (also within xml-element value, design decision)
		s, ?(<[/?]?) ?,\1,g  # remove unnecessary spaces before/after
		s, ?([/?]?>) ?,\1,g  # xml-element open/close tokens
	}'
}

# prerequisite: input is linearized && whitespace-normalized
ensure_well_formed_xml() {
	# xml in /var/flash/phonebook is not well-formed
	$SED -r -e '{
		s,(<[?][^?>]+)(>),\1?\2,                   # xml-declaration is wrong: <? ... > instead of <? ... ?>
		s,([?]>)(<phonebook[ >]),\1<phonebooks>\2, # multiple root elements (<phonebook>), fix it by surrounding it with
		s,(</phonebook>)$,\1</phonebooks>,         # <phonebooks> (AVM uses the same xml-element in the exported version)
	}'
}

# prerequisite: input is linearized && whitespace-normalized && well-formed
remove_unnecessary_var_flash_only_elements() {
	$SED -r -e '{
		s,<featureflags>[^<]*</featureflags>,,g
		s,<uniqueid>[^<]*</uniqueid>(<phonebook[ >]),\1,g
	}'
}

# prerequisite: input is linearized && whitespace-normalized && well-formed
pretty_print_xml() {
	# TODO: indentation?
	$SED -r -e '{
		s,>$,>\n,
		s,><,>\n<,g
	}'
}

# TODO: implement me
determine_active_phonebook_id() {
	echo -n 0
}

# prerequisite: BOOK variable is set and its value is valid
filter_by_book_id_pattern() {
	local filter_pattern="<phonebook[ >]" # all pattern
	if [ "${BOOK}" != "all" ]; then
		local filter_pattern="<phonebook[^>]* owner=\"$(echo ${BOOK} | $SED -r -e 's, ,|,g')\"[^>]*>"
		if echo ${BOOK} | $GREP -qE "(^| )0( |$)"; then
			# book with id 0 has no attributes
			filter_pattern="(${filter_pattern}|<phonebook>)"
		fi
	fi
	echo -n "${filter_pattern}"
}

# prerequisite: input is linearized && whitespace-normalized
filter_by_book_id() {
	if [ "${BOOK}" = "all" ]; then
		# don't filter anything, just pass the input through
		cat -
		return
	fi

	$SED -r -e '{
		s,(<phonebook[ >]),\n\1,g              # put each phonebook-element
		s,(</phonebook>)<,\1\n<,g              # on a separate line
	}' \
	| $SED -r -n -e '{
		/^<phonebook[ >]/ !p                   # keep all non-phonebook-lines
		/^'"$(filter_by_book_id_pattern)"'/ p  # keep all phonebook-lines with id contained in $BOOK
	}' \
	| linearize
}

unescape_xml_entity_references() {
	# see http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
	$SED -r -e '{
		s,&lt\;,<,g
		s,&gt\;,>,g
		s,&amp\;,\&,g
		s,&quot\;,",g
		s,&apos;,'"'"',g
	}'
}

# prerequisite: input is linearized && whitespace-normalized && well-formed
to_tsv() {
	# TODO: consider encoding
	# write header line
	echo -e "VIP\tContactName\tNumber\tNumberType\tQuickDialNumber\tVanityNumber"
	$SED -r -e '{
		s,(<contact[ >]),\n\1,g
		s,(</contact>)<,\1\n<,g
	}' \
	| $SED -r -n \
	-e '/^<contact[ >]/ {                                                                       # consider only contact lines
		/<category\/>/ !{                                                                   # not containing some internal numbers (a contact without category - i.e. <category/> - is an internal number)
			s,<(mod_time|uniqueid)>[^<]*</\1>,,g                                        # remove
			s,<(services|setup)/>,,g                                                    #        irrelevant
			s,</?(contact|person|telephony)[^>]*>,,g                                    #                   elements
			s, (prio|id)="[^"]*",,g                                                     #                           and attributes
			s,(type="fax)_work",\1",g                                                   # replace "fax_work" with just "fax" (cosmetic only)
			p
		}
	}' \
	| $SED -r -e '{
		s,(<number[ >]),\n\1,g                                                              # put each phone number on its own line
	}' \
	| $SED -r -n -e '{                                                                          # convert xml to tsv (tab separated values)
		/^<(category)>[^<]*<\/\1><(realName)>[^<]*<\/\2>$/ {
			s,<(category|realName)>([^<]*)<\/\1>,\2\t,g                                 # keep category & realName in the hold buffer
			h
		}
		/^<number[ >]/ {                                                                    # and add it to each phone number line
			s,<(number)([^>]*)>([^<]*)<\/\1>,\3\t\2,g                                   # extract number, keep other number attributes
			#
			/ type="[^"]*"/ !{                                                          # if type-attribute does not exist
				s,(.*[\t])([^\t]*),\1\t\2,                                          # append empty cell
			}
			/ type="[^"]*"/ {                                                           # if type-attribute exists
				s,(.*[\t])([^\t]*) type="([^"]*)"(.*),\1\3\t\2\4,                   # extract it
			}
			#
			/ quickdial="[^"]*"/ !{                                                     # if quickdial-attribute does not exist
				s,(.*[\t])([^\t]*),\1\t\2,                                          # append empty cell
			}
			/ quickdial="[^"]*"/ {                                                      # if quickdial-attribute exists
				s,(.*[\t])([^\t]*) quickdial="([^"]*)"(.*),\1\3\t\2\4,              # extract it
			}
			#
			/ vanity="[^"]*"/ !{                                                        # if vanity-attribute does not exist
				s,(.*[\t])([^\t]*),\1\t\2,                                          # append empty cell
			}
			/ vanity="[^"]*"/ {                                                         # if vanity-attribute exists
				s,(.*[\t])([^\t]*) vanity="([^"]*)"(.*),\1\3\t\2\4,                 # extract it
			}
			#
			G                                                                           # append category & realName to the pattern space by getting them from the hold buffer
			s,([^\n]*)\n([^\n]*),\2\1,                                                  # put category & realName in front of the number and its attributes
			p
		}
	}' \
	| unescape_xml_entity_references
}

tsv_to_csv() {
	$SED -r -e '{
		s,","",g                                                                            # unescape double-quote sign according to RFC4180 2.7
		s,([^\t]*),"\1",g                                                                   # escape each cell with "
		s/\t/,/g                                                                            # replace tab with comma
	}'
}


# parse arguments
BOOK="active"
METHOD="-" # TODO: change to pbd as soon as implemented
case "${SELF}" in
	*2tsv|*2csv|*2xml)
		TO="${SELF:$((${#SELF}-3)):3}"
		ARGS=$($GETOPT -o hb:m:   --long help,book:,method:     -n "${SELF}" -- "$@")
		;;
	*)
		TO="tsv"
		ARGS=$($GETOPT -o hb:m:t: --long help,book:,method:,to: -n "${SELF}" -- "$@")
		;;
esac
# we assume getopt call is the last command in both case-branches above
if [ "$?" -ne 0 ]; then
	usage
	exit 1
fi

eval set -- "${ARGS}"

while true; do
	case "$1" in
		-h|--help)
			usage
			exit 1
			;;
		-b|--book)
			case "$2" in
				active|all)
					BOOK="$2"
					;;
				*)
					if ! echo $2 | $GREP -qE "^[0-9]+([, ][ ]*[0-9]+)*$"; then
						echo >&2 "Error: invalid $1 parameter \"$2\""
						usage
						exit 1
					fi
					BOOK=$(echo $2 | $TR "," " ")
					;;
			esac
			shift 2
			;;
		-m|--method)
			case "$2" in
				pbd|cat|-)
					METHOD="$2"
					;;
				*)
					echo >&2 "Error: invalid $1 parameter \"$2\""
					usage
					exit 1
					;;
			esac
			shift 2
			;;
		-t|--to)
			case "$2" in
				tsv|csv|xml)
					TO="$2"
					;;
				*)
					echo >&2 "Error: invalid $1 parameter \"$2\""
					usage
					exit 1
					;;
			esac
			shift 2
			;;
		--)
			shift
			break
			;;
		*)
			echo >&2 "Error: internal error!"
			exit 1
			;;
	esac
done

if [ "$#" -ne 0 ]; then
	echo >&2 "Error: unexpected parameter(s) $@"
	usage
	exit 1
fi

if [ "${BOOK}" = "active" ]; then
	BOOK="$(determine_active_phonebook_id)"
fi

# process
case "${TO}" in
	tsv)
		cat - | $DOS2UNIX | linearize | normalize_whitespaces | ensure_well_formed_xml | filter_by_book_id | to_tsv
		;;
	csv)
		cat - | $DOS2UNIX | linearize | normalize_whitespaces | ensure_well_formed_xml | filter_by_book_id | to_tsv | tsv_to_csv
		;;
	xml)
		cat - | $DOS2UNIX | linearize | normalize_whitespaces | ensure_well_formed_xml | filter_by_book_id | remove_unnecessary_var_flash_only_elements | pretty_print_xml
		;;
esac
