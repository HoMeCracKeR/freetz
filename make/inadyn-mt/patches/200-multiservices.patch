--- readme.html
+++ readme.html
@@ -6,8 +6,7 @@
 <body>
 <p><b>inadyn-mt - Simple DYNAMIC DNS client.<br>
 </b></p>
-<p><b>Version 02.24.47, August 2015<br>
-
+<p><b>Version 02.24.47-ms_pid_00_patch, August 2015<br>
 </b></p>
 <p><b>INADYN Advanced Help<br>
 </b></p>
@@ -289,32 +288,24 @@
 </p>
 <p style="margin-left: 20px;">'--ip_server_name &#60;name&#62;[:port] &#60;url&#62;': The client
 IP is detected by calling 'url' from this 'ip_server_name:port'.<br>
-</p>
 
 <p style="margin-left: 40px;">Choice of ip server name parameter option can determine what type of address is updated.
 To update an IPv6 address, simply choose an ip server that supports IPv6, such as, ip6.me /, myip.dk /, dhis.org /, among 
 others.  And, of course, dynamic dns server should be set to one that supports IPv6.  See IPv6 section below for more 
 information.<br>
 </p>
-<p style="margin-left:20px;">'--ip_server_host &#60;host name&#62;': Host name used in http request to ip server <br>&nbsp;&nbsp;&nbsp;&nbsp
-if differnt from ip server name, as when, e.g., ip_server_name is 'localhost:port /' through an SSL bridge.  Defaults to ip server name.<br>
-</p>
 
 </p>
 <p style="margin-left: 20px;">'--dyndns_server_name &#60;name&#62;[:port]': dynamic dns server name, and optional port.</name>
 </p>
-<p style="margin-left: 40px;">The server that receives the update DNS request.<br>
+<p style="margin-left: 40px;">The server that receives the update DNS
+request.<br>
 If no proxy is wanted, then it is enough to set the dyndns system. The default servers will be taken.<br>
 </p>
 <p style="margin-left: 20px;">'--dyndns_server_url &#60;url&#62;': full URL relative to DynDNS server root.
 </p>
-
-<p style="margin-left: 20px;">'--dyndns_server_host &#60;host name&#62;': Host name used in http update DNS request, if different from<br> &nbsp;&nbsp;&nbsp;&nbsp
-dyndns server name, as when, e.g., dyndns_server_name is 'localhost:port' through an SSL bridge.  Defaults to dyndns server name.
-</p>
-
 <p style="margin-left: 20px;">'--dyndns_system &#60;NAME&#62;': optional DYNDNS service type. SHOULD be one of the following:</p>
-<p style="margin-left: 40px;">-For dyndns.org DNS system: dyndns@dyndns.org OR statdns@dyndns.org OR custom@dyndns.org<br>
+<p style="margin-left: 40px;">-For dyndns.org DNS system: dyndns@dyndns.org OR statdns@dyndns.org OR custom@dyndns.org.<br>
 -For freedns.afraid.org DNS system: default@freedns.afraid.org<br>
 -For zoneedit.com: default@zoneedit.com<br>
 -For no-ip.com: default@no-ip.com<br>
@@ -519,6 +510,10 @@
 <b>HISTORY<br><br>
 
 </b>
+Ver.&nbsp; inadyn-mt 2.24.47-ms_pid_patch_00 - August 2015<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Multiple services, in single program instance<br><br>
+
 Ver.&nbsp; inadyn-mt 2.24.47 - August 2015<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - avoid unnecessary config change related alias updates<br>
--- src/cache_list.c
+++ src/cache_list.c
@@ -62,6 +62,7 @@
 {
 
 	int	i;
+	int	ii;
 	char	*alias_ip_v;
 	char	*alias_cmp_src;
 	int	is_auto=false;
@@ -73,41 +74,44 @@
 	alias_ip_v=safe_malloc(strlen(alias)+strlen(alias_type)+2);
 	sprintf(alias_ip_v,"%s:%s",alias,alias_type);
 
-	for (i=0;i<p_dyndns->alias_info.count;i++) {
+	for (ii=0;ii<p_dyndns->srv_cnt;ii++) {
 
-		/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
+		for (i=0;i<p_dyndns->info[ii].alias_info.count;i++) {
 
-		alias_cmp_src=safe_malloc(strlen(p_dyndns->alias_info.names[i].name)+9);
-		sprintf(alias_cmp_src,"%s:%s",p_dyndns->alias_info.names[i].name,p_dyndns->alias_info.names[i].ip_v);
+			/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
 
-		if ((!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->alias_info.names[i].ip_v,DUAL_LIST)))
-			&& !(strcmp(p_dyndns->alias_info.names[i].name,alias))
-			&& !(strcmp(p_dyndns->info.dyndns_server_name.name[ip_store],server))) {
+			alias_cmp_src=safe_malloc(strlen(p_dyndns->info[ii].alias_info.names[i].name)+9);
+			sprintf(alias_cmp_src,"%s:%s",p_dyndns->info[ii].alias_info.names[i].name,p_dyndns->info[ii].alias_info.names[i].ip_v);
 
-			p_dyndns->alias_info.update_succeeded[i]=is_updated;
+			if ((!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->info[ii].alias_info.names[i].ip_v,DUAL_LIST)))
+				&& !(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias))
+				&& !(strcmp(p_dyndns->info[ii].dyndns_server_name.name,server))) {
 
-			is_found=true;
-		}
-		else {
+				p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
 
-			/*for aliases of type auto, set update state for either ip6, ip4*/
+				is_found=true;
+			}
+			else {
 
-			if (is_auto)
+				/*for aliases of type auto, set update state for either ip6, ip4*/
 
-				if (!(strcmp(p_dyndns->alias_info.names[i].name,alias))
-					&& !(strcmp(p_dyndns->info.dyndns_server_name.name[ip_store],server))) {
+				if (is_auto)
 
-					p_dyndns->alias_info.update_succeeded[i]=is_updated;
+					if (!(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias))
+						&& !(strcmp(p_dyndns->info[ii].dyndns_server_name.name,server))) {
 
-					is_found=true;
-				}
-		}
+						p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
 
-		free(alias_cmp_src);
+						is_found=true;
+					}
+			}
+
+			free(alias_cmp_src);
 
-		if (is_found)
+			if (is_found)
 
-			break;
+				break;
+		}
 	}
 
 	free(alias_ip_v);
@@ -295,6 +299,20 @@
 	}
 }
 
+static int number_of_aliases(DYN_DNS_CLIENT *p_dyndns)
+{
+	char    i;
+	int     alias_count=0;
+
+
+	for (i=0;i<MAX_DNS_SERVER;i++) {
+
+		alias_count+=p_dyndns->info[i].alias_info.count;
+	}
+
+	return alias_count;
+}
+
 RC_TYPE ip_cache_list_read(DYN_DNS_CLIENT *p_dyndns,volatile int *is_need_update)
 {
 	FILE			*fp=NULL;
@@ -383,7 +401,7 @@
 			fclose(fp);
 	}
 
-	*is_need_update=(alias_count<p_dyndns->alias_info.count);
+	*is_need_update=(alias_count<number_of_aliases(p_dyndns));
 
 	return rc;
 }
@@ -393,7 +411,7 @@
   If alias not marked as successfull update, look up cache entry & set ip(s) to that/those and return true.
   Otherwise if not in cache, return false, with ip's set NULL.  
 */
-static int get_update_addresses(DYN_DNS_CLIENT *p_self,int alias_index,char **p_ip_addr,char **p_ip4_addr,char **p_ip6_addr,
+static int get_update_addresses(DYN_DNS_CLIENT *p_self,int svr_index,int alias_index,char **p_ip_addr,char **p_ip4_addr,char **p_ip6_addr,
 				int is_dyndns_dual,DYNDNS_IPV ip_enum)
 {
 	int	cache_index;
@@ -402,23 +420,23 @@
 	*p_ip4_addr=NULL;
 	*p_ip6_addr=NULL;
 
-	if (p_self->alias_info.update_succeeded[alias_index]) {
+	if (p_self->info[svr_index].alias_info.update_succeeded[alias_index]) {
 
 		if (!(is_dyndns_dual))
 
-			*p_ip_addr=p_self->info.my_ip_address.name[ip_enum];
+			*p_ip_addr=p_self->info[svr_index].i_face.my_ip_address.name[ip_enum];
 		else {
-			*p_ip4_addr=p_self->info.my_ip_address.name[ip_4];
-			*p_ip6_addr=p_self->info.my_ip_address.name[ip_6];
+			*p_ip4_addr=p_self->info[svr_index].i_face.my_ip_address.name[ip_4];
+			*p_ip6_addr=p_self->info[svr_index].i_face.my_ip_address.name[ip_6];
 		}
 	}
 	else {
 		if (!(is_dyndns_dual)) {
 
 			cache_index=ip_cache_list_short_index_of(&p_self->ip_cache_list,
-						p_self->alias_info.names[alias_index].name,
-						p_self->info.dyndns_server_host,
-						p_self->alias_info.names[alias_index].ip_v);
+						p_self->info[svr_index].alias_info.names[alias_index].name,
+						p_self->info[svr_index].dyndns_server_host,
+						p_self->info[svr_index].alias_info.names[alias_index].ip_v);
 
 			if (-1==cache_index)
 
@@ -428,8 +446,8 @@
 		}
 		else {
 			cache_index=ip_cache_list_short_index_of(&p_self->ip_cache_list,
-						p_self->alias_info.names[alias_index].name,
-						p_self->info.dyndns_server_host,
+						p_self->info[svr_index].alias_info.names[alias_index].name,
+						p_self->info[svr_index].dyndns_server_host,
 						"ipv4");
 
 			if (!(-1==cache_index))
@@ -437,8 +455,8 @@
 				*p_ip4_addr=p_self->ip_cache_list.saved_ip_cache[cache_index].ip;
 
 			cache_index=ip_cache_list_short_index_of(&p_self->ip_cache_list,
-					p_self->alias_info.names[alias_index].name,
-					p_self->info.dyndns_server_host,
+					p_self->info[svr_index].alias_info.names[alias_index].name,
+					p_self->info[svr_index].dyndns_server_host,
 					"ipv6");
 
 			if (!(-1==cache_index))
@@ -455,125 +473,141 @@
 }
 
 RC_TYPE ip_cache_list_update_state(DYN_DNS_CLIENT *p_self,int updates_needed,int success_updates,
-										  int config_fails,RC_TYPE *rc)
+						int config_fails,RC_TYPE rc,char srv_index,volatile int *is_global_success_updates,
+						volatile int *is_global_in_proc_update_pending)
 {
-	FILE *fp;
+	FILE			*fp;
+	DYNDNS_INFO_TYPE	*info;
+
+
+	info=&p_self->info[srv_index];
 
+	/*global successes maintained across server iterations in main loop*/
+	*is_global_success_updates=(*is_global_success_updates || success_updates);
 
-//	if (config_fails==p_self->alias_info.count) {
-	if (config_fails) {
+	if (config_fails==info->alias_info.count) {
 
-//		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "All config fail in update_update_state...\n"));
+		rc=RC_DYNDNS_RSP_CONFIG;
 
-		*rc=RC_DYNDNS_RSP_CONFIG;
+		if (!(srv_index==p_self->srv_cnt-1))
+
+			return rc;
 	}
-	else {
 
-		if (success_updates) {
+	/*
+		reset on last server if any server successes
+	*/
+	if (*is_global_success_updates && srv_index==p_self->srv_cnt-1) {
+
+		/*reset forced update period*/
+		p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
+		p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;
 
-			/*reset forced update period*/
-			p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
-			p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;
+		if ((fp=utf_fopen(p_self->time_cache, "w"))) {
 
-			if ((fp=utf_fopen(p_self->time_cache, "w"))) {
+			fprintf(fp,"%ld",time(NULL));
 
-				fprintf(fp,"%ld",time(NULL));
+			fclose(fp);
+		}
 
-				fclose(fp);
-			}
+		fp=utf_fopen(p_self->ip_cache, "w");
 
-			fp=utf_fopen(p_self->ip_cache, "w");
+		{
+			IP_CACHE_LIST	this_cache_list;
+			char		*p_ip_addr;
+			char		*p_ip4_addr;
+			char		*p_ip6_addr;
+			int		i;
+			int		ii;
+			DYNDNS_IPV	ip_enum;
+			BOOL		is_dyndns_dual;
 
-			{
-				IP_CACHE_LIST	this_cache_list;
-				char		*p_ip_addr;
-				char		*p_ip4_addr;
-				char		*p_ip6_addr;
-				int		i;
-				DYNDNS_IPV	ip_enum;
-				BOOL		is_dyndns_dual;
+			memset(&this_cache_list,0,sizeof(IP_CACHE_LIST));
 
-				memset(&this_cache_list,0,sizeof(IP_CACHE_LIST));
+			for (ii=0;ii<p_self->srv_cnt;ii++) {
 
-				for (i=0;i<p_self->alias_info.count;i++) {
+				for (i=0;i<p_self->info[ii].alias_info.count;i++) {
 
-					is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST));
+					is_dyndns_dual=(NULL!=strstr(p_self->info[ii].alias_info.names[i].ip_v,DUAL_LIST));
 
-					ip_enum=p_self->alias_info.names[i].ip_v_enum;
+					ip_enum=p_self->info[ii].alias_info.names[i].ip_v_enum;
 
 					/*figure out whether updated to new, or failed and need rewrite cache to that read last*/
-					if (!(get_update_addresses(p_self,i,&p_ip_addr,&p_ip4_addr,&p_ip6_addr,is_dyndns_dual,ip_enum)))
+					if (!(get_update_addresses(p_self,ii,i,&p_ip_addr,&p_ip4_addr,&p_ip6_addr,is_dyndns_dual,ip_enum)))
 
 						continue;
 
 					if (!(is_dyndns_dual)) {
 
 						ip_cache_list_add(&this_cache_list,p_ip_addr,
-								p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v,
-								p_self->info.dyndns_server_host);
+								p_self->info[ii].alias_info.names[i].name,p_self->info[ii].
+								alias_info.names[i].ip_v,p_self->info[ii].dyndns_server_host);
 						if (fp)
 							fprintf(fp,"%s %s:%s %s\n",p_ip_addr,
-								p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v,
-								p_self->info.dyndns_server_host);
+								p_self->info[ii].alias_info.names[i].name,p_self->info[ii].
+								alias_info.names[i].ip_v,p_self->info[ii].dyndns_server_host);
 					}
 					else {
 						if (p_ip4_addr)
 
-							ip_cache_list_add(&this_cache_list,p_ip4_addr,p_self->alias_info.names[i].name,
-								"ip4",p_self->info.dyndns_server_host);
+							ip_cache_list_add(&this_cache_list,p_ip4_addr,p_self->info[ii].alias_info.names[i].name,
+								"ip4",p_self->info[ii].dyndns_server_host);
 
 						if (p_ip6_addr)
 
-							ip_cache_list_add(&this_cache_list,p_ip6_addr,p_self->alias_info.names[i].name,
-								"ip6",p_self->info.dyndns_server_host);
+							ip_cache_list_add(&this_cache_list,p_ip6_addr,p_self->info[ii].alias_info.names[i].name,
+								"ip6",p_self->info[ii].dyndns_server_host);
 
 						if (fp) {
 
 							if (p_ip4_addr)
 
-								fprintf(fp,"%s %s:ip4 %s\n",p_ip4_addr,p_self->alias_info.names[i].name,
-									p_self->info.dyndns_server_host);
+								fprintf(fp,"%s %s:ip4 %s\n",p_ip4_addr,p_self->info[ii].alias_info.names[i].name,
+									p_self->info[ii].dyndns_server_host);
 
 							if (p_ip6_addr)
 
-								fprintf(fp,"%s %s:ip6 %s\n",p_ip6_addr,p_self->alias_info.names[i].name,
-									p_self->info.dyndns_server_host);
+								fprintf(fp,"%s %s:ip6 %s\n",p_ip6_addr,p_self->info[ii].alias_info.names[i].name,
+									p_self->info[ii].dyndns_server_host);
 						}
 					}
 				}
+			}
 
-				if (fp)
-					fclose(fp);
+			if (fp)
+				fclose(fp);
 
-				ip_cache_list_destruct(&p_self->ip_cache_list);
-				p_self->ip_cache_list.saved_ip_cache=this_cache_list.saved_ip_cache;
-				p_self->ip_cache_list.count=this_cache_list.count;
-			}
+			ip_cache_list_destruct(&p_self->ip_cache_list);
+			p_self->ip_cache_list.saved_ip_cache=this_cache_list.saved_ip_cache;
+			p_self->ip_cache_list.count=this_cache_list.count;
 		}
+	}
 
-		/*any pending?*/
-		if (!(updates_needed && !(success_updates==updates_needed))) {
+	/*any pending?*/
+	if ((updates_needed && !(success_updates==updates_needed))) {
 
-			/*no pendings*/
-			if (success_updates) {
+		if (rc==RC_OK) /*not break after http client init*/
 
-				p_self->is_forced_update_attempted=false;
+			rc=RC_DYNDNS_RSP_NOTOK;
 
-				*rc=RC_OK;
-			}
-		}
-		else {
+		DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
+						updates_needed-success_updates));
+	}
+	else {
 
-			if (*rc==RC_OK) /*not break after http client init*/
+		/*no pendings this server*/
+		if (success_updates) {
 
-				*rc=RC_DYNDNS_RSP_NOTOK;
+			/*no pendings any server*/
+			if (!(*is_global_in_proc_update_pending) && srv_index==p_self->srv_cnt-1)
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
-						updates_needed-success_updates));
+				p_self->is_forced_update_attempted=false;
+
+			rc=RC_OK;
 		}
 	}
 
-	return *rc;
+	return rc;
 }
 
 void ip_cache_list_add(IP_CACHE_LIST *ip_cache_list,char *ip,char *alias,char *ip_type,char *server)
--- src/cache_list.h
+++ src/cache_list.h
@@ -26,10 +26,11 @@
 
 #include "dyndns.h"
 
+RC_TYPE ip_cache_cache_list(DYN_DNS_CLIENT *p_dyndns);
 void ip_cache_list_add(IP_CACHE_LIST *ip_cache_list,char *ip,char *alias,char *ip_type,char *server);
 int ip_cache_list_index_of(IP_CACHE_LIST *s_list,void *in_addr,char *ip,char *alias,char *server,char *ip_alias_type);
 int ip_cache_list_short_index_of(IP_CACHE_LIST *s_list,char *alias,char *server,char *ip_type);
-RC_TYPE ip_cache_list_update_state(DYN_DNS_CLIENT *p_self,int updates_needed,int success_updates,int config_fails,RC_TYPE *rc);
+RC_TYPE ip_cache_list_update_state(DYN_DNS_CLIENT *p_self,int updates_needed,int success_updates,int config_fails,RC_TYPE rc,char srv_index,volatile int *is_global_success_updates,volatile int *is_global_in_proc_update_pending);
 RC_TYPE ip_cache_list_read(DYN_DNS_CLIENT *p_dyndns,volatile int *is_need_update);
 RC_TYPE ip_cache_list_update(DYN_DNS_CLIENT *p_dyndns,int *is_need_update);
 void ip_cache_list_destruct(IP_CACHE_LIST *ip_cache_list);
--- src/config.h
+++ src/config.h
@@ -96,9 +96,6 @@
 /* Define to 1 if the system has the type `_Bool'. */
 #define HAVE__BOOL 1
 
-/* install prefix */
-#define META_ROOT "/usr/share/inadyn-mt"
-
 /* Disallow load some libraries dynamically */
 /* #undef NO_DYN_LOAD */
 
--- src/dyndns.c
+++ src/dyndns.c
@@ -105,7 +105,9 @@
 #endif
 
 #include "errorcode.h"
+
 #include "path.h"
+
 #include "dyndns.h"
 #include "debug_if.h"
 #include "base64.h"
@@ -127,13 +129,14 @@
 
 	DYN_DNS_CLIENT	*p_dyndns;
 #ifndef _WIN32
-	void		*p_data;
+	void			*p_data;
 #else
-	RAS_THREAD_DATA	*p_data;
+	RAS_THREAD_DATA *p_data;
 #endif
 
 } CB_ALERT_DATA;
 
+
 /*
 	Define this, and link with winmm.lib
 	for audible alerts (see inadyn-mt/extra/wav/alarm.wav)
@@ -145,10 +148,12 @@
 
 #endif
 
-static volatile	BOOL	global_is_online=true;
-static volatile BOOL	is_online_thread_exit=false;
-static volatile BOOL	is_alert_thread_exit=false;
-static volatile BOOL	is_update_pending=false;
+static volatile	BOOL		global_is_online=true;
+static volatile BOOL		is_online_thread_exit=false;
+static volatile BOOL		is_alert_thread_exit=false;
+static volatile BOOL		is_global_update_pending=false;
+static volatile BOOL		is_global_in_proc_update_pending=false;
+static volatile BOOL		is_global_success_updates=false;
 
 #ifdef USE_THREADS
 
@@ -175,52 +180,73 @@
 #include "debug_service.h"
 #include "unicode_util.h"
 
-static BOOL				returnSignaled=false;
-static unsigned long			thread_online_test=0;
-static unsigned long			thread_alert=0;
+static BOOL		returnSignaled=false;
+static unsigned long	thread_online_test=0;
+static unsigned	long	thread_alert=0;
 
 #endif
 
 static int do_is_dyndns_online(DYN_DNS_CLIENT *p_self);
 static int is_exit_requested(DYN_DNS_CLIENT *p_self);
 static int is_exit_requested_void(void *p_self);
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i);
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt);
 static void exit_online_test_threads();
 static RC_TYPE dyn_dns_shutdown(DYN_DNS_CLIENT *p_self);
 static RC_TYPE do_dyn_dns_init(DYN_DNS_CLIENT *p_self);
 static RC_TYPE init_update_loop(DYN_DNS_CLIENT *p_dyndns,int argc, char* argv[],void **p_data,BOOL *init_flag);
 
+#ifdef USE_SNDFILE
+#ifdef USE_THREADS
+
+static int is_dyndns_online(DYN_DNS_CLIENT *p_self,void *p_data);
+
+#ifndef _WIN32
+static void *is_dyndns_online_thread(void *p_data);
+static void *alert_if_offline_thread(void *p_data);
+#else
+static void is_dyndns_online_thread(void *p_data);
+static void alert_if_offline_thread(void *p_data);
+#endif
+
+#else
+
+void alert_if_offline(DYN_DNS_CLIENT *p_dyndns,void *p_data);
+
+#endif
+#endif
+
 #define MD5_DIGEST_BYTES (16)
 
 /* DNS systems specific configurations*/
 
-DYNDNS_ORG_SPECIFIC_DATA dyndns_org_dynamic =	{"dyndns"};
-DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom =	{"custom"};
-DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static =	{"statdns"};
-
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int nr, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_custom_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-
-static RC_TYPE is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char* p_ok_string);
-static RC_TYPE is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
-static RC_TYPE is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string);
+DYNDNS_ORG_SPECIFIC_DATA dyndns_org_dynamic = {"dyndns"};
+DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom = {"custom"};
+DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static = {"statdns"};
+
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this,char srv_cnt, int nr, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_custom_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char*p_rsp, char* p_ok_string,char srv_cnt);
 
 DYNDNS_SYSTEM_INFO dns_system_table[] =
     {
@@ -315,6 +341,13 @@
 			DYNDNS_MY_IP_SERVER, DYNDNS_MY_IP_SERVER_URL,
 			"ipv4.tunnelbroker.net", "/ipv4_end.php?", NULL}},
 
+		{HE_DEFAULT,
+			{"default@he.net", NULL,
+			(DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)is_dyndns_server_rsp_ok,
+			(DNS_SYSTEM_REQUEST_FUNC) get_req_for_he_dns_server,
+			"checkip.dns.he.net", "/",
+			"dyn.dns.he.net", "/nic/update?", NULL}},
+
 		/* Support for dynsip.org by milkfish, from DD-WRT */
 		{DYNSIP_DEFAULT,
 			{"default@dynsip.org", NULL,
@@ -433,7 +466,7 @@
 	DYN_DNS_CMD	old_cmd;
 
 
-	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_update_pending,p_self);
+	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_global_update_pending,p_self);
 
 	if (old_cmd != NO_CMD)
 	{
@@ -441,10 +474,10 @@
 	}
 
 #ifdef USE_THREADS
-	/*keeping track of time out of this routine (for forced update period) -- 
-	  a bit experimental, but appears unneccessary.  Easy enough to 
+	/*keeping track of time out of this routine (for forced update period) --
+	  a bit experimental, but appears unneccessary.  Easy enough to
 	  remove though -- these two functions here, the restart below and in
-	  do_update_alias_table, the create in init, and the destroy in main.  
+	  do_update_alias_table, the create in init, and the destroy in main.
 	  Compiler option?  :-)
 	*/
 	stop_timer(&update_timer);
@@ -452,7 +485,6 @@
 	dec_forced_update_count(p_self);
 #endif
 
-
 	while(1)
 	{
 
@@ -473,23 +505,23 @@
 
 		if (!(p_self->forced_update_counter)) {
 
-			if (!(is_update_pending && !(p_self->retry_pending_off))) {
+			if (!(is_global_update_pending && !(p_self->retry_pending_off))) {
 
 				/*
 					If not retrying pendings, forced update retries fallback to update_period.
 
-					So, this setup performs as inadyn if retry pendings off.  But, it will attempt
-					a forced update before update_period expiration if havn't tried since last update
-					and not doing pendings.  A bit overdone perhaps...the idea is to decouple ip
-					change checks (and associated interval) from required account maintenance ip
-					updates.  A failed update prompted by either update interval trigger will cause
-					mode shift to pending interval (15 minute default) if pending updates not explicitly
+					So, this setup performs as inadyn if retry pendings off.  But, it will attempt 
+					a forced update before update_period expiration if havn't tried since last update 
+					and not doing pendings.  A bit overdone perhaps...the idea is to decouple ip 
+					change checks (and associated interval) from required account maintenance ip 
+					updates.  A failed update prompted by either update interval trigger will cause 
+					mode shift to pending interval (15 minute default) if pending updates not explicitly 
 					turned off.
 				*/
 
-				if (!(is_update_pending) || !(p_self->is_forced_update_attempted)) {
+				if (!(is_global_update_pending) || !(p_self->is_forced_update_attempted)) {
 
-					if (!(p_self->is_bad_config)) {
+					if (!(p_self->is_global_bad_config)) {
 
 						DBG_PRINTF((LOG_INFO,"I:DYNDNS: Command loop breaking for forced update...\n"));
 
@@ -550,14 +582,13 @@
                 is_online_thread_exit=true;
         }
 #endif
-
         p_self->cmd=i_event;
 }
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int cnt,DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,DYNDNS_SYSTEM *p_sys_info)
 {
 
-	int	bytes_stored=0;
+	int bytes_stored=0;
 
 
 	DYNDNS_ORG_SPECIFIC_DATA *p_dyndns_specific =
@@ -567,53 +598,53 @@
 
 
 	bytes_stored=sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	                     p_self->info.dyndns_server_url,
+	                     p_self->info[srv_cnt].dyndns_server_name.url,
 	                     p_dyndns_specific->p_system,
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.my_ip_address.name[ip_store],
-	                     p_self->wildcard ? "ON" : "OFF",
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.dyndns_server_host,
-	                     p_self->info.credentials.p_enc_usr_passwd_buffer);
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	                     p_self->info[srv_cnt].wildcard ? "ON" : "OFF",
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].dyndns_server_host,
+	                     p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 
 
 	return bytes_stored;
 }
 
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.hashes[cnt].str,
-                       p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.hashes[cnt].str,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_EASYDNS_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
-	               p_self->wildcard ? "ON" : "OFF",
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].wildcard ? "ON" : "OFF",
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 
@@ -624,28 +655,28 @@
 	}
 
 	return sprintf(p_self->p_req_buffer, GENERIC_TZO_AUTH_MY_IP_REQUEST_FORMAT,
-		       p_self->info.dyndns_server_url,
-		       p_self->alias_info.names[cnt].name,
-		       p_self->info.credentials.my_username,
-		       p_self->info.credentials.my_password,
-		       p_self->info.my_ip_address.name[ip_store],
-		       p_self->info.dyndns_server_host);
+		       p_self->info[srv_cnt].dyndns_server_name.url,
+		       p_self->info[srv_cnt].alias_info.names[cnt].name,
+		       p_self->info[srv_cnt].credentials.my_username,
+		       p_self->info[srv_cnt].credentials.my_password,
+		       p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+		       p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, SITELUTIONS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->info.credentials.my_username,
-	               p_self->info.credentials.my_password,
-	               p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].credentials.my_username,
+	               p_self->info[srv_cnt].credentials.my_password,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	unsigned char	digestbuf[MD5_DIGEST_BYTES];
 	char		digeststr[MD5_DIGEST_BYTES*2+1];
@@ -657,108 +688,122 @@
 	memset(&digestbuf,0,MD5_DIGEST_BYTES);
 	memset(&digeststr,0,MD5_DIGEST_BYTES*2+1);
 
+
 	if (p_self == NULL)
 	{
 		/* 0 == "No characters written" */
 		return 0;
 	}
 
-	md5_buffer(p_self->info.credentials.my_password,
-		   strlen(p_self->info.credentials.my_password), digestbuf);
+	md5_buffer(p_self->info[srv_cnt].credentials.my_password,
+		   strlen(p_self->info[srv_cnt].credentials.my_password), digestbuf);
 
 	for (i = 0; i < MD5_DIGEST_BYTES; i++)
 		sprintf(&digeststr[i*2], "%02x", digestbuf[i]);
 
 	return sprintf(p_self->p_req_buffer, HE_IPV6TB_UPDATE_MY_IP_REQUEST_FORMAT,
-				p_self->info.dyndns_server_url,
-				p_self->info.my_ip_address.name[ip_store],
-				p_self->info.credentials.my_username,
+				p_self->info[srv_cnt].dyndns_server_name.url,
+				p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				p_self->info[srv_cnt].credentials.my_username,
 				digeststr,
-				p_self->alias_info.names[cnt].name,
-				p_self->info.dyndns_server_host);
+				p_self->info[srv_cnt].alias_info.names[cnt].name,
+				p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_he_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+{
+
+	(void)p_sys_info;
+
+	return sprintf(p_self->p_req_buffer, HE_DEFAULT_UPDATE_MY_IP_REQUEST_FORMAT,
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+				   p_self->info[srv_cnt].dyndns_server_host);
+}
+
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, DHIS_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.credentials.my_password,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].credentials.my_password,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, ZERIGO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,
-				   p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+				   p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, TWODNS_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,
-				   p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+				   p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, void *p_specific_data)
+static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self,char srv_cnt, void *p_specific_data)
 {
 	(void)p_specific_data;
 
 	return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST,
-	               p_self->info.ip_server_url, p_self->info.ip_server_host);
+	               p_self->info[srv_cnt].ip_server_name.url,p_self->info[srv_cnt].ip_server_host);
 }
 
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_host);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_host);
 }
 
-static int get_req_for_generic_custom_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_custom_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 
 	/*be backward compatible relative to new ip_param option*/
-	if (!(p_self->ip_param))
+	if (!(p_self->info[srv_cnt].ip_param))
 
 		return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-				p_self->info.dyndns_server_url,
-				p_self->alias_info.names[cnt].name,
-				p_self->info.credentials.p_enc_usr_passwd_buffer,
-				p_self->info.dyndns_server_host);
+				p_self->info[srv_cnt].dyndns_server_name.url,
+				p_self->info[srv_cnt].alias_info.names[cnt].name,
+				p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+				p_self->info[srv_cnt].dyndns_server_host);
 	else {
 		/*assume if either of these, not doing basic auth*/
-		if (!(p_self->id_param || p_self->pw_param))
+		if (!(p_self->info[srv_cnt].id_param || p_self->info[srv_cnt].pw_param))
 
 			return sprintf(p_self->p_req_buffer, GENERIC_DNS_CUSTOM_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-						p_self->info.dyndns_server_url,
-						p_self->alias_info.names[cnt].name,
-						p_self->ip_param,
-						p_self->info.my_ip_address.name[ip_store],
-						p_self->wildcard ? "ON" : "OFF",
-						p_self->info.credentials.p_enc_usr_passwd_buffer,
-						p_self->info.dyndns_server_host);
+						p_self->info[srv_cnt].dyndns_server_name.url,
+						p_self->info[srv_cnt].alias_info.names[cnt].name,
+						p_self->info[srv_cnt].ip_param,
+						p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+						p_self->info[srv_cnt].wildcard ? "ON" : "OFF",
+						p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+						p_self->info[srv_cnt].dyndns_server_host);
 
 		else {
 
@@ -770,19 +815,19 @@
 			  We'll throw caution to the wind, and brazenly assume, we have both.  Just kidding - servers file probably has both.
 			*/
 
-			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "NOT BASIC AUTH.  ip_param:  %s, id_param:  %s, pw_param:  %s...\n",p_self->ip_param,p_self->id_param,p_self->pw_param));
+			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "NOT BASIC AUTH.  ip_param:  %s, id_param:  %s, pw_param:  %s...\n",p_self->info[srv_cnt].ip_param,p_self->info[srv_cnt].id_param,p_self->info[srv_cnt].pw_param));
 
 			return sprintf(p_self->p_req_buffer, GENERIC_DNS_CUSTOM_MY_IP_REQUEST_FORMAT,
-						p_self->info.dyndns_server_url,
-						p_self->alias_info.names[cnt].name,
-						p_self->ip_param,
-						p_self->info.my_ip_address.name[ip_store],
-						p_self->id_param,
-						p_self->info.credentials.my_username,
-						p_self->pw_param,
-						p_self->info.credentials.my_password,
-						p_self->wildcard ? "ON" : "OFF",
-						p_self->info.dyndns_server_host);
+						p_self->info[srv_cnt].dyndns_server_name.url,
+						p_self->info[srv_cnt].alias_info.names[cnt].name,
+						p_self->info[srv_cnt].ip_param,
+						p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+						p_self->info[srv_cnt].id_param,
+						p_self->info[srv_cnt].credentials.my_username,
+						p_self->info[srv_cnt].pw_param,
+						p_self->info[srv_cnt].credentials.my_password,
+						p_self->info[srv_cnt].wildcard ? "ON" : "OFF",
+						p_self->info[srv_cnt].dyndns_server_host);
 		}
 	}
 }
@@ -795,8 +840,9 @@
   so no match in success list or config list IS fatal.  Eventually all will be converted to the inversion - I'm
   not as paranoid (or ignorant) about TCP as I was.
 */
-static RC_TYPE is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string)
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
+	/*fail on (badauth, nohost, notfqdn, !yours, etc)*/
 
 	(void) p_ok_string;
 
@@ -811,10 +857,15 @@
 	return RC_DYNDNS_RSP_CONFIG;
 }
 
-static RC_TYPE is_freedns_server_rsp_ok(DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string)
+/* Freedns afraid.org.specific response validator.
+    ok blabla and n.n.n.n
+    fail blabla and n.n.n.n
+    are the good answers. We search our own IP address in response and that's enough.
+*/
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 
-	if ((!(strstr(p_rsp, "ERROR")) && strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]))
+	if ((!(strstr(p_rsp, "ERROR")) && strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]))
 		|| strstr(p_rsp, "has not changed"))
 
 		return RC_OK;
@@ -826,7 +877,12 @@
 	return RC_DYNDNS_RSP_CONFIG;
 }
 
-static RC_TYPE is_zoneedit_server_rsp_ok(DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string)
+/**
+	the OK codes are:
+		CODE=200
+		CODE=707, for duplicated updates
+*/
+BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	(void) p_ok_string;
 
@@ -851,7 +907,7 @@
 /**
 	NOERROR is the OK code here
 */
-static RC_TYPE is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string)
+BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	if (strstr(p_rsp, "NOERROR"))
 
@@ -869,7 +925,7 @@
 	return RC_DYNDNS_RSP_NOTOK;
 }
 
-static RC_TYPE is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char* p_ok_string)
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 
 	if (strstr(p_rsp,"success"))
@@ -891,11 +947,11 @@
 /* HE ipv6 tunnelbroker specific response validator.
    own IP address and 'already in use' are the good answers.
 */
-static RC_TYPE is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string)
+static BOOL is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	(void)p_ok_string;
 
-	if (strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) || strstr(p_rsp,"already in use"))
+	if (strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) || strstr(p_rsp,"already in use"))
 
 		return RC_OK;
 
@@ -909,7 +965,7 @@
 /* TZO specific response validator.
    If we have an HTTP 302 the update wasn't good and we're being redirected
 */
-static RC_TYPE is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string)
+static BOOL is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 
 	if (strstr(p_rsp,"200") || strstr(p_rsp,"304"))
@@ -929,9 +985,10 @@
 	return RC_DYNDNS_RSP_NOTOK;
 }
 
-static RC_TYPE is_dhis_server_rsp_ok(DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char* p_ok_string)
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
-	if (strstr(p_rsp,p_self->info.my_ip_address.name[ip_store]))
+
+	if (strstr(p_rsp,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]))
 
 		return RC_OK;
 
@@ -946,7 +1003,7 @@
 	return RC_DYNDNS_RSP_NOTOK;
 }
 
-static RC_TYPE is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char* p_ok_string)
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 	if (strstr(p_rsp,"Status: 200"))
 
@@ -963,22 +1020,22 @@
 	return RC_DYNDNS_RSP_NOTOK;
 }
 
-static BOOL is_rsp_in_list(char* haystack,gen_list rsp_list,DYN_DNS_CLIENT *p_dyndns,int alias_index)
+static BOOL is_rsp_in_list(char* haystack,gen_list rsp_list,DYN_DNS_CLIENT *p_dyndns,int srv_index,int alias_index)
 {
 	gen_list_itr		itr;
 	char			*s_exp;
 	struct EXP_MAPPING	*p_mapping=safe_malloc(sizeof(struct EXP_MAPPING));
 
-	itr=list_get_itr(rsp_list);
-	list_begin(rsp_list,itr);
-
 	p_mapping->p_dyndns=p_dyndns;
+	p_mapping->server_index=srv_index;
 	p_mapping->alias_index=alias_index;
 
+	itr=list_get_itr(rsp_list);
+	list_begin(rsp_list,itr);
+
 	do {
 
-		DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "is_rsp_in_list checking list param:  %s\n",
-				vars_expanded_str(arg_to_val,p_mapping,&s_exp,list_entry_item(itr))));
+		DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "is_rsp_in_list checking list param:  %s\n",vars_expanded_str(arg_to_val,p_mapping,&s_exp,list_entry_item(itr))));
 
 		if (strstr(haystack,s_exp)) {
 
@@ -1013,33 +1070,32 @@
 	RC_DYNDNS_SERVER_ERROR,
 	RC_DYNDNS_RSP_CONFIG
 */
-static RC_TYPE is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string)
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, int alias_index, char *p_rsp, char *p_ok_string, char srv_cnt)
 {
-
 	DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "entered is_generic_server_rsp_ok...\n"));
 
-	if (!(p_self->rsp_success_codes)) {
+	if (!(p_self->info[srv_cnt].rsp_success_codes)) {
 
 		DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "No svr_rsp_success set in generic server response check...\n"));
 	}
 	else {
-		if (!(p_self->is_ip_in_svr_rsp)) {
+		if (!(p_self->info[srv_cnt].is_ip_in_svr_rsp)) {
 
-			if (is_rsp_in_list(p_rsp,p_self->rsp_success_codes,p_self,alias_index))
+			if (is_rsp_in_list(p_rsp,p_self->info[srv_cnt].rsp_success_codes,p_self,srv_cnt,alias_index))
 
 				return RC_OK;
 		}
 		else {
-			if (is_rsp_in_list(p_rsp,p_self->rsp_success_codes,p_self,alias_index) &&
-						strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]))
+			if (is_rsp_in_list(p_rsp,p_self->info[srv_cnt].rsp_success_codes,p_self,srv_cnt,alias_index) &&
+						strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]))
 
 				return RC_OK;
 		}
 	}
 
-	if (p_self->is_ip_in_svr_rsp) {
+	if (p_self->info[srv_cnt].is_ip_in_svr_rsp) {
 
-		if (strstr(p_rsp,p_self->info.my_ip_address.name[ip_store]))
+		if (strstr(p_rsp,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]))
 
 			return RC_OK;
 	}
@@ -1059,7 +1115,7 @@
 	}
 
 	/*actual failed update?  or no values to check?*/
-	if (!(p_self->rsp_success_codes) && !(p_self->is_ip_in_svr_rsp)) {
+	if (!(p_self->info[srv_cnt].rsp_success_codes) && !(p_self->info[srv_cnt].is_ip_in_svr_rsp)) {
 
 		DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "No update success check values set in generic server response check...\n"));
 
@@ -1080,12 +1136,12 @@
 	  to recognize codes not success and not config,
 	  so merely 'pass through', so with only one
 	  list, all such are try later.*/
-	if (!(p_self->rsp_config_codes)) {
+	if (!(p_self->info[srv_cnt].rsp_config_codes)) {
 
 		DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "No svr_rsp_other set in generic server response check...\n"));
 	}
 	else {
-		if (is_rsp_in_list(p_rsp,p_self->rsp_config_codes,p_self,alias_index)) {
+		if (is_rsp_in_list(p_rsp,p_self->info[srv_cnt].rsp_config_codes,p_self,srv_cnt,alias_index)) {
 
 			DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "Server error.  Pausing a bit before reattempt...\n"));
 
@@ -1096,26 +1152,26 @@
 	return RC_DYNDNS_RSP_CONFIG;
 }
 
-static RC_TYPE update_ip_addr_store(DYN_DNS_CLIENT *p_self,char *p_ip_str)
+static RC_TYPE update_ip_addr_store(DYN_DNS_CLIENT *p_self,int svr_index,char *p_ip_str)
 {
-	DYNDNS_IPV              ip_enum;
-	int                     family;
-	void                    *in_addr;
-	int                     sock_size;
-	unsigned char           ip_str_to_ip[16];
+	DYNDNS_IPV	ip_enum;
+	int		family;
+	void		*in_addr;
+	int		sock_size;
+	unsigned char	ip_str_to_ip[16];
 
 
 	if ((strstr(p_ip_str,".")!=NULL)) {
 
 		ip_enum=ip_4;
 		family=AF_INET;
-		in_addr=&(((struct sockaddr_in*) &p_self->info.net_addr[ip_enum])->sin_addr);
+		in_addr=&(((struct sockaddr_in*) &p_self->info[svr_index].net_addr[ip_enum])->sin_addr);
 		sock_size=sizeof(struct in_addr);
 	}
 	else {
 		ip_enum=ip_6;
 		family=AF_INET6;
-		in_addr=&(((struct sockaddr_in6*) &p_self->info.net_addr[ip_enum])->sin6_addr);
+		in_addr=&(((struct sockaddr_in6*) &p_self->info[svr_index].net_addr[ip_enum])->sin6_addr);
 		sock_size=sizeof(struct in6_addr);
 	}
 
@@ -1124,16 +1180,16 @@
 	/*my_ip_has_changed abandoned for ip_cache_list, but not setting it just feels wrong.
 	  --check out other jokes, and more, in ./src/*.c!
 	*/
-	p_self->info.my_ip_has_changed[ip_enum] = !(0==memcmp(in_addr,ip_str_to_ip,sock_size));
+	p_self->info[svr_index].i_face.my_ip_has_changed[ip_enum] = !(0==memcmp(in_addr,ip_str_to_ip,sock_size));
 
 	memcpy(in_addr,ip_str_to_ip,sock_size);
-	strcpy(p_self->info.my_ip_address.name[ip_enum],p_ip_str);
+	strcpy(p_self->info[svr_index].i_face.my_ip_address.name[ip_enum],p_ip_str);
 
 	/*put currently operated upon here -- for auto ip type too*/
-	strcpy(p_self->info.my_ip_address.name[ip_store],p_ip_str);
-	memcpy(&p_self->info.net_addr[ip_store],&p_self->info.net_addr[ip_enum],sizeof(struct sockaddr_storage));
+	strcpy(p_self->info[svr_index].i_face.my_ip_address.name[ip_store],p_ip_str);
+	memcpy(&p_self->info[svr_index].net_addr[ip_store],&p_self->info[svr_index].net_addr[ip_enum],sizeof(struct sockaddr_storage));
 
-	p_self->info.my_ip_has_changed[ip_store]=p_self->info.my_ip_has_changed[ip_enum];
+	p_self->info[svr_index].i_face.my_ip_has_changed[ip_store]=p_self->info[svr_index].i_face.my_ip_has_changed[ip_enum];
 
 
 	return RC_OK;
@@ -1143,25 +1199,25 @@
     Note:
         it updates the flag: info->'my_ip_has_changed' if the old address was different
 */
-static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
-	RC_TYPE			rc=RC_OK;
-	char			*p_current_str=p_self->http_tr.p_rsp;
-	char			*p_ip_str;
 
+	RC_TYPE		rc=RC_OK;
+	char		*p_current_str=p_self->http_tr.p_rsp;
+	char		*p_ip_str;
 
 	if (p_self->http_tr.rsp_len <= 0 || p_self->http_tr.p_rsp == NULL) {
 
 		return RC_INVALID_POINTER;
 	}
 
-	if (!(RC_OK==(rc=parse_ip_address(&p_ip_str,p_current_str)))) {
+	if (!((rc=parse_ip_address(&p_ip_str,p_current_str))==RC_OK)) {
 
 		return rc;
 	}
 	else {
 
-		update_ip_addr_store(p_self,p_ip_str);
+		update_ip_addr_store(p_self,srv_cnt,p_ip_str);
 
 		free(p_ip_str);
 
@@ -1169,7 +1225,7 @@
 	}
 }
 
-static RC_TYPE check_if_ipv6_addr(DYN_DNS_CLIENT *p_self,struct sockaddr_storage *net_addr)
+static RC_TYPE check_if_ipv6_addr(DYN_DNS_CLIENT *p_self,int svr_index,struct sockaddr_storage *net_addr)
 {
 
 	char	ip_str[40];
@@ -1177,7 +1233,7 @@
 
 	inet_ntop_w(AF_INET6,&(((struct sockaddr_in6*) net_addr)->sin6_addr),ip_str,40);
 
-	return update_ip_addr_store(p_self,ip_str);
+	return update_ip_addr_store(p_self,svr_index,ip_str);
 }
 
 /*
@@ -1188,22 +1244,29 @@
 	iterate over any fallback addresses
 	break on first success
 */
-static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	struct sockaddr_storage	*if_addr;
 	RC_TYPE			rc;
+	HTTP_CLIENT		*p_http;
+	DYNDNS_INFO_TYPE	*info;
+	struct sockaddr_storage	*if_addr;
+
+
+	info=&p_self->info[srv_index];
 
+	p_http = &info->http_to_ip_server;
 
-	rc = http_client_init_all(&p_self->http_to_ip_server);
+
+	rc = http_client_init_all(&info->http_to_ip_server);
 
 	if (rc != RC_OK)
 	{
-		http_client_shutdown(&p_self->http_to_ip_server);
+		http_client_shutdown(&info->http_to_ip_server);
 
 		return rc;
 	}
 
-	if_addr=if_address(p_self->if_name,AF_INET6,&p_self->ipv6_priv_ext);
+	if_addr=if_address(p_self->info[srv_index].if_name,AF_INET6,&p_self->info[srv_index].ipv6_priv_ext);
 
 	/*return good if at least one transaction*/
 
@@ -1212,7 +1275,6 @@
 	do
 	{
 		/*prepare request for IP server*/
-
 		{
 			int			i=0;
 			HTTP_TRANSACTION	*p_tr = &p_self->http_tr;
@@ -1222,9 +1284,8 @@
 			BOOL			is_got_afinet=false;
 
 
-			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,
-			                                      p_self->info.p_dns_system->p_specific_data);
-
+			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,srv_index,
+			                                      info->p_dns_system->p_specific_data);
 			DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "The request for IP server:\n%s\n",p_self->p_req_buffer));
 
 			p_tr->p_req = (char*) p_self->p_req_buffer;
@@ -1232,13 +1293,14 @@
 			p_tr->max_rsp_len = p_self->work_buffer_size - 1;
 			p_tr->rsp_len = 0;
 
+
 			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Entering Loop.  Got %d sockets...\n",
-				p_self->http_to_ip_server.super.super.server_socket_count));
+				info->http_to_ip_server.super.super.server_socket_count));
 
-			for (i=0;i<p_self->http_to_ip_server.super.super.server_socket_count;i++,
-				p_self->http_to_ip_server.super.super.sock_index++) {
+			for (i=0;i<info->http_to_ip_server.super.super.server_socket_count;i++,
+				info->http_to_ip_server.super.super.sock_index++) {
 
-				addr=p_self->http_to_ip_server.super.super.addr_ar[i];
+				addr=info->http_to_ip_server.super.super.addr_ar[i];
 
 				/*on *nix, IPv4 precedence could mean no IPv6 routes which could cause a crash on socket send*/
 				if (((is_got_afinet=(is_got_afinet || addr->ai_family==AF_INET)) && addr->ai_family==AF_INET6))
@@ -1257,75 +1319,74 @@
 
 					continue;
 
-/*we shall support address fetch from ip server of AF_INET, and AF_INET6
-  ip type thereby implicit (auto), or specified (ip4, ip6 or both (which
-  can be aka type dual, or coupled)), and via interface if if_name was
-  opted (and ip6 was specified), and indeed got an ip6 address from it.
-  so control flow is...(note the logic could be simplified, by checking
-  if address before entering loop, but I like the control flow as it
-  is/was and didn't want to disturb it).
-*/
 				/*doing any ip4?  and don't skip ip6 from if*/
 				/*continue if...
-					  is ip4                                   and don't need it*/
-				if ((((addr->ai_family==AF_INET && (!(p_self->info.is_update_ip4 || p_self->info.is_update_auto))
-                                        /*or already got it  AND, don't need ip6*/
+					is ip4						and don't need it*/
+				if ((((addr->ai_family==AF_INET && (!(p_self->info[srv_index].is_update_ip4 || p_self->info[srv_index].is_update_auto))
+					/*or already got it  AND, don't need ip6*/
 					|| is_got_ip4)) && !(if_addr && !is_got_ip6)))
 
 					continue;
 
 				/*doing any ip6?*/
+				if ((addr->ai_family==AF_INET6) && !(p_self->info[srv_index].is_update_ip6 || p_self->info[srv_index].is_update_auto))
+
+					continue;
+
+				/*doing any ip6?*/
 				/*continue if...
-					  is ip6                                  and don't need it                             or have it*/
-				if ((addr->ai_family==AF_INET6 && (!(p_self->info.is_update_ip6 || p_self->info.is_update_auto) || is_got_ip6)))
+					is ip6					and don't need it				or have it*/
+				if ((addr->ai_family==AF_INET6 && (!(p_self->info[srv_index].is_update_ip6 || p_self->info[srv_index].is_update_auto) || is_got_ip6)))
 
 					continue;
 
 				/*use interface address*/
 				/*if...
-				    have it           and not ip4, and don't have          OR don't need                   and do need ip6*/
-				if (if_addr && (!(addr->ai_family==AF_INET && !is_got_ip4) || !p_self->info.is_update_ip4) && !is_got_ip6) {
+				have it		and not ip4, and don't have			OR don't need				and do need ip6*/
+				if (if_addr && (!(addr->ai_family==AF_INET && !is_got_ip4) || !p_self->info[srv_index].is_update_ip4) && !is_got_ip6) {
 
 					DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "Checking bound interface IPv6 address...\n"));
 
-					if (RC_OK==(rc=check_if_ipv6_addr(p_self,if_addr)))
+					if (RC_OK==(rc=check_if_ipv6_addr(p_self,srv_index,if_addr)))
 
 						is_got_ip6=true;
 				}
 				else {
 
-					if (!(0==strcmp(p_self->ipv6_priv_ext.addr_pref,"policy"))) {
+					if (strcmp(p_self->info[srv_index].ipv6_priv_ext.addr_pref,"policy")) {
 
 						/*as per above flags=IPV6_PREFER_SRC_PUBLIC, connect with our "normal" IPV6 address*/
-						setsockopt(p_self->http_to_ip_server.super.super.socket[i],IPPROTO_IPV6,IPV6_ADDR_PREFERENCES,
-							(void *) &p_self->ipv6_priv_ext.flags,sizeof (&p_self->ipv6_priv_ext.flags));
+						setsockopt(info->http_to_ip_server.super.super.socket[i],IPPROTO_IPV6,IPV6_ADDR_PREFERENCES,
+							(void *) &p_self->info[srv_index].ipv6_priv_ext.flags,sizeof(&p_self->info[srv_index].ipv6_priv_ext.flags));
 					}
 
-					if (!(RC_OK==(rc=http_client_connect_socket(&p_self->http_to_ip_server)))) {
+					if (!(RC_OK==(rc=http_client_connect_socket(&info->http_to_ip_server)))) {
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "connect failed getting %s ip from %s%s in check_my_ip_address...\n",
-							addr_family_get_name(addr->ai_family),p_self->info.ip_server_name.name[ip_store],p_self->info.ip_server_url));
+							addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
 
 						continue;
 
 					}
 
-					if (!(RC_OK==(rc=http_client_transaction(&p_self->http_to_ip_server,&p_self->http_tr)))) {
+					memset(p_self->p_work_buffer,0,p_self->work_buffer_size);
+
+					if (!(RC_OK==(rc=http_client_transaction(&info->http_to_ip_server,&p_self->http_tr)))) {
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Failed getting %s ip from %s%s in check_my_ip_address...\n",
-							addr_family_get_name(addr->ai_family),p_self->info.ip_server_name.name[ip_store],p_self->info.ip_server_url));
+							addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
 					}
 					else {
 
 						DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Transaction %d DONE...\n",i));
 
-                		                p_self->http_tr.p_rsp[p_tr->rsp_len]=0;
+						DBG_PRINTF((LOG_INFO,"I:DYNDNS: IP server response: %s\n", p_self->p_work_buffer));
 
-                        		        DBG_PRINTF((LOG_INFO,"I:DYNDNS: IP server response: %s\n", p_self->p_work_buffer));
+						p_self->http_tr.p_rsp[p_tr->rsp_len]=0;
 
 						DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "GONNA PARSE...\n"));
 
-						if (!(RC_OK==(rc=do_check_my_ip_address(p_self)))) {
+						if (!(RC_OK==(rc=do_check_my_ip_address(p_self,srv_index)))) {
 
 							DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "ip parse failed in check_my_ip_address...\n"));
 						}
@@ -1334,16 +1395,17 @@
 
 				if (rc==RC_OK) {
 
-					DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info.my_ip_address.name[ip_store]));
+					DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
-					p_self->info.is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
-					p_self->info.is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
+					p_self->info[srv_index].is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
+					p_self->info[srv_index].is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
 
 					/*detect if just doing auto (based on ip server) and dump out when done*/
-					if ((is_got_ip4 && is_got_ip6) || !(p_self->info.is_update_ip4 && p_self->info.is_update_ip6))
+					if ((is_got_ip4 && is_got_ip6) || !(p_self->info[srv_index].is_update_ip4 && p_self->info[srv_index].is_update_ip6))
 
 						/*support ip4 only updates, on dual ip server*/
-						if ((p_self->info.is_update_ip4 && is_got_ip4) || !(p_self->info.is_update_ip4))
+						if ((p_self->info[srv_index].is_update_ip4 && is_got_ip4) || !(p_self->info[srv_index].is_update_ip4))
+
 							break;
 				}
 			}
@@ -1352,36 +1414,37 @@
 	while(0);
 
 	/*close*/
-	http_client_shutdown(&p_self->http_to_ip_server);
-
-	free(if_addr);
+	http_client_shutdown(&info->http_to_ip_server);
 
 
 	return rc;
 }
 
-static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset)
+static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset,char srv_index)
 {
-	int	i;
-	int	success_updates=0;
-	int	update_ok=false;
-	int	config_fails=0;
-	int	updates_needed=p_self->alias_info.count;
-	BOOL	is_ipv4;
-	RC_TYPE	rc_retry_later=RC_OK;
+	DYNDNS_INFO_TYPE	*info;
+	int			i;
+	int			success_updates=0;
+	int			update_ok=false;
+	int			config_fails=0;
+	int			updates_needed=p_self->info[srv_index].alias_info.count;
+	BOOL			is_ipv4;
+	RC_TYPE			rc_retry_later=RC_OK;
 
 	RC_TYPE rc = RC_OK;
 
 
+	info=&p_self->info[srv_index];
+
 	do
 	{
-		for (i = 0; i < p_self->alias_info.count; ++i) {
+		for (i = 0; i < info->alias_info.count; ++i) {
 
-			if (!(p_self->alias_info.update_required[i])) {
+			if (!(info->alias_info.update_required[i])) {
 
-				if (p_self->alias_info.fatal_error[i]) {
+				if (info->alias_info.fatal_error[i]) {
 
-					do_handle_bad_config(p_self,i);
+					do_handle_bad_config(p_self,i,srv_index);
 
 					config_fails++;
 				}
@@ -1389,81 +1452,82 @@
 				updates_needed--;
 			}
 			else {
-
 				/*dual stack with ip's updated in comma delimited list fashion?*/
-				if (NULL==(strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))) {
+				if (NULL==(strstr(info->alias_info.names[i].ip_v,DUAL_LIST))) {
 
-					if (!(ip_store==p_self->alias_info.names[i].ip_v_enum))
+					if (!(ip_store==info->alias_info.names[i].ip_v_enum))
 
-						strcpy(p_self->info.my_ip_address.name[ip_store],
-								p_self->info.my_ip_address.name[p_self->alias_info.names[i].ip_v_enum]);
+						strcpy(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],
+								p_self->info[srv_index].i_face.my_ip_address.name[info->alias_info.names[i].ip_v_enum]);
 				}
 				else {
-					sprintf(p_self->info.my_ip_address.name[ip_store],"%s,%s",p_self->info.my_ip_address.name[ip_4],p_self->info.my_ip_address.name[ip_6]);
+					sprintf(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],"%s,%s",
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_4],
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_6]);
 
-					if (!(p_self->info.is_got_ip4 && p_self->info.is_got_ip6)) {
+					if (!(p_self->info[srv_index].is_got_ip4 && p_self->info[srv_index].is_got_ip6)) {
 
-						p_self->alias_info.update_succeeded[i]=false;
+						info->alias_info.update_succeeded[i]=false;
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping partially empty address (%s) update of alias "\
-							"%s\n",p_self->info.my_ip_address.name[ip_store],p_self->alias_info.names[i].name));
+							"%s\n",p_self->info[srv_index].i_face.my_ip_address.name[ip_store],info->alias_info.names[i].name));
 
 						continue;
 					}
 				}
 
-				if (!(strlen(p_self->info.my_ip_address.name[ip_store]))) {
+				if (!(strlen(p_self->info[srv_index].i_face.my_ip_address.name[ip_store]))) {
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",info->alias_info.names[i].name));
 
 					continue;
 				}
 
-				is_ipv4=(p_self->alias_info.names[i].ip_v_enum==ip_4);
+				is_ipv4=(info->alias_info.names[i].ip_v_enum==ip_4);
 
 				/*bind to dynamic dns server according to address type to be updated*/
-				http_client_set_is_ipv4(&p_self->http_to_dyndns,is_ipv4);
+				http_client_set_is_ipv4(&info->http_to_dyndns,is_ipv4);
 
-				if (!((rc=http_client_init_and_connect(&p_self->http_to_dyndns))==RC_OK)) {
+				if (!((rc=http_client_init_and_connect(&info->http_to_dyndns))==RC_OK)) {
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),info->alias_info.names[i].name));
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 				}
 				else {
-
 					/*build dyndns transaction*/
 					{
 						HTTP_TRANSACTION http_tr;
 
-						http_tr.req_len = p_self->info.p_dns_system->p_dns_update_req_func(
-                                                        (struct _DYN_DNS_CLIENT*) p_self,i,(struct DYNDNS_SYSTEM*)
-                                                        p_self->info.p_dns_system);
+						http_tr.req_len =
+							info->p_dns_system->p_dns_update_req_func((struct _DYN_DNS_CLIENT*) p_self,srv_index,i,
+							(struct DYNDNS_SYSTEM*) info->p_dns_system);
+
 						http_tr.p_req = (char*) p_self->p_req_buffer;
 						http_tr.p_rsp = (char*) p_self->p_work_buffer;
-						/*save place for a \0 at the end*/
-						http_tr.max_rsp_len = p_self->work_buffer_size - 1;
+						http_tr.max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
 						http_tr.rsp_len = 0;
 						p_self->p_work_buffer[http_tr.rsp_len+1] = 0;
 
 						/*send it*/
-						rc = http_client_transaction(&p_self->http_to_dyndns, &http_tr);
+						rc = http_client_transaction(&info->http_to_dyndns, &http_tr);
 						http_tr.p_rsp[http_tr.rsp_len]=0;
 
+						p_self->p_req_buffer[http_tr.req_len] = 0;
 						DBG_PRINTF((LOG_NOTICE,"N:" MODULE_TAG "DYNDNS my Request:\n%s\n", p_self->p_req_buffer));
 
 						/*error in send?*/
 						if (!(rc == RC_OK))
 
-							p_self->alias_info.update_succeeded[i]=false;
+							info->alias_info.update_succeeded[i]=false;
 
 						else {
 
 							update_ok = (RC_OK==
-								(rc = p_self->info.p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
-								i,http_tr.p_rsp,p_self->info.p_dns_system->p_success_string)));
+								(rc=info->p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,i,
+									    http_tr.p_rsp,info->p_dns_system->p_success_string,srv_index)));
 
 							if (update_ok)
 							{
@@ -1477,12 +1541,12 @@
 									*is_forced_update_reset=true;
 								}
 #endif
-								p_self->alias_info.update_required[i]=false;
-								p_self->alias_info.update_succeeded[i]=true;
+								info->alias_info.update_required[i]=false;
+								info->alias_info.update_succeeded[i]=true;
 
 								DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Alias '%s' to IP '%s' updated successfully.\n",
-											p_self->alias_info.names[i].name,
-											p_self->info.my_ip_address.name[ip_store]));
+											info->alias_info.names[i].name,
+											p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
 								if (p_self->external_command)
 
@@ -1490,7 +1554,7 @@
 							}
 							else {
 
-								p_self->alias_info.update_succeeded[i]=false;
+								info->alias_info.update_succeeded[i]=false;
 
 								/*dyndns2 protocol, retry later?*/
 								if (rc==RC_DYNDNS_SERVER_ERROR) {
@@ -1500,10 +1564,9 @@
 								else {
 									if (!(rc==RC_DYNDNS_RSP_CONFIG)) {
 
-										DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Error updating alias %s\n",p_self->alias_info.names[i].name));
+										DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",info->alias_info.names[i].name));
 									}
 									else {
-
 										if (strstr(http_tr.p_rsp,"badagent"))
 
 											DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Server responded with 'badagent'.  Attempting to update IPv6 to IPv4 only server?  Try ip4 parameter, e.g., --alias youralias ip4.\n"));
@@ -1511,14 +1574,16 @@
 
 											DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Error validating DYNDNS svr answer. Check usr,pass,hostname!\n"));
 
-										p_self->alias_info.fatal_error[i]=TRUE;
+										DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error validating DYNDNS svr answer. Check usr,pass,hostname!\n"));
+
+										info->alias_info.fatal_error[i]=TRUE;
 
 										DBG_PRINTF((LOG_CRIT,"C:" MODULE_TAG "\n"\
 												ERROR_FLAG \
 												"Fatal dyndns server update error for "\
 												"alias, %s.\nThis client should be stopped and corrected for "\
 												"configuration errors, and restarted...\n" \
-												ERROR_FLAG,p_self->alias_info.names[i].name));
+												ERROR_FLAG,info->alias_info.names[i].name));
 
 										config_fails++;
 										updates_needed--;
@@ -1526,13 +1591,14 @@
 								}
 							}
 
+							http_tr.p_rsp[http_tr.rsp_len] = 0;
 							DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "DYNDNS Server response:\n%s\n", http_tr.p_rsp));
 						}
 					}
 				}
 
 				{
-					RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns);
+					RC_TYPE rc2 = http_client_shutdown(&info->http_to_dyndns);
 
 					if (!(rc2==RC_OK))
 
@@ -1540,130 +1606,135 @@
 
 				}
 
-				if (i<p_self->alias_info.count-1)
+				if (i<info->alias_info.count-1)
 
 					os_sleep_ms(1000);
 			}
 
-			if (rc_retry_later==RC_DYNDNS_SERVER_ERROR)
-
-				break;
-
 			/*reset for loop*/
 			rc=RC_OK;
 		}
 	}
 	while(0);
 
-	rc=ip_cache_list_update_state(p_self,updates_needed,success_updates,config_fails,&rc);
+	rc=ip_cache_list_update_state(p_self,updates_needed,success_updates,config_fails,rc,srv_index,&is_global_success_updates,&is_global_in_proc_update_pending);
 
 	if (!(rc_retry_later==RC_DYNDNS_SERVER_ERROR))
 
 		return rc;
 	else
 		return RC_DYNDNS_SERVER_ERROR;
+
 }
 
-static int get_is_cache_current(DYN_DNS_CLIENT *p_self,int alias_index,DYNDNS_IPV ip_v,char *ip_v_str)
+static int get_is_cache_current(DYN_DNS_CLIENT *p_self,int svr_index,int alias_index,DYNDNS_IPV ip_v,char *ip_v_str)
 {
-
 	char	*ip_alias_type;
 	int	is_cache_current=0;
 	void	*in_addr;
 	int	address_size;
 
 
-	ip_alias_type=safe_malloc(strlen(p_self->info.my_ip_address.name[ip_v])+strlen(p_self->alias_info.names[alias_index].name)+strlen(p_self->alias_info.names[alias_index].ip_v)+strlen(ip_v_str)+3);
-	sprintf(ip_alias_type,"%s %s:%s",p_self->info.my_ip_address.name[ip_v],p_self->alias_info.names[alias_index].name,ip_v_str);
+	ip_alias_type=safe_malloc(strlen(p_self->info[svr_index].i_face.my_ip_address.name[ip_v])+strlen(p_self->info[svr_index].alias_info.names[alias_index].name)+strlen(p_self->info[svr_index].alias_info.names[alias_index].ip_v)+strlen(ip_v_str)+3);
+	sprintf(ip_alias_type,"%s %s:%s",p_self->info[svr_index].i_face.my_ip_address.name[ip_v],p_self->info[svr_index].alias_info.names[alias_index].name,ip_v_str);
 
-	if (!(strpbrk(p_self->info.my_ip_address.name[ip_v],":"))) {
+	if (!(strpbrk(p_self->info[svr_index].i_face.my_ip_address.name[ip_v],":"))) {
 
 		address_size=sizeof(struct in_addr);
 
-		in_addr=&(((struct sockaddr_in*) &p_self->info.net_addr[ip_v])->sin_addr);
+		in_addr=&(((struct sockaddr_in*) &p_self->info[svr_index].net_addr[ip_v])->sin_addr);
 	}
 	else {
 		address_size=sizeof(struct in6_addr);
 
-		in_addr=&(((struct sockaddr_in6*) &p_self->info.net_addr[ip_v])->sin6_addr);
+		in_addr=&(((struct sockaddr_in6*) &p_self->info[svr_index].net_addr[ip_v])->sin6_addr);
 	}
 
-	is_cache_current=!(-1==ip_cache_list_index_of(&p_self->ip_cache_list,in_addr,p_self->info.my_ip_address.name[ip_v],
-					p_self->alias_info.names[alias_index].name,p_self->info.dyndns_server_host,
-					ip_alias_type));
-
+	is_cache_current=!(-1==ip_cache_list_index_of(&p_self->ip_cache_list,in_addr,p_self->info[svr_index].i_face.my_ip_address.name[ip_v],
+		p_self->info[svr_index].alias_info.names[alias_index].name,p_self->info[svr_index].dyndns_server_host,
+		ip_alias_type));
 
 	free(ip_alias_type);
 
 	return is_cache_current;
 }
 
-static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self)
+/*
+    Updates for every maintained name the property: 'update_required'.
+    The property will be checked in another function and updates performed.
+
+      Action:
+        Check if my IP address has changed. -> ALL names have to be updated.
+        Note: In the update function the property will set to false if update was successful.
+*/
+static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	int		i;
-	DYNDNS_IPV	ip_v;
-	BOOL		is_dyndns_dual;
-	BOOL		is_cache_current;
+	int			i;
+	DYNDNS_IPV		ip_v;
+	BOOL			is_dyndns_dual;
+	BOOL			is_cache_current;
+	DYNDNS_INFO_TYPE	*info;
 
+	info=&p_self->info[srv_index];
 
-	for (i = 0; i < p_self->alias_info.count; ++i)
+	for (i = 0; i < info->alias_info.count; ++i)
 	{
-
-		ip_v=p_self->alias_info.names[i].ip_v_enum;
+		ip_v=info->alias_info.names[i].ip_v_enum;
 
 		/*ip type DUAL_LIST is dual of form, 1.1.1.1,::1 -- both ip types in one update connection*/
-		if (!(is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST)))) {
+		if (!(is_dyndns_dual=(NULL!=strstr(info->alias_info.names[i].ip_v,DUAL_LIST)))) {
 
-			is_cache_current=get_is_cache_current(p_self,i,ip_v,p_self->alias_info.names[i].ip_v);
+			is_cache_current=get_is_cache_current(p_self,srv_index,i,ip_v,info->alias_info.names[i].ip_v);
 		}
 		else {
 
-			is_cache_current=get_is_cache_current(p_self,i,ip_4,"ip4");
+			is_cache_current=get_is_cache_current(p_self,srv_index,i,ip_4,"ip4");
 
 			if (is_cache_current)
 
-				is_cache_current=get_is_cache_current(p_self,i,ip_6,"ip6");
+				is_cache_current=get_is_cache_current(p_self,srv_index,i,ip_6,"ip6");
 		}
 
-		p_self->alias_info.update_required[i] =
+		info->alias_info.update_required[i] =
 
 			/*ip address changed, or failed update?*/
 			(!is_cache_current
 
 			/*pending failed update?*/
-			|| (is_update_pending && !(p_self->alias_info.update_succeeded[i]))
+			|| (is_global_update_pending && !(info->alias_info.update_succeeded[i]))
 
 			/*administrative update?*/
 			|| (!(p_self->forced_update_counter)));
 
-		if (p_self->alias_info.update_required[i]) {
+		if (info->alias_info.update_required[i]) {
 
 			if (is_dyndns_dual)
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s,%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v,
-						p_self->info.my_ip_address.name[ip_4],p_self->info.my_ip_address.name[ip_6]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v,
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_4],
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_6]));
 
 
 			else
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v,
-						p_self->info.my_ip_address.name[ip_v]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v,
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_v]));
 
-			p_self->alias_info.update_required[i]=!(p_self->alias_info.fatal_error[i]);
+			info->alias_info.update_required[i]=!(info->alias_info.fatal_error[i]);
 		}
 	}
 
 	return RC_OK;
 }
 
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i)
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt)
 {
 
 	/*might want to sound an error specific alert too*/
 
-	if (i<p_self->alias_info.count)
+	if (i<p_self->info[srv_cnt].alias_info.count)
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
 					ERROR_FLAG \
@@ -1671,7 +1742,7 @@
 					"fatal dyndns server update error for "\
 					"alias, %s.\nThis client should be stopped and corrected for "\
 					"configuration errors, and restarted...\n" \
-					ERROR_FLAG,p_self->alias_info.names[i].name));
+					ERROR_FLAG,p_self->info[srv_cnt].alias_info.names[i].name));
 	else
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
@@ -1685,34 +1756,34 @@
 	return RC_ERROR;
 }
 
-static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	/*ip update subsequent dns server return bad config related error*/
 
 	int	i;
 
-	for (i=0;i<p_self->alias_info.count;i++) {
+	for (i=0;i<p_self->info[srv_cnt].alias_info.count;i++) {
 
-		if (p_self->alias_info.fatal_error[i])
+		if (p_self->info[srv_cnt].alias_info.fatal_error[i])
 
 			break;
 	}
 
-	return do_handle_bad_config(p_self,i);
+	return do_handle_bad_config(p_self,i,srv_cnt);
 }
 
 /*
 	- increment the forced update times counter
 	- detect current IP
-		- connect to an HTTP server
+		- connect to an HTTP server 
 		- parse the response for IP addr
 
 	- for all the names that have to be maintained
 		- get the current DYN DNS address from DYN DNS server
 		- compare and update if neccessary
 */
-static RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE	rc=RC_ERROR;
@@ -1727,9 +1798,9 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->is_bad_config)
+	if (p_self->is_global_bad_config)
 
-		return dyn_dns_handle_bad_config(p_self);
+		return dyn_dns_handle_bad_config(p_self,srv_cnt);
 
 	do
 	{
@@ -1742,7 +1813,7 @@
 
 				if ((is_exit=(p_self->net_retries<net_attempts++))) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;
 
 					break;
 				}
@@ -1752,7 +1823,7 @@
 			else {
 
 				/*ask IP server something so will respond and give me my IP */
-				rc = check_my_ip_address(p_self);
+				rc = check_my_ip_address(p_self,srv_cnt);
 
 				if (rc==RC_OK)
 
@@ -1762,7 +1833,7 @@
 
 				if (p_self->net_retries<ip_attempts++) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;
 
 					break;
 				}
@@ -1789,7 +1860,7 @@
 			DBG_PRINTF((LOG_INFO,"I:DYNDNS: dyn_dns_update_ip checking alias table...\n"));
 
 			/*step through aliases list, resolve them and check if they point to my IP*/
-			rc = do_check_alias_update_table(p_self);
+			rc = do_check_alias_update_table(p_self,srv_cnt);
 			if (rc != RC_OK)
 			{
 				break;
@@ -1805,7 +1876,7 @@
 
 					if (p_self->net_retries<net_attempts++) {
 
-						is_update_pending=true;
+						p_self->info[srv_cnt].is_update_pending=true;
 
 						break;
 					}
@@ -1814,21 +1885,29 @@
 				}
 				else {
 
+					DBG_PRINTF((LOG_INFO,"D:" MODULE_TAG "dyn_dns_update_ip calling do_update_alias_table...\n"));
+
 					/*update IPs marked as not identical with my IP*/
-					rc = do_update_alias_table(p_self,&is_forced_update_reset);
+					rc = do_update_alias_table(p_self,&is_forced_update_reset,srv_cnt);
 
 					if (rc==RC_OK) {
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
+
+						DBG_PRINTF((LOG_INFO,"D:" MODULE_TAG "aliases update in dyn_dns_update_ip...\n"));
 
 						break;
 					}
 
-					DBG_PRINTF((LOG_ERR,"E:DYNDNS: Failed updating alias table...\n"));
+					DBG_PRINTF((LOG_WARNING,"W:DYNDNS: Failed updating alias table...\n"));
 
-					/*ALL aliases config failed*/
-					if (!(is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG))) || (rc==RC_DYNDNS_SERVER_ERROR))
+					p_self->info[srv_cnt].is_bad_config=(rc==RC_DYNDNS_RSP_CONFIG);
 
+					/*ALL aliases config failed*/
+					if (!(p_self->info[srv_cnt].is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG))) ||
+												(rc==RC_DYNDNS_SERVER_ERROR))
 						break;
 					else
 						if (p_self->net_retries<ip_attempts++)
@@ -1853,18 +1932,18 @@
 	*src+=inc;
 }
 
-static RC_TYPE dyn_dns_reinit(DYN_DNS_CLIENT *p_dyndns)
+int number_of_aliases(DYN_DNS_CLIENT *p_dyndns)
 {
+	char	i;
+	int	alias_count=0;
 
-	RC_TYPE	rc=RC_OK;
-
-
-	dyn_dns_shutdown(p_dyndns);
 
-	rc=do_dyn_dns_init(p_dyndns);
+	for (i=0;i<MAX_DNS_SERVER;i++) {
 
+		alias_count+=p_dyndns->info[i].alias_info.count;
+	}
 
-	return rc;
+	return alias_count;
 }
 
 static int increment_iterations(DYN_DNS_CLIENT *p_dyndns)
@@ -1880,7 +1959,7 @@
 	return iterations;
 }
 
-static BOOL is_completed_iterations(DYN_DNS_CLIENT *p_dyndns,int *iteration)
+BOOL is_completed_iterations(DYN_DNS_CLIENT *p_dyndns,int *iteration)
 {
 
 
@@ -1907,6 +1986,9 @@
 	RC_TYPE	rc=RC_OK;
 	BOOL	init_flag=FALSE;
 	int	current_iteration=0;
+	char	bad_config_count;
+	char	i;
+	int	success_count;
 
 #ifdef _WIN32
 
@@ -1919,39 +2001,62 @@
 
 	rc=init_update_loop(p_dyndns,argc,argv,&p_ras_thread_data,&init_flag);
 
+        events_register_client(dyndns_event,p_dyndns,NULL);
+        events_start_loop_thread();
+
 	if (p_dyndns->abort)
 
 		return rc;
 
-        events_register_client(dyndns_event,p_dyndns,NULL);
-        events_start_loop_thread();
-
 	if (rc==RC_OK) /*init all okay?*/
 
 		do
 		{
-			/*update IP address in a loop*/
+			/*state across multiple server updates*/
+			bad_config_count=0;
+			is_global_success_updates=false; /*flagged in update_update_state*/
+			is_global_in_proc_update_pending=false;
+			success_count=0;
 
-			if (((rc=dyn_dns_update_ip(p_dyndns))==RC_OK))
+			for (i=0;i<p_dyndns->srv_cnt;i++) {
 
-				increment_iterations(p_dyndns);
+				if (p_dyndns->cmd==CMD_STOP)
 
-			else {
+					break;
 
-				DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
-					        errorcode_get_name(rc), rc, current_iteration));
+				if (((rc=dyn_dns_update_ip(p_dyndns,i))==RC_OK))
 
-				if (p_dyndns->is_bad_config=(rc==RC_DYNDNS_RSP_CONFIG))
+					success_count++;
 
-					p_dyndns->cmd=CMD_STOP;
 				else {
-					/*dyndns2 retry later*/
-					p_dyndns->retry_later=(rc==RC_DYNDNS_SERVER_ERROR);
 
-					rc=dyn_dns_reinit(p_dyndns);
+					DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
+								errorcode_get_name(rc), rc, current_iteration));
+
+					if (p_dyndns->info[i].is_bad_config)
+
+						bad_config_count++;
+					else
+						/*dyndns2 retry later*/
+						p_dyndns->retry_later=(rc==RC_DYNDNS_SERVER_ERROR);
 				}
+
+				is_global_in_proc_update_pending=(is_global_in_proc_update_pending || p_dyndns->info[i].is_update_pending);
+			}
+
+			is_global_update_pending=is_global_in_proc_update_pending;
+
+			/*bad config all aliases for all servers?*/
+			if (p_dyndns->is_global_bad_config=(bad_config_count==p_dyndns->srv_cnt)) {
+
+				p_dyndns->cmd=CMD_STOP;
+
+				DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "All server update configurations are bad.  Stopping client...\n"));
 			}
 
+			if (success_count==p_dyndns->srv_cnt)
+
+				increment_iterations(p_dyndns);
 #ifdef USE_SNDFILE
 
 #ifndef USE_THREADS
@@ -1960,6 +2065,7 @@
 #endif
 
 #endif
+
 			if (p_dyndns->cmd==CMD_STOP) {
 
 				DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "STOP command received. Exiting.\n"));
@@ -1973,14 +2079,6 @@
 
 				break;
 			}
-			else {
-				if (!(rc==RC_OK)) {
-
-					init_flag=false;
-
-					break;
-				}
-			}
 
 			/* sleep the time set in the ->sleep_sec data memeber*/
 			dyn_dns_wait_for_cmd(p_dyndns);
@@ -1989,11 +2087,12 @@
 			inc_update_times(p_dyndns,&(p_dyndns->times_since_last_update),1);
 
 			/*reset the command*/
-			if (!(p_dyndns->cmd==CMD_STOP)) {
+			if (!(p_dyndns->cmd==CMD_STOP))	{
 
 				p_dyndns->cmd=NO_CMD;
 			}
 			else {
+
 				DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "STOP command received. Exiting.\n"));
 
 				break;
@@ -2039,24 +2138,24 @@
 /*************
  Connection testing, connection status alert, DYN_DNS_CLIENT default config, construct, destruct.
 */
-static RC_TYPE dyn_dns_set_ip_proxy_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_set_ip_proxy_dest(HTTP_CLIENT *dest,DYNDNS_INFO_TYPE *info)
 {
 	RC_TYPE	rc;
 
-	if (RC_OK==(rc=http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store])))
+	if (RC_OK==(rc=http_client_set_remote_name(dest,info->proxy_server_name.name)))
 
-		rc=http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		rc=http_client_set_port(dest,info->proxy_server_name.port);
 
 	return rc;
 }
 
-static RC_TYPE dyn_dns_set_comm_src_params(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_set_comm_src_params(HTTP_CLIENT *dest,DYNDNS_INFO_TYPE *info)
 {
 	RC_TYPE	rc;
 
-	if (RC_OK==(rc=http_client_set_addr_pref(dest,p_self->ipv6_priv_ext)))
+	if (RC_OK==(rc=http_client_set_addr_pref(dest,info->ipv6_priv_ext)))
 
-		rc=http_client_set_if_name(dest,p_self->if_name);
+		rc=http_client_set_if_name(dest,info->if_name);
 
 	return rc;
 }
@@ -2064,56 +2163,56 @@
 static RC_TYPE dyn_dns_set_online_check_params(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[0].proxy_server_name.name)
 	{
-		dyn_dns_set_ip_proxy_dest(dest,p_self);
+		dyn_dns_set_ip_proxy_dest(dest,&p_self->info[0]);
 	}
 	else {
 
-		http_client_set_remote_name(dest,p_self->info_online_status.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info_online_status.ip_server_name.port);
+
+		http_client_set_remote_name(dest,p_self->info_online_status.name);
+		http_client_set_port(dest,p_self->info_online_status.port);
 	}
 
 
 	return RC_OK;
 }
 
-static RC_TYPE dyn_dns_set_ip_server_params(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_set_ip_server_params(HTTP_CLIENT *dest,DYNDNS_INFO_TYPE *info)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (info->proxy_server_name.name)
 	{
-
-		dyn_dns_set_ip_proxy_dest(dest,p_self);
+		dyn_dns_set_ip_proxy_dest(dest,info);
 	}
 	else {
 
-		http_client_set_remote_name(dest,p_self->info.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.ip_server_name.port);
+		http_client_set_remote_name(dest,info->ip_server_name.name);
+
+		http_client_set_port(dest,info->ip_server_name.port);
 	}
 
-	dyn_dns_set_comm_src_params(dest,p_self);
+	dyn_dns_set_comm_src_params(dest,info);
 
 
 	return RC_OK;
 }
-
-static RC_TYPE dyn_dns_set_dyndns_server_params(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_set_dyndns_server_params(HTTP_CLIENT *dest,DYNDNS_INFO_TYPE *info)
 {
 
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (info->proxy_server_name.name)
 	{
 
-		dyn_dns_set_ip_proxy_dest(dest,p_self);
+		dyn_dns_set_ip_proxy_dest(dest,info);
 	}
 	else {
 
-		http_client_set_remote_name(dest,p_self->info.dyndns_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.dyndns_server_name.port);
+		http_client_set_remote_name(dest,info->dyndns_server_name.name);
+		http_client_set_port(dest,info->dyndns_server_name.port);
 	}
 
-	dyn_dns_set_comm_src_params(dest,p_self);
+	dyn_dns_set_comm_src_params(dest,info);
 
 
 	return RC_OK;
@@ -2121,9 +2220,14 @@
 
 static RC_TYPE dyn_dns_set_http_clients(DYN_DNS_CLIENT *p_self)
 {
+	char	i;
 
-	dyn_dns_set_ip_server_params(&p_self->http_to_ip_server,p_self);
-	dyn_dns_set_dyndns_server_params(&p_self->http_to_dyndns,p_self);
+
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		dyn_dns_set_ip_server_params(&p_self->info[i].http_to_ip_server,&p_self->info[i]);
+		dyn_dns_set_dyndns_server_params(&p_self->info[i].http_to_dyndns,&p_self->info[i]);
+	}
 
 	return RC_OK;
 }
@@ -2147,11 +2251,11 @@
 	rc=http_client_test_connect(http_to_ip_server,is_exit_requested_void,p_self);
 #endif
 
+	http_client_shutdown(http_to_ip_server);
 	http_client_destruct(http_to_ip_server);
 
 	free(http_to_ip_server);
 
-
 	return rc;
 }
 
@@ -2329,7 +2433,6 @@
 
 				sleep_lightly_ms(p_dyndns->alert_interval,&alert_abort_cond,&alert_cond_param);
 
-
 			} while (1);
 
 			free(wave_params);
@@ -2359,11 +2462,9 @@
 
 #else
 
-	if (thread_alert) {
+	if (thread_alert)
 
 		WaitForSingleObject((HANDLE) thread_alert,INFINITE);
-		CloseHandle((HANDLE) thread_alert);
-	}
 #endif
 
 	thread_alert=0;
@@ -2386,11 +2487,9 @@
 		pthread_join(thread_online_test,NULL);
 #else
 
-	if (thread_online_test) {
+	if (thread_online_test)
 
 		WaitForSingleObject((HANDLE) thread_online_test,INFINITE);
-		CloseHandle((HANDLE) thread_online_test);
-	}
 #endif
 
 	thread_online_test=0;
@@ -2417,7 +2516,7 @@
 static void alert_if_offline_thread(void *p_data)
 #endif
 {
-	DYN_DNS_CLIENT		*p_dyndns;
+	DYN_DNS_CLIENT	*p_dyndns;
 
 	if (p_data) {
 
@@ -2433,7 +2532,9 @@
 		}
 	}
 
-#ifndef _WIN32
+#ifdef _WIN32
+	_endthread();
+#else
 	pthread_exit(p_data);
 
 	/*compiler complaints (pthread_exit does not return)*/
@@ -2558,7 +2659,7 @@
 					/*sleep less, check status more, if offline*/
 					sleep_lightly_ms(p_self->status_offline_interval,&thread_exit_cond,p_self);
 				}
-			}
+			}	
 
 			exit_alert_thread();
 
@@ -2568,7 +2669,9 @@
 		}
 	}
 
-#ifndef _WIN32
+#ifdef _WIN32
+	_endthread();
+#else
 	pthread_exit(p_data);
 
 	/*compiler complaints (pthread_exit does not return)*/
@@ -2602,11 +2705,11 @@
 
 #endif /*USE_THREADS*/
 
-/******************Windows RAS thread, and Windows Service related******************/
+/******************Windows RAS thread******************/
 
 #ifdef _WIN32
 
-static start_ras_thread(DYN_DNS_CLIENT *p_dyndns,RAS_THREAD_DATA **p_ras_thread_data)
+static void start_ras_thread(DYN_DNS_CLIENT *p_dyndns,RAS_THREAD_DATA **p_ras_thread_data)
 {
 
 	if (p_dyndns->dbg.level>=LOG_INFO)
@@ -2615,7 +2718,7 @@
 
 
 	*p_ras_thread_data=construct_and_launch_trap_ras_events(dyn_dns_update_ip_handler,p_dyndns,p_dyndns->\
-		                   http_to_ip_server.super.super.p_remote_host_name,\
+		                   info[0].http_to_ip_server.super.super.p_remote_host_name,\
 		                   p_dyndns->dbg.level);
 
 	if (*p_ras_thread_data) {
@@ -2644,8 +2747,9 @@
 
 	do
 	{
-		p_self->info.p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
-		if (p_self->info.p_dns_system == NULL)
+
+		p_self->info[0].p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
+		if (p_self->info[0].p_dns_system == NULL)
 		{
 			rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
 			break;
@@ -2672,34 +2776,12 @@
 		p_self->time_cache=safe_malloc(prefix_len+time_len);
 		sprintf(p_self->time_cache, "%s%s", DYNDNS_DEFAULT_CACHE_PREFIX, DYNDNS_DEFAULT_TIME_FILE);
 #endif
-
 #ifdef _WIN32
-		/*running as a windows service, default cache dir to module path, else working dir*/
-		if (!(is_win_service())) {
-
-			char	*cwd=dir_delimited(short_name(cross_platform_cwd(&cwd)));
-			int	cwd_len=strlen(cwd);
-
-			p_self->ip_cache=safe_malloc(cwd_len+ip_len);
-			sprintf(p_self->ip_cache, "%s%s", cwd,DYNDNS_DEFAULT_IP_FILE);
-
-			p_self->time_cache=safe_malloc(cwd_len+time_len);
-			sprintf(p_self->time_cache, "%s%s",cwd,DYNDNS_DEFAULT_TIME_FILE);
-
-			free(cwd);
-		}
-		else {
-			char	*cache_dir=dir_delimited(short_name(modulePath(NULL,&cache_dir)));
-			int	cache_len=strlen(cache_dir);
-
-			p_self->ip_cache=safe_malloc(cache_len+ip_len);
-			p_self->time_cache=safe_malloc(cache_len+time_len);
-
-			sprintf(p_self->ip_cache, "%s%s",cache_dir,DYNDNS_DEFAULT_IP_FILE);
-			sprintf(p_self->time_cache, "%s%s",cache_dir,DYNDNS_DEFAULT_TIME_FILE);
+		p_self->ip_cache=safe_malloc(ip_len);
+		p_self->time_cache=safe_malloc(time_len);
 
-			free(cache_dir);
-		}
+		sprintf(p_self->ip_cache, "%s", DYNDNS_DEFAULT_IP_FILE);
+		sprintf(p_self->time_cache, "%s", DYNDNS_DEFAULT_TIME_FILE);
 #endif
 		/*update period*/
 		p_self->sleep_sec = DYNDNS_DEFAULT_SLEEP;
@@ -2715,13 +2797,8 @@
 
 		set_wave_gain(p_self,DYNDNS_DEFAULT_USER_WAVE_GAIN);
 
-		{
-			char	root[6];
-			char	path[]="extra" DIR_DELIM_STR "wav";
-			char	wave_file[]=DYNDNS_DEFAULT_WAVE_FILE;
+		searchedProgFile(NULL,&(p_self->wave_file),"inadyn-mt","extra" DIR_DELIM_STR "wav",4,DYNDNS_DEFAULT_WAVE_FILE);
 
-			p_self->wave_file=searchedProgFile(NULL,&p_self->wave_file,get_root(root),path,4,wave_file);
-		}
 
 		if (!(p_self->wave_file)) {
 
@@ -2733,12 +2810,11 @@
 		}
 
 		/*
-			default:  tell wave routines
+			default:  tell wave routines 
 			use quarter bytes/sec buffer
 		*/
 		p_self->wave_buff_factor=DYNDNS_DEFAULT_WAVE_BUFF_FACTOR;
 #endif
-
 		p_self->dbg.level=DYNDNS_DEFAULT_DEBUG_LEVEL;
 	}
 	while(0);
@@ -2746,7 +2822,7 @@
 	return rc;
 }
 
-static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self)
+static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 	RC_TYPE		rc=RC_OK;
 	char		*str_uri_encoded;
@@ -2758,17 +2834,17 @@
 
 	size=strlen(format)+1;
 
-	if (!(p_self->info.credentials.my_password))
+	if (!(p_self->info[srv_cnt].credentials.my_password))
 
-		p_self->info.credentials.my_password=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_password=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_password);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_password);
 
-	if (!(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_username))
 
-		p_self->info.credentials.my_username=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_username=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_username);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_username);
 
 	do
 	{
@@ -2780,8 +2856,8 @@
 		}
 
 		actual_len = sprintf(p_tmp_buff, format,
-		                     p_self->info.credentials.my_username,
-		                     p_self->info.credentials.my_password);
+		                     p_self->info[srv_cnt].credentials.my_username,
+		                     p_self->info[srv_cnt].credentials.my_password);
 
 		if (actual_len >= size)
 		{
@@ -2791,15 +2867,15 @@
 
 		/*encode*/
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer =
+		p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer =
 		    b64encode(utf_8_uri_encoded(&str_uri_encoded,p_tmp_buff,"&#",";"));
 
 		free(str_uri_encoded);
 
-		p_self->info.credentials.encoded =
-		    (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL);
+		p_self->info[srv_cnt].credentials.encoded =
+		    (p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer != NULL);
 
-		p_self->info.credentials.size = strlen(p_self->info.credentials.p_enc_usr_passwd_buffer);
+		p_self->info[srv_cnt].credentials.size = strlen(p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 	}
 	while(0);
 
@@ -2818,7 +2894,7 @@
 	DBG_PRINTF((LOG_SYSTEM, "S:" MODULE_TAG "Started 'inadyn-mt version %s' - dynamic DNS updater.\n", DYNDNS_VERSION_STRING));
 }
 
-static void destroy_list(gen_list* params_list)
+static void destroy_custom_params_list(gen_list* params_list)
 {
 	gen_list_itr	itr=list_itr_create(*params_list,&itr);
 
@@ -2833,28 +2909,69 @@
 	list_itr_destroy(&itr);
 }
 
+static void destroy_custom_params(DYN_DNS_CLIENT *p_self)
+{
+
+	int		i;
+	DYNDNS_SYSTEM	*p_static_user_defined=get_dns_system_by_id(CUSTOM_HTTP_BASIC_AUTH);
+
+
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		free(p_self->info[i].ip_param);
+		p_self->info[i].ip_param=NULL;
+		free(p_self->info[i].id_param);
+		p_self->info[i].id_param=NULL;
+		free(p_self->info[i].pw_param);
+		p_self->info[i].pw_param=NULL;
+
+		free(p_self->info[i].if_name);
+		p_self->info[i].if_name=NULL;
+
+		if (p_self->info[i].rsp_config_codes)
+
+			destroy_custom_params_list(&p_self->info[i].rsp_config_codes);
+
+		if (p_self->info[i].rsp_success_codes)
+
+			destroy_custom_params_list(&p_self->info[i].rsp_success_codes);
+
+		if (0==strcmp(USER_DEFINED_SERVER,p_self->info[i].p_dns_system->p_key)) {
+
+			if (!(p_self->info[i].p_dns_system==p_static_user_defined)) {
+
+				free(p_self->info[i].p_dns_system->p_key);
+				p_self->info[i].p_dns_system->p_key=NULL;
+
+				free(p_self->info[i].p_dns_system);
+				p_self->info[i].p_dns_system=NULL;
+			}
+		}
+	}
+}
+
 /*
-        Disconnect and some other clean up.
+	Disconnect and some other clean up.
 */
 static RC_TYPE dyn_dns_shutdown(DYN_DNS_CLIENT *p_self)
 {
-        if (p_self == NULL)
-        {
-                return RC_INVALID_POINTER;
-        }
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
 
-        if (p_self->initialized == FALSE)
-        {
-                return RC_OK;
-        }
+	if (p_self->initialized == FALSE)
+	{
+		return RC_OK;
+	}
 
-        return RC_OK;
+	return RC_OK;
 }
 
 /*
 	Sets up the object.
 	- sets the IPs of the DYN DNS server
-	- if proxy server is set use it!
+    - if proxy server is set use it!
 	- ...
 */
 static RC_TYPE do_dyn_dns_init(DYN_DNS_CLIENT *p_self)
@@ -2906,26 +3023,27 @@
 
 #ifdef USE_THREADS
 
-	void	**p_ras_thread_data=p_data;
+	void			**p_ras_thread_data=p_data;
 #endif
 
 #else
 	RAS_THREAD_DATA	**p_ras_thread_data= (RAS_THREAD_DATA **) p_data;
-	int		regParamsC=1;
-	wchar_t		*regArgs[50];
-	char		*utf_8_argv[50];
-	int		i=0;
+	int             regParamsC=1;
+	wchar_t         *regArgs[50];
+	char            *utf_8_argv[50];
+	int             i=0;
 
-	RC_TYPE		rc_reg=RC_ERROR;
+	RC_TYPE         rc_reg=RC_ERROR;
 #endif
 
-	threads_wrapper_init();
-
 #ifdef USE_THREADS
 
+	threads_wrapper_init();
+
 	memset(&update_timer,0,sizeof(my_timer_t));
 #endif
 
+
 	if (p_dyndns == NULL)
 
 		return RC_INVALID_POINTER;
@@ -2937,7 +3055,6 @@
 		return rc;
 	}
 
-
 #ifdef _WIN32
 
 	SetLastError(0);
@@ -2971,7 +3088,6 @@
 	/* read cmd line options and set object properties*/
 	rc_cmd_line = get_config_data(p_dyndns, argc, argv);
 
-
 #ifndef _WIN32
 
 	if (rc_cmd_line != RC_OK || p_dyndns->abort)
@@ -2984,7 +3100,6 @@
 
 		return rc_cmd_line;
 
-
 	if (p_dyndns->lang_hard_coded) {
 
 		/*use hard coded defaults -- don't use default locale file*/
@@ -3005,15 +3120,10 @@
 	}
 
 	/*if logfile provided, redirect output to log file*/
-	if (!(p_dyndns->dbg.p_logfilename)) {
-
-		/*set log level to default*/
-		set_debug_level(p_dyndns->dbg.level);
-	}
-	else {
+	if (p_dyndns->dbg.p_logfilename)
+	{
 
-		DBG_PRINTF((LOG_INFO, "I:" MODULE_TAG "Attempting to open log file: %s, log level:  %i...\n",p_dyndns->dbg.p_logfilename,
-			p_dyndns->dbg.level));
+		DBG_PRINTF((LOG_INFO, "I:" MODULE_TAG "Attempting to open log file: %s...\n",p_dyndns->dbg.p_logfilename));
 
 		rc = os_open_dbg_output(DBG_FILE_LOG, "", p_dyndns->dbg.p_logfilename,p_dyndns->dbg.level);
 
@@ -3060,6 +3170,35 @@
 		}
 	}
 
+	/*if pid-file wanted, create it*/
+	if (p_dyndns->p_pidfilename) {
+
+		if (strlen(p_dyndns->p_pidfilename) != 0)
+		{
+			FILE *fp=NULL;
+			int obj=0;
+			char pid[7];
+
+
+			if ((fp = utf_fopen(p_dyndns->p_pidfilename, "w")))
+			{
+
+#ifndef _WIN32
+				if (0<snprintf(pid, 7, "%d\n", getpid()))
+#else
+				if (0<_snprintf(pid, 7, "%d\n", _getpid()))
+#endif
+					obj = fwrite(pid, strlen(pid), 1, fp);
+
+				fclose(fp);
+			}
+			if (!fp || obj != 1)
+			{
+				return RC_FILE_IO_OPEN_ERROR;
+			}
+		}
+	}
+
 	dyn_dns_print_hello(NULL);
 
 	/*  now that log is open, report any command line errors eventhough registry params made up for them --
@@ -3072,7 +3211,7 @@
 
 	}
 
-	ip_cache_list_read(p_dyndns,&is_update_pending);
+	ip_cache_list_read(p_dyndns,&is_global_update_pending);
 
 	rc = dyn_dns_init(p_dyndns);
 
@@ -3080,7 +3219,7 @@
 
 		*init_flag=true;
 
-                rc = os_install_signal_handler(p_dyndns);
+		rc = os_install_signal_handler(p_dyndns);
 
 		if (rc != RC_OK)
 
@@ -3089,7 +3228,18 @@
 
 	if (rc==RC_OK) {
 
-		rc = get_encoded_user_passwd(p_dyndns);
+		char	i;
+		RC_TYPE	pw_rc;
+
+
+		for (i=0;i<p_dyndns->srv_cnt;i++) {
+
+			if (!(RC_OK==(pw_rc=get_encoded_user_passwd(p_dyndns,i))))
+
+				if (rc==RC_OK) /*return first of any error(s)*/
+
+					rc=pw_rc;
+		}
 
 #ifdef _WIN32
 
@@ -3127,7 +3277,10 @@
 */
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self)
 {
-	RC_TYPE rc;
+	char	i;
+	char	ii;
+
+
 	if (p_self == NULL)
 	{
 		return RC_OK;
@@ -3138,15 +3291,57 @@
 		dyn_dns_shutdown(p_self);
 	}
 
-	rc = http_client_destruct(&p_self->http_to_ip_server);
-	if (rc != RC_OK)
-	{
+	free(p_self->ip_server_name_global.name);
+	p_self->ip_server_name_global.name=NULL;
+	free(p_self->ip_server_name_global.url);
+	p_self->ip_server_name_global.url=NULL;
 
-	}
+	for (i=0;i<MAX_DNS_SERVER;i++) {
 
-	rc = http_client_destruct(&p_self->http_to_dyndns);
-	if (rc != RC_OK)
-	{
+		http_client_destruct(&p_self->info[i].http_to_ip_server);
+		http_client_destruct(&p_self->info[i].http_to_dyndns);
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+		p_self->info[i].i_face.my_ip_address.name[ip_store]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+		p_self->info[i].i_face.my_ip_address.name[ip_4]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+		p_self->info[i].i_face.my_ip_address.name[ip_6]=NULL;
+
+		free(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+		p_self->info[i].credentials.p_enc_usr_passwd_buffer=NULL;
+
+		free(p_self->info[i].credentials.my_username);
+		p_self->info[i].credentials.my_username=NULL;
+
+		free(p_self->info[i].credentials.my_password);
+		p_self->info[i].credentials.my_password=NULL;
+
+		free(p_self->info[i].dyndns_server_name.url);
+		p_self->info[i].dyndns_server_name.url=NULL;
+
+		free(p_self->info[i].proxy_server_name.name);
+		p_self->info[i].proxy_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.name);
+		p_self->info[i].ip_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.url);
+		p_self->info[i].ip_server_name.url=NULL;
+
+		free(p_self->info[i].ip_server_host);
+		p_self->info[i].ip_server_host=NULL;
+
+		free(p_self->info[i].dyndns_server_host);
+		p_self->info[i].dyndns_server_host=NULL;
+
+		for (ii=0;ii<p_self->info[i].alias_info.count;ii++) {
+
+			free(p_self->info[i].alias_info.names[ii].name);
+			p_self->info[i].alias_info.names[ii].name=NULL;
+		}
 
 	}
 
@@ -3162,11 +3357,6 @@
 		p_self->p_req_buffer = NULL;
 	}
 
-	if (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL)
-	{
-		free(p_self->info.credentials.p_enc_usr_passwd_buffer);
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-	}
 
 	if (p_self->lang_file != NULL)
 	{
@@ -3194,51 +3384,6 @@
 		p_self->time_cache=NULL;
 	}
 
-	if (p_self->info.credentials.my_username != NULL)
-	{
-
-		free(p_self->info.credentials.my_username);
-		p_self->info.credentials.my_username=NULL;
-	}
-
-	if (p_self->info.credentials.my_password != NULL)
-	{
-
-		free(p_self->info.credentials.my_password);
-		p_self->info.credentials.my_password=NULL;
-	}
-
-	{
-		int i=0;
-
-
-		while (1) {
-
-			if (!(p_self->alias_info.names[i].name != NULL))
-
-				break;
-			else
-			{
-
-				free(p_self->alias_info.names[i].name);
-				p_self->alias_info.names[i].name=NULL;
-			}
-		}
-	}
-
-	if (p_self->info.ip_server_url != NULL)
-	{
-
-		free(p_self->info.ip_server_url);
-		p_self->info.ip_server_url=NULL;
-	}
-
-	if (p_self->info.dyndns_server_url != NULL)
-	{
-
-		free(p_self->info.dyndns_server_url);
-		p_self->info.dyndns_server_url=NULL;
-	}
 
 	if (p_self->external_command != NULL)
 	{
@@ -3247,97 +3392,12 @@
 		p_self->external_command=NULL;
 	}
 
-	if (p_self->info.proxy_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.proxy_server_name.name[ip_store]);
-		p_self->info.proxy_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.dyndns_server_name.name[ip_store] !=NULL)
-	{
-		free(p_self->info.dyndns_server_name.name[ip_store]);
-		p_self->info.dyndns_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.ip_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.ip_server_name.name[ip_store]);
-		p_self->info.ip_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.ip_server_host != NULL)
-	{
-		free(p_self->info.ip_server_host);
-		p_self->info.ip_server_host=NULL;
-	}
-
-	if (p_self->info.dyndns_server_host != NULL)
-	{
-		free(p_self->info.dyndns_server_host);
-		p_self->info.dyndns_server_host=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_store]);
-		p_self->info.my_ip_address.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_4] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_4]);
-		p_self->info.my_ip_address.name[ip_4]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_6] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_6]);
-		p_self->info.my_ip_address.name[ip_6]=NULL;
-	}
+	free(p_self->p_pidfilename);
+	p_self->p_pidfilename = NULL;
 
 	ip_cache_list_destruct(&p_self->ip_cache_list);
 
-	if (p_self->if_name)
-	{
-		free(p_self->if_name);
-		p_self->if_name=NULL;
-	}
-
-	if (p_self->rsp_config_codes)
-	{
-		destroy_list(&p_self->rsp_config_codes);
-	}
-
-	if (p_self->rsp_success_codes)
-	{
-		destroy_list(&p_self->rsp_success_codes);
-	}
-
-	if (p_self->ip_param)
-	{
-		free(p_self->ip_param);
-		p_self->ip_param=NULL;
-	}
-
-	if (p_self->id_param)
-	{
-		free(p_self->id_param);
-		p_self->id_param=NULL;
-	}
-
-	if (p_self->pw_param)
-	{
-		free(p_self->pw_param);
-		p_self->pw_param=NULL;
-	}
-
-	free(p_self->servers_additional);
-	p_self->servers_additional=NULL;
+	destroy_custom_params(p_self);
 
 	free(p_self);
 	p_self = NULL;
@@ -3346,7 +3406,7 @@
 }
 
 /*
-	See if we can find servers_additional.cfg.
+        See if we can find servers_additional.cfg.
 */
 static void get_servers_additional(DYN_DNS_CLIENT *p_self)
 {
@@ -3466,6 +3526,8 @@
 	DYN_DNS_CLIENT	*p_self;
 	BOOL		http_to_dyndns_constructed = FALSE;
 	BOOL		http_to_ip_constructed = FALSE;
+	char i;
+
 
 	if (pp_self == NULL)
 	{
@@ -3502,25 +3564,30 @@
 		}
 
 
-		rc = http_client_construct(&p_self->http_to_ip_server);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
-		}
+		for (i=0;i<MAX_DNS_SERVER;i++) {
+
+			rc = http_client_construct(&p_self->info[i].http_to_ip_server);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		p_self->info.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			rc = http_client_construct(&p_self->info[i].http_to_dyndns);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		http_to_ip_constructed = TRUE;
+			p_self->info[i].i_face.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
 
-		rc = http_client_construct(&p_self->http_to_dyndns);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
+			p_self->info[i].credentials.p_enc_usr_passwd_buffer = NULL;
 		}
+
+		http_to_ip_constructed = TRUE;
 		http_to_dyndns_constructed = TRUE;
 
 		(p_self)->cmd = NO_CMD;
@@ -3528,12 +3595,9 @@
 		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;
 		(p_self)->initialized = FALSE;
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-
 		p_self->lang_file = NULL;
 
 		get_servers_additional(p_self);
-
 	}
 	while(0);
 
@@ -3551,25 +3615,33 @@
 		{
 			free (p_self->p_work_buffer);
 		}
-		if (http_to_dyndns_constructed)
 		{
-			http_client_destruct(&p_self->http_to_dyndns);
-		}
-		if (http_to_ip_constructed)
-		{
-			http_client_destruct(&p_self->http_to_ip_server);
-		}
-		if (p_self->info.my_ip_address.name[ip_store])
-		{
-			free(p_self->info.my_ip_address.name[ip_store]);
-		}
-		if (p_self->info.my_ip_address.name[ip_4])
-		{
-			free(p_self->info.my_ip_address.name[ip_4]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_dyndns);
+			}
 		}
-		if (p_self->info.my_ip_address.name[ip_6])
 		{
-			free(p_self->info.my_ip_address.name[ip_6]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_ip_server);
+			}
+
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				if (p_self->info[i].i_face.my_ip_address.name[ip_store])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_4])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_6])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+				}
+			}
 		}
 	}
 
--- src/dyndns.h
+++ src/dyndns.h
@@ -22,8 +22,8 @@
 /*
 
 	History:
-		Dec 2007 -- Added get_cmd.h include, for get_config_data_with_error_handling
-			prototype.
+		Dec 2007 -- Added get_cmd.h include, for get_config_data_with_error_handling 
+					prototype.
 */
 
 /*interface for main dydns functions */
@@ -76,7 +76,7 @@
 
 #endif
 
-#define DYNDNS_EXTRA_VERSION
+#define	DYNDNS_EXTRA_VERSION    "-ms_pid_patch_00"
 
 #define DYNDNS_VERSION_STRING	"02.24.47" DYNDNS_VERSION_SND DYNDNS_VERSION_THD DYNDNS_EXTRA_VERSION
 #define DYNDNS_AGENT_NAME	"inadyn-mt/" DYNDNS_VERSION_STRING
@@ -86,26 +86,27 @@
 
 typedef enum
 {
-	DYNDNS_DYNAMIC,
-	DYNDNS_STATIC,
-	DYNDNS_CUSTOM,
-	DYNDNS_DEFAULT,
-	FREEDNS_AFRAID_ORG_DEFAULT,
-	ZONE_EDIT_DEFAULT,
-	CUSTOM_HTTP_BASIC_AUTH,
-	NOIP_DEFAULT,
-	EASYDNS_DEFAULT,
-	DYNDNS_3322_DYNAMIC,
-	SITELUTIONS_DOMAIN,
-	TZO_DEFAULT,
-	DNSOMATIC_DEFAULT,
-	HE_IPV6TB,
-	DYNSIP_DEFAULT,
-	DHIS_DEFAULT,
-	MAJIMOTO_DEFAULT,
-	ZERIGO_DEFAULT,
-	TWODNS_DEFAULT,
-	LAST_DNS_SYSTEM = -1
+    DYNDNS_DYNAMIC,
+    DYNDNS_STATIC,
+    DYNDNS_CUSTOM,
+    DYNDNS_DEFAULT,
+    FREEDNS_AFRAID_ORG_DEFAULT,
+    ZONE_EDIT_DEFAULT,
+    CUSTOM_HTTP_BASIC_AUTH,
+    NOIP_DEFAULT,
+    EASYDNS_DEFAULT,
+    DYNDNS_3322_DYNAMIC,
+    SITELUTIONS_DOMAIN,
+    TZO_DEFAULT,
+    DNSOMATIC_DEFAULT,
+    HE_IPV6TB,
+    HE_DEFAULT,
+    DYNSIP_DEFAULT,
+    DHIS_DEFAULT,
+    MAJIMOTO_DEFAULT,
+    ZERIGO_DEFAULT,
+    TWODNS_DEFAULT,
+    LAST_DNS_SYSTEM = -1
 } DYNDNS_SYSTEM_ID;
 
 /*test values*/
@@ -148,7 +149,7 @@
 
 #define DYNDNS_SYSTEM_CUSTOM	"custom"
 #define DYNDNS_SYSTEM_DYNAMIC	"dyndns"
-#define DYNDNS_SYSTEM_STATIC	"statdns"
+#define DYNDNS_SYSTEM_STATIC	"statdns" 
 
 #define GENERIC_DNS_IP_SERVER_NAME	DYNDNS_MY_IP_SERVER
 #define DYNDNS_MY_DNS_SYSTEM		DYNDNS_DEFAULT
@@ -156,7 +157,6 @@
 /* Conversation with the IP server */
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST  \
 	"GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: " DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR "\r\n\r\n"
-
 /* dyndns.org specific update address format */
 /* 3322.org has the same parameters ...*/
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT \
@@ -196,24 +196,24 @@
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
 #define GENERIC_DNS_CUSTOM_BASIC_AUTH_MY_IP_REQUEST_FORMAT \
-	"GET %s%s&%s=%s&" \
-	"wildcard=%s " \
-	"HTTP/1.0\r\n" \
-	"Authorization: Basic %s\r\n" \
-	"Host: %s\r\n" \
-	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
+        "GET %s%s&%s=%s&" \
+        "wildcard=%s " \
+        "HTTP/1.0\r\n" \
+        "Authorization: Basic %s\r\n" \
+        "Host: %s\r\n" \
+        "User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
 #define GENERIC_DNS_CUSTOM_MY_IP_REQUEST_FORMAT \
-	"GET %s%s&%s=%s&" \
-	"%s=%s&" \
-	"%s=%s&" \
-	"wildcard=%s " \
-	"HTTP/1.0\r\n" \
-	"Host: %s\r\n" \
-	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
+        "GET %s%s&%s=%s&" \
+        "%s=%s&" \
+        "%s=%s&" \
+        "wildcard=%s " \
+        "HTTP/1.0\r\n" \
+        "Host: %s\r\n" \
+        "User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
 #define GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT \
-	"GET %s%s&myip=%s " \
+    "GET %s%s&myip=%s " \
 	 "HTTP/1.0\r\n" \
 	"Authorization: Basic %s\r\n" \
 	"Host: %s\r\n" \
@@ -246,7 +246,7 @@
 	"GET %s%s&" \
 	"Email=%s&" \
 	"TZOKey=%s&" \
-	"IPAddress=%s " \
+	"IPAddress=%s "	\
 	"HTTP/1.0\r\n" \
 	"Host: %s\r\n" \
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
@@ -257,8 +257,18 @@
 	"ipv4b=%s&" \
 	"user_id=%s&" \
 	"pass=%s&" \
-	"tunnel_id=%s " \
+	"tunnel_id=%s "	\
 	"HTTP/1.0\r\n" \
+	"Host: %s\r\n"	\
+	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
+
+/* HE DynDNS specific update request format */
+#define HE_DEFAULT_UPDATE_MY_IP_REQUEST_FORMAT	\
+	"GET %s" \
+	"hostname=%s&"	\
+	"myip=%s " \
+	"HTTP/1.0\r\n"	\
+	"Authorization: Basic %s\r\n"	\
 	"Host: %s\r\n" \
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
@@ -277,13 +287,13 @@
 #define MAJIMOTO_MY_IP_UPDATE_REQUEST_FORMAT \
 	"GET %s" \
 	"hostname=%s&" \
-	"myip=%s "		\
+	"myip=%s " \
 	"HTTP/1.0\r\n" \
 	"Authorization: Basic %s\r\n" \
 	"Host: %s\r\n" \
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
-/* zerogo.net specific update request format */
+/* zerigo.net specific update request format */
 #define ZERIGO_MY_IP_UPDATE_REQUEST_FORMAT \
 	"GET %s%s&" \
 	"ip=%s " \
@@ -309,11 +319,11 @@
 
 
 /* SOME DEFAULT CONFIGURATIONS */
-#define DYNDNS_DEFAULT_SLEEP			(600)					/*s*/
-#define DYNDNS_MIN_SLEEP			(30)					/*s*/
-#define DYNDNS_MAX_SLEEP			(10 * 24 * 3600)			/*10 days in s*/
+#define DYNDNS_DEFAULT_SLEEP			(600)	/*s*/
+#define DYNDNS_MIN_SLEEP			(30)	/*s*/
+#define DYNDNS_MAX_SLEEP			(10 * 24 * 3600)	/*10 days in s*/
 #define DYNDNS_MIN_FORCED_UPDATE_PERIOD_S	DYNDNS_MIN_SLEEP
-#define DYNDNS_MAX_FORCED_UPDATE_PERIOD_S	(30 * 24 * 3600)			/* 30 days in sec*/
+#define DYNDNS_MAX_FORCED_UPDATE_PERIOD_S	(30 * 24 * 3600)	/* 30 days in sec*/
 #define DYNDNS_MY_FORCED_UPDATE_PERIOD_S	DYNDNS_MAX_FORCED_UPDATE_PERIOD_S	/* 30 days in sec*/
 #define DYNDNS_DEFAULT_UPDATE_ADJUST		.5
 #define DYNDNS_MIN_FORCED_UPDATE_ADJUST		-4
@@ -345,13 +355,13 @@
 
 /*attenuation max, min constants -- translate to [-40..0], [-120db..0db]*/
 #define DYNDNS_MAX_WAVE_RANGE			120
-#define DYNDNS_MIN_WAVE_GAIN			-10		/*minimum wave play volume*/
-#define DYNDNS_MAX_WAVE_GAIN			10		/*maximum wave play volume*/
+#define DYNDNS_MIN_WAVE_GAIN			-10	/*minimum wave play volume*/
+#define DYNDNS_MAX_WAVE_GAIN			10	/*maximum wave play volume*/
 
-#define DYNDNS_INFINITE_WAVE			-1		/*infinite times per wave play call to play wave file*/
-#define DYNDNS_DEFAULT_INAUDIBLE		1		/*audible alerts default as on*/
-#define DYNDNS_DEFAULT_ALERT_RETRIES		0		/*network retries before sounding alert*/
-#define DYNDNS_DEFAULT_ALERT_INTERVAL		0		/*ms time between audible alerts*/
+#define DYNDNS_INFINITE_WAVE			-1	/*infinite times per wave play call to play wave file*/
+#define DYNDNS_DEFAULT_INAUDIBLE		1	/*audible alerts default as on*/
+#define DYNDNS_DEFAULT_ALERT_RETRIES		0	/*network retries before sounding alert*/
+#define DYNDNS_DEFAULT_ALERT_INTERVAL		0	/*ms time between audible alerts*/
 #define DYNDNS_DEFAULT_WAVE_FILE		"alarm.wav"	/*default wave file, and path ("current working dir")*/
 #define DYNDNS_DEFAULT_WAVE_BUFF_FACTOR		.25		/*max by which to divide or multiply wave file bytes per second for buffer size*/
 
@@ -367,12 +377,12 @@
 #define DYNDNS_DEFAULT_USER_WAVE_GAIN		10
 
 /*allow attenuate to 120db in DYNDNS_MAX_WAVE_RANGE increments*/
-#define DYNDNS_DECIBEL_STEP			DYNDNS_MAX_WAVE_RANGE/(-1*DYNDNS_MIN_WAVE_GAIN+DYNDNS_MAX_WAVE_GAIN)
+#define DYNDNS_DECIBEL_STEP		DYNDNS_MAX_WAVE_RANGE/(-1*DYNDNS_MIN_WAVE_GAIN+DYNDNS_MAX_WAVE_GAIN)
 
-#define DYNDNS_DEFAULT_WAVE_LOOPS		0		/*default number of times per wave play call to play wave file*/
+#define DYNDNS_DEFAULT_WAVE_LOOPS		0	/*default number of times per wave play call to play wave file*/
 
-#define DYNDNS_DEFAULT_STATUS_INTERVAL		600		/*seconds online status check interval default*/
-#define DYNDNS_DEFAULT_STATUS_OFFLINE_INTERVAL	15		/*seconds online status check interval default, after offline detect*/
+#define DYNDNS_DEFAULT_STATUS_INTERVAL		600	/*seconds online status check interval default*/
+#define DYNDNS_DEFAULT_STATUS_OFFLINE_INTERVAL	15	/*seconds online status check interval default, after offline detect*/
 
 /*local configs*/
 /*address str may contain both ip4,ip6 separated by semi colon*/
@@ -391,21 +401,24 @@
 #define DUAL_LIST		"coupled"
 #define MAX_IP_TYPE_SIZE	8
 
+#define MAX_DNS_SERVER		10
+
 /* typedefs */
 struct _DYN_DNS_CLIENT;
 struct DYNDNS_SYSTEM;
+struct DYNDNS_INFO_TYPE;
 
 /** Types used for DNS system specific configuration
 */
 /** Function to prepare DNS system specific server requests
 */
 
-typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int nr, struct DYNDNS_SYSTEM *p_sys_info);
-typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, int alias_index, char *p_rsp, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, char srv_cnt, int nr, struct DYNDNS_SYSTEM *p_sys_info);
+typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, int alias_index, char *p_rsp, const char*p_ok_str,char srv_cnt);
 
 typedef struct
 {
-	const char*				p_key;
+	char*					p_key;
 	void*					p_specific_data;
 	DNS_SYSTEM_SRV_RESPONSE_OK_FUNC		p_rsp_ok_func;
 	DNS_SYSTEM_REQUEST_FUNC			p_dns_update_req_func;
@@ -462,10 +475,17 @@
 
 typedef struct
 {
-	char	*name[3];
+	char	*name;
+	char	*url;
 	int	port;
 } DYNDNS_SERVER_NAME;
 
+typedef struct
+{
+	char	*name[3];
+	int	port;
+} DYNDNS_MY_IP;
+
 /*a given alias (dyn domain names) can
   be associated with one "ip type", of
   'dual', 'coupled', 'ip4', 'ip6', 'auto',
@@ -484,12 +504,20 @@
 
 typedef struct
 {
-    	BOOL			my_ip_has_changed[3];
-	BOOL			is_update_ip4;
-	BOOL			is_update_ip6;
-	BOOL			is_update_auto;
-	BOOL			is_got_ip4;
-	BOOL			is_got_ip6;
+	/*multiple of ip types (2 -- IPv4, IPv6)*/
+	DYNDNS_ALIAS_NAME	names[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int			update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int			update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int			fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
+	DYNDNS_HASH_TYPE	hashes[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int			count;
+	int			count_dual;
+} DYNDNS_ALIAS_INFO;
+
+typedef struct
+{
+
+	BOOL my_ip_has_changed[3];
 
 	/*3 strings - ip_4, ip_6 address,
 	  and temp store, ip_store for
@@ -499,31 +527,50 @@
 	  convenient) -- for instance,
 	  ip type "auto" (based on first
 	  address returned by ip server)*/
-	DYNDNS_SERVER_NAME	my_ip_address;
-	struct sockaddr_storage	net_addr[3];
+	DYNDNS_MY_IP my_ip_address;
+} DYNDNS_IFACE_INFO;
+
+/*per update server*/
+typedef struct DYNDNS_INFO_TYPE
+{
+	BOOL is_update_ip4;
+	BOOL is_update_ip6;
+	BOOL is_update_auto;
+	BOOL is_got_ip4;
+	BOOL is_got_ip6;
+
+	HTTP_CLIENT	http_to_ip_server;
+	HTTP_CLIENT	http_to_dyndns;
+
+	DYNDNS_IFACE_INFO	i_face;
 
 	DYNDNS_CREDENTIALS	credentials;
 	DYNDNS_SYSTEM		*p_dns_system;
 	DYNDNS_SERVER_NAME	dyndns_server_name;
-	char			*dyndns_server_url;
-	char			*dyndns_server_host;
-	DYNDNS_SERVER_NAME	ip_server_name;
-	char			*ip_server_host;
-	char			*ip_server_url;
+        char                    *dyndns_server_host;
+        DYNDNS_SERVER_NAME      ip_server_name;
+        char                    *ip_server_host;
 	DYNDNS_SERVER_NAME	proxy_server_name;
-} DYNDNS_INFO_TYPE;
 
-typedef struct
-{
-	/*multiple of ip types (2 -- IPv4, IPv6)*/
-	DYNDNS_ALIAS_NAME	names[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int			update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int			update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int			fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
-	DYNDNS_HASH_TYPE	hashes[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int			count;
-	int			count_dual;
-} DYNDNS_ALIAS_INFO;
+	DYNDNS_ALIAS_INFO	alias_info;
+        BOOL                    wildcard;
+
+	BOOL			is_bad_config;
+	BOOL			is_update_pending;
+
+	/*additional custom DDNS server type options*/
+	gen_list		rsp_success_codes;
+	gen_list		rsp_config_codes;
+	char			*ip_param;
+	char			*id_param;
+	char			*pw_param;
+	int			is_ip_in_svr_rsp;
+
+	IPV6_PRIV_EXT		ipv6_priv_ext;
+	char			*if_name;
+	struct sockaddr_storage	net_addr[3];
+
+} DYNDNS_INFO_TYPE;
 
 typedef struct
 {
@@ -533,60 +580,58 @@
 
 typedef struct IP_CACHE
 {
-        char            *ip;
-        char            *alias;
-        char            *type;
-        char            *server;
-        char            *ip_alias_type;
+	char		*ip;
+	char		*alias;
+	char		*type;
+	char		*server;
+	char		*ip_alias_type;
 
-        unsigned char   ip_n[16];
+	unsigned char	ip_n[16];
 } IP_CACHE;
 
 typedef struct IP_CACHE_LIST {
 
-        IP_CACHE        *saved_ip_cache;
+	IP_CACHE	*saved_ip_cache;
 
-        int             count;
+	int		count;
 } IP_CACHE_LIST;
 
 typedef struct DYN_DNS_CLIENT
 {
 	DYN_DNS_CMD	cmd;
-	int		sleep_sec;				/* time between 2 updates*/
+	int		sleep_sec;			/* time between 2 updates*/
 	unsigned	forced_update_period_sec;
-	float		forced_update_adjust;			/* how to round forced update calculation */
-	unsigned	forced_update_period_sec_orig;		/* original read from cmd line */
+	float		forced_update_adjust;		/* how to round forced update calculation */
+	unsigned	forced_update_period_sec_orig;	/* original read from cmd line */
 	int		times_since_last_update;
-	int		forced_update_times;			/* the same forced update period counted in sleep periods*/
-	unsigned	cmd_check_period;			/*time to wait for a command*/
-	unsigned	forced_update_counter;			/*cmd_check_periods tracking forced_update_period expiration*/
+	int		forced_update_times;		/* the same forced update period counted in sleep periods*/
+	unsigned	cmd_check_period;		/*time to wait for a command*/
+	unsigned	forced_update_counter;		/*cmd_check_periods tracking forced_update_period expiration*/	
 	int		is_forced_update_attempted;
 	int		total_iterations;
 	int		iterations;
-	int		net_retries;				/*failed comm retries*/
-	long		retry_interval;				/*miliseconds wait interval between retries*/
+	int		net_retries;			/*failed comm retries*/
+	long		retry_interval;			/*miliseconds wait interval between retries*/
 	long		retry_pending_interval;
 	int		retry_pending_off;
-	int		retry_later;				/*dyndns2 network error - retry in 5 minutes*/
-	char		*lang_file;				/*language (locale) file full path, and file name*/
-	int		lang_hard_coded;			/*flagged when --lang_file parameter with empty option*/
-	int		audible_off;				/*compiled with USE_SNDFILE defined, but want run without*/
-	char		*wave_file;				/*network status alerts wave file full path, and file name*/
-	int		wave_loops;				/*number of times per wave play call to play wave file*/
-	float		wave_gain;				/*volume at which to play wave file*/
-	int		alert_retries;				/*network retries before sounding alert*/
-	int		alert_interval;				/*time betweens sounding network status alarm*/
-	int		status_interval;			/*ms between online status checks*/
-	int		status_offline_interval;		/*ms between online status checks, after offline detect*/
-	float		wave_buff_factor;			/*multiple of wave file bytes per second*/
+	int		retry_later;			/*dyndns2 network error - retry in 5 minutes*/
+	char		*lang_file;			/*language (locale) file full path, and file name*/
+	int		lang_hard_coded;		/*flagged when --lang_file parameter with empty option*/
+	int		audible_off;			/*compiled with USE_SNDFILE defined, but want run without*/
+	char		*wave_file;			/*network status alerts wave file full path, and file name*/
+	int		wave_loops;			/*number of times per wave play call to play wave file*/
+	float		wave_gain;			/*volume at which to play wave file*/
+	int		alert_retries;			/*network retries before sounding alert*/
+	int		alert_interval;			/*time betweens sounding network status alarm*/
+	int		status_interval;		/*ms between online status checks*/
+	int		status_offline_interval;	/*ms between online status checks, after offline detect*/
+	float		wave_buff_factor;		/*multiple of wave file bytes per second*/
 
 	BOOL		initialized;
 	BOOL		run_in_background;
 	BOOL		debug_to_syslog;
 	BOOL		change_persona;
 
-	HTTP_CLIENT		http_to_ip_server;
-	HTTP_CLIENT		http_to_dyndns;
 	HTTP_TRANSACTION	http_tr;
 	char			*p_work_buffer;		/* for HTTP responses*/
 	int			work_buffer_size;
@@ -596,45 +641,39 @@
 	char			*time_cache;
 	char			*ip_cache;
 
-
 	USER_INFO		sys_usr_info;		/*info about the current account running inadyn*/
-	DYNDNS_INFO_TYPE	info;			/*servers, names, passwd*/
-	DYNDNS_INFO_TYPE	info_online_status;	/*info about url to reach to confirm online status -- defaults to info*/
 
-	DYNDNS_ALIAS_INFO	alias_info;
+
+
+	DYNDNS_INFO_TYPE	info[MAX_DNS_SERVER];	/*servers, names, passwd*/
+	char			srv_cnt;
 
 	IP_CACHE_LIST		ip_cache_list;		/*read in from ip cache file written on ddns update*/
 
+	DYNDNS_SERVER_NAME	info_online_status;	/*info about url to reach to confirm online status -- defaults to info*/
+
 	BOOL			abort_on_network_errors;
 	BOOL			force_addr_update;
 	BOOL			use_proxy;
 	BOOL			abort;
-	BOOL			wildcard;
-	BOOL			is_bad_config;
+	BOOL			is_global_bad_config;	/*all servers*/
 
-	IPV6_PRIV_EXT		ipv6_priv_ext;
-	char			*if_name;
+	DYNDNS_SERVER_NAME	ip_server_name_global;
 
-	/*additional custom DDNS server type options*/
-	gen_list	rsp_success_codes;
-	gen_list	rsp_config_codes;
-	char		*ip_param;
-	char		*id_param;
-	char		*pw_param;
-	int		is_ip_in_svr_rsp;
+	char 			*p_pidfilename;
 
-	char		*servers_additional;
+	char			*servers_additional;
 
 	/*dbg*/
 	DBG_TYPE		dbg;
 } DYN_DNS_CLIENT;
 
-
 /*for mapping servers_additional.cfg variable identifiers
   to values in arg_to_val (in inadyn_cmd.c)*/
 struct EXP_MAPPING {
 
         DYN_DNS_CLIENT  *p_dyndns;
+	int		server_index;
         int             alias_index;
 }EXP_MAPPING;
 
@@ -667,17 +706,33 @@
 char *print_time(void);
 
 /*
-	 basic resource allocations for the dyn_dns object**
+	 basic resource allocations for the dyn_dns object
 */
 RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT **pp_self);
 
 /*
 	Resource free.
-*/
+*/	
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self);
 
 void dyndns_event(int i_event,void  *p_context);
 
+/*
+	Disconnect and some other clean up.
+*/
+
+/* the real action:
+	- detect current IP
+		- connect to an HTTP server 
+		- parse the response for IP addr
+
+	- for all the names that have to be maintained
+		- get the current DYN DNS address from DYN DNS server
+		- compare and update if neccessary
+*/
+
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt);
+
 /* MAIN - Dyn DNS update entry point.*/
 
 /*
@@ -685,7 +740,7 @@
 		- read the configuration options
 		- create and init dyn_dns object.
 		- launch the IP update action
-*/
+*/		
 int dyn_dns_main(DYN_DNS_CLIENT *p_self, int argc, char* argv[]);
 
 
@@ -703,7 +758,7 @@
 
 #else
 
-int service_event_handler_orig(SERVICE_EVENT service_event);
+int service_event_handler(SERVICE_EVENT service_event);
 
 int inadyn_main(int argc, char* argv[],int is_service_in,FILE *pLOG_FILE);
 
--- src/errorcode.h
+++ src/errorcode.h
@@ -46,7 +46,8 @@
 	RC_HTTP_OBJECT_NOT_INITIALIZED			= 0x30,
 	RC_HTTP_BAD_PARAMETER				= 0x31,
 
-	RC_DYNDNS_SERVER_ERROR				= 0x38,
+	RC_DYNDNS_SERVER_ERROR				= 0x37,
+	RC_DYNDNS_TOO_MANY_SERVERS			= 0x38,
 	RC_DYNDNS_INVALID_IP_ADDR			= 0x39,
 	RC_DYNDNS_BUFFER_TOO_SMALL			= 0x40,
 	RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE	= 0x41,
--- src/inadyn_cmd.c
+++ src/inadyn_cmd.c
@@ -21,15 +21,15 @@
 */
 
 /*
-	Dyn Dns update main implementation file
+	Dyn Dns update main implementation file 
 	Author: narcis Ilisei
 	Date: May 2003
 
 	History:
 		- first implemetnation
-		- 18 May 2003 : cmd line option reading added -
+		- 18 May 2003 : cmd line option reading added - 
 		- many options added
-		- january 2005 - new format for the config file =Thanks to Jerome Benoit.
+		- january 2005 - new format for the config file =Thanks to Jerome Benoit. 
 		- january 30 2005 - new parser for config file -
 		- october 2007 - debug level command line parameter added
 		- dec 2007 - file options handler now provides for command line options precedence
@@ -59,6 +59,7 @@
 #include "unicode_util.h"
 #include "safe_mem.h"
 #include "path.h"
+#include "args_exp.h"
 
 /* command line options */
 #define DYNDNS_INPUT_FILE_OPT_STRING "--input_file"
@@ -73,6 +74,7 @@
 static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dns_server_host_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_ip_server_host_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -87,6 +89,7 @@
 #endif
 
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -129,6 +132,13 @@
 
 #endif
 
+/*
+	muti-services -- inc or set index based on
+	most recent server name option parameter
+	appearance.
+*/
+static server_index=0;
+
 static CMD_DESCRIPTION_TYPE cmd_options_table[] =
     {
         {"--help",	0,	{help_handler, NULL,0},	"help" },
@@ -140,18 +150,19 @@
         {"--password",	1,	{get_password_handler, NULL,0},	"<password> - your password. Optional."},
         {"-p",		1,	{get_password_handler, NULL,0},	"<password> - your password"},
 
-        {"--alias",	4,	{get_alias_handler, NULL,3},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimted\n          hash, and optional ip version, default auto. This option can appear multiple times." },
-        {"-a",		4,	{get_alias_handler, NULL,3},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimited\n          hash, and optional ip version, default auto. This option can appear multiple times." },
+        {"--alias",	3,	{get_alias_handler, NULL,2},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimted hash, and optional ip version, default auto. This option can appear multiple times." },
+        {"-a",		3,	{get_alias_handler, NULL,2},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimited hash, and optional ip version, default auto. This option can appear multiple times." },
 
-        {"--debug",     1,  {get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
-        {"-d",          1,  {get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
+        {"--debug",     1,	{get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
+        {"-d",          1,	{get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
 
-        /*for help display only -- service_main takes care of these handlers
+        /*
+        for help display only -- service_main takes care of these handlers
 
-          could have a service_main_display_help() function instead
+        could have a servie_main_display_help() function instead
         */
 
-#ifdef _WIN32
+#ifdef _WIN32  
         {"-i",3,{NULL, NULL,3},"[quoted service description] [-n <service name>] - install service"},
         {"-s",2,{NULL, NULL,2},"[-n <service name>] - start service"},
         {"-e",2,{NULL, NULL,2},"[-n <service name>] - exit service"},
@@ -160,13 +171,37 @@
 #endif
 
 
-        {DYNDNS_INPUT_FILE_OPT_STRING,	1,	{get_options_from_file_handler, NULL,0}, "<path/file> - the file containing inadyn options.  The default config file, '" DYNDNS_MT_DEFAULT_CONFIG_FILE "'\n          is used if inadyn is called without any cmd line options.  Input file options are inserted at point of this\n          option's appearance." },
-        {"--ip_server_name",		2,	{get_ip_server_name_handler, NULL,0},"<srv_name[:port] local_url> - local IP is detected by parsing the response after returned\n          by this server and URL.  The first IP in found http response is considered 'my IP'."},
-        {"--ip_server_host",		1,	{get_ip_server_host_handler, NULL,0},"<host name> - Host name used in http request to ip server if differnt from ip server name,\n          as when, e.g., ip_server_name is 'localhost:port /' through an SSL bridge.  Defaults to ip server name."},
-        {"--online_check_url",		2,	{get_online_check_url_handler, NULL,1},"<srv_name[:port] local_url> - URL to reach to confirm online status.  Default value:  \n          " DYNDNS_MY_ONLINE_CHECK " /"},
-        {"--dyndns_server_name",	1,	{get_dns_server_name_handler, NULL,0},"<NAME>[:port] - The server that receives the update DNS request.  Allows the use of\n          unknown DNS services that accept HTTP updates.  If no proxy is wanted, then it\n          is enough to set the dyndns system. The default servers will be taken."},
-        {"--dyndns_server_url",		1,	{get_dns_server_url_handler, NULL,0},"<name> - full URL relative to DynDNS server root.  Ex: /some_script.php?hostname="},
-        {"--dyndns_server_host",	1,	{get_dns_server_host_handler, NULL,0},"<host name> - Host name used in http update DNS request, if different from dyndns server\n          name, as when, e.g., dyndns_server_name is 'localhost:port' through an SSL bridge.  Defaults to dyndns server name."},
+        {DYNDNS_INPUT_FILE_OPT_STRING,	1,	{get_options_from_file_handler, NULL,0}, "<path/file> - the file containing [further] inadyn options.  "
+         "The default config file, '" DYNDNS_MT_DEFAULT_CONFIG_FILE "' is used if inadyn is called without any cmd line options.  "\
+         "Input file options are inserted at point of this option's appearance." },
+
+        {"--ip_server_name",		2,	{get_ip_server_name_handler, NULL,0},
+         "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
+         "The first IP in found http response is considered 'my IP'."},
+
+        {"--ip_server_host",            1,      {get_ip_server_host_handler, NULL,0},
+	 "<host name> - Host name used in http request to ip server if differnt from ip server name.  Defaults to ip server name."},
+
+        {"--ip_server_name_global",	2,	{get_global_ip_server_name_handler, NULL,0},
+         "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
+         "The first IP in found http response is considered 'my IP'.  Same as ip_server_name option, but overrides unchanged dyndns_system default ip servers."},
+
+        {"--online_check_url",		2,	{get_online_check_url_handler, NULL,0},
+         "<srv_name[:port] local_url> - URL to reach to confirm online status.  "\
+         "Default value:  " DYNDNS_MY_ONLINE_CHECK " /"},
+
+        {"--dyndns_server_name", 	1,	{get_dns_server_name_handler, NULL,0},
+         "<NAME>[:port] - The server that receives the update DNS request.  Allows the use of unknown DNS services that "\
+		 "accept HTTP updates.  If no proxy is wanted, then it is enough to set the dyndns system. The default servers "\
+		 "will be taken."},
+
+        {"--dyndns_server_url", 	1, {get_dns_server_url_handler, NULL,0},
+         "<name> - full URL relative to DynDNS server root.  Ex: /some_script.php?hostname="},
+
+        {"--dyndns_server_host",        1,      {get_dns_server_host_handler, NULL,0},
+         "<host name> - Host name used in http update DNS request, if different from dyndns server name.  Defaults to "\
+          "dyndns server name."},
+
         {"--dyndns_system",		1,	{get_dyndns_system_handler, NULL,0},
          "[NAME] - optional DYNDNS service type. SHOULD be one of the following: \n"
          "\t\t-For dyndns.org:  dyndns@dyndns.org OR statdns@dyndns.org OR customdns@dyndns.org.\n"
@@ -203,9 +238,9 @@
          "\t\tDEFAULT value: dyndns@dyndns.org\n"},
 
         {"--proxy_server",		1,	{get_proxy_server_handler, NULL,0},"[NAME[:port]]  - the http proxy server name and port. Default is none."},
-        {"--update_period",		1,	{get_update_period_handler, NULL,0},"<#> - how often the IP is checked. The period is in [ms]. 30000..864000000.  Default is\n          about 10 min. Max is 10 days"},
-        {"--update_period_sec",		1,	{get_update_period_sec_handler, NULL,0},"<#> - how often the IP is checked. The period is in [sec]. 30..864000.  Default is\n          about 10 min. Max is 10 days"},
-        {"--forced_update_period",	1,	{get_forced_update_period_handler, NULL,0},"<#> - how often, in seconds, the IP is updated even if it is not changed. 30 sec\n          ..30 days, default, 30 days."},
+        {"--update_period",		1,	{get_update_period_handler, NULL,0},"<#> - how often the IP is checked. The period is in [ms]. 30000..864000000.  Default is about 10 min. Max is 10 days"},
+        {"--update_period_sec",		1,	{get_update_period_sec_handler, NULL,0},"<#> - how often the IP is checked. The period is in [sec]. 30..864000.  Default is about 10 min. Max is 10 days"},
+        {"--forced_update_period", 	1,	{get_forced_update_period_handler, NULL,0},"<#> - how often, in seconds, the IP is updated even if it is not changed. 30 sec..30 days, default, 30 days."},
 
 #ifdef USE_THREADS
 
@@ -213,36 +248,40 @@
 #endif
 
         {"--log_file",			1,	{get_logfile_name, NULL,0},"<path/file> - log file path and name"},
+        {"--pid_file",			1,	{get_pidfile_name, NULL,0},"pid file path and name"},
         {"--background",		0,	{set_silent_handler, NULL,0},"run in background. output to log file or to syslog"},
-
 	{"--verbose",			1,	{set_verbose_handler, NULL,0},"<#> - set dbg level. 0 to 5"},
 
 	{"--iterations",		1,	{set_iterations_handler, NULL,0},"<#> - set the number of DNS updates. Default is 0, which means infinity."},
-        {"--syslog",			0,	{set_syslog_handler, NULL,0},	"force logging to syslog . (e.g. /var/log/mepossages). Works on **NIX systems only."},
-        {"--change_persona",		1,	{set_change_persona_handler, NULL,0}, "<uid[:gid]> - after init switch to a new user/group. Parameters: <uid[:gid]> to change to.\n          Works on **NIX systems only."},
-        {"--version",			0,	{print_version_handler, NULL,0}, "print the version number."},
-        {"--exec",			1,	{get_exec_handler, NULL,0}, "<command> - external command to exec after an IP update. Include the full path."},
-        {"--cache_dir",			1,	{get_cache_dir_handler, NULL,0}, "<path> - cache directory name. (e.g. /tmp/ddns). Defaults to /tmp on **NIX systems."},
-        {"--wildcard",			0,	{wildcard_handler, NULL,0}, "enable domain wildcarding for dyndns.org, 3322.org, or easydns.com."},
-        {"--retries",			1,	{get_retries_handler, NULL,0}, "<#> - network comm retry attempts.  0 to 100, default 0"},
-        {"--retry_interval",		1,	{get_retry_interval_handler, NULL,0}, "<#> - network comm miliseconds retry interval.  0 to 30,000, default 1,000"},
-	{"--retry_pending",		0,	{get_retry_pending_off_handler, NULL,0}, "<#> - retry ip update even after network comm retries exhausted,  default on"},
-	{"--retry_pending_interval",	1,	{get_retry_pending_interval_handler, NULL,0}, "<#> - network comm seconds update retry interval, after retries exhausted.  5..3600,\n          default 300"},
-	{"--lang_file",			1,	{get_lang_file_handler, NULL,1}, "[path/file] - language file path, and file name, defaults to either ../inadyn-mt/lang/en.lng, or\n          etc/inadyn-mt/en.lng.  Empty parameter option gives hard coded english defaults."},
+        {"--syslog",			0,	{set_syslog_handler, NULL,0},"force logging to syslog . (e.g. /var/log/messages). Works on **NIX systems only."},
+        {"--change_persona",		1,	{set_change_persona_handler, NULL,0},"<uid[:gid]> - after init switch to a new user/group. Parameters: <uid[:gid]> to change to. Works on **NIX systems only."},
+        {"--version",			0,	{print_version_handler, NULL,0},"print the version number\n"},
+        {"--exec",			1,	{get_exec_handler, NULL,0},"<command> - external command to exec after an IP update. Include the full path."},
+        {"--cache_dir",			1,	{get_cache_dir_handler, NULL,0},"<path> - cache directory name. (e.g. /tmp/ddns). Defaults to /tmp on **NIX systems."},
+        {"--wildcard",			0,	{wildcard_handler, NULL,0},"enable domain wildcarding for dyndns.org, 3322.org, or easydns.com."},
+        {"--retries",			1,	{get_retries_handler, NULL,0},"<#> - network comm retry attempts.  0 to 100, default 0"},
+        {"--retry_interval",		1, 	{get_retry_interval_handler, NULL,0},"<#> - network comm miliseconds retry interval.  0 to 30,000, default 1,000"},
+	{"--retry_pending",		0,	{get_retry_pending_off_handler, NULL,0},"<#> - retry ip update even after network comm retries exhausted,  default on"},
+	{"--retry_pending_interval",	1,	{get_retry_pending_interval_handler, NULL,0},"<#> - network comm seconds update retry interval, after retries exhausted.  5..3600, default 300"},
+        {"--lang_file",			1,	{get_lang_file_handler, NULL,1},"[path/file] - language file path, and file name, defaults to either ../inadyn-mt/lang/en.lng, or etc/inadyn-mt/en.lng.  Empty parameter option gives hard coded english defaults."},
 #ifdef USE_SNDFILE
-	{"--audible",			0,	{get_audible_on_handler, NULL,0}, "audible network status alerts toggle.  default off"},
-	{"--wave_file",			2,	{get_wave_file_handler, NULL,1}, "<path/file [#] - audible network status alerts wave file path, and file name. defaults\n          to either ../inadyn-mt/extra/wav/alarm.wav, or etc/inadyn-mt/extra/wav/alarm.wav \n          [wave loops: 0..100; -1 for infinite] same as wave_loops below -- optional number of\n          times per wave play call to repeat wave file play, default 0"},
-	{"--wave_loops",		1,	{get_wave_loops_handler, NULL,0}, "<#> - same as wave_file parameter optional parameter --\n          0..100; -1 for infinite number of times per wave play call to repeat wave file play, default 0"},
-	{"--alert_retries",		1,	{get_alert_retries_handler, NULL,0}, "<#> - network retries before audible network status alerts. [0..100], default 0"},
-	{"--alert_interval",		1,	{get_alert_interval_handler, NULL,0}, "<#> - time in miliseconds between consecutive audible network status alerts. [0..3600000],\n          default 0"},
-	{"--wave_gain",			1,	{get_wave_gain_handler, NULL,0}, "<#> - gain (amplitude adjust) at which to play audible alert (beware clipping), integer or float.\n          [-10..10], default 10 (0db, no attenuation)."},
-	{"--wave_buff",			1,	{get_wave_buff_handler, NULL,0}, "<#> - wave file output buffer size control -- integer or float multiple of wave file bytes per sec.\n          [.25..10], default .25"},
+	{"--audible",			0,	{get_audible_on_handler, NULL,0},"audible network status alerts toggle.  default off"},
+	{"--wave_file",			2,	{get_wave_file_handler, NULL,1},"<path/file [#] - audible network status alerts wave file path, and file name. defaults\n" \
+         "\t\tto either ../inadyn-mt/extra/wav/alarm.wav, or etc/inadyn-mt/extra/wav/alarm.wav \n"\
+         "\t\t[wave loops: 0..100; -1 for infinite] same as wave_loops below -- optional number of\n"\
+         "\t\ttimes per wave play call to repeat wave file play, default 0"},
+	{"--wave_loops",		1,	{get_wave_loops_handler, NULL,0},"<#> - same as wave_file parameter optional parameter --\n"\
+         "\t\t0..100; -1 for infinite number of times per wave play call to repeat wave file play, default 0"},
+	{"--alert_retries",		1,	{get_alert_retries_handler, NULL,0},"<#> - network retries before audible network status alerts. [0..100], default 0"},
+	{"--alert_interval",		1,	{get_alert_interval_handler, NULL,0},"<#> - time in miliseconds between consecutive audible network status alerts. [0..3600000], default 0"},
+	{"--wave_gain",			1,	{get_wave_gain_handler, NULL,0},"<#> - gain (amplitude adjust) at which to play audible alert (beware clipping), integer or float. [-10..10], default 10 (0db, no attenuation)."},
+	{"--wave_buff",			1,	{get_wave_buff_handler, NULL,0},"<#> - wave file output buffer size control -- integer or float multiple of wave file bytes per sec. [.25..10], default .25"},
 
 /*possible other options:
 		-time before go into rest period
 		-time to rest
-		-time of day block out period
-		-for dial-up, don't test connect
+		-time of day block out period	
+		-for dial-up, don't test connect 
 		'til after dail-up
 		-for dial-up, don't alert if
 		user terminated connection
@@ -254,8 +293,8 @@
 
 #ifdef USE_THREADS
 
-	{"--status_interval",		1, {get_status_interval_handler, NULL,0}, "<#> - seconds [30..864000] interval at which to check online status.  defaults to 600"},
-	{"--status_offline_interval",	1, {get_status_offline_interval_handler, NULL,0}, "<#> - seconds [0..864000] interval at which to check online status, after offline\n          detected.  defaults to 15"},
+	{"--status_interval",		1,	{get_status_interval_handler, NULL,0},"<#> - seconds [30..864000] interval at which to check online status.  defaults to 600"},
+	{"--status_offline_interval",	1,	{get_status_offline_interval_handler, NULL,0},"<#> - seconds [0..864000] interval at which to check online status, after offline detected.  defaults to 15"},
 #endif
 #endif
         {"--svr_ip_param",		3,	{get_ip_param_handler, NULL,2}, "<custom DDNS server ip name parameter> - custom DDNS url parameter for ip address, e.g., myip."},
@@ -264,11 +303,10 @@
 	{"--svr_ip_in_rsp",		0,	{get_ip_in_svr_rsp_handler, NULL,0}, "flag that custom DDNS server returns your ip address on update success.  Defaults to false."},
 	{"--svr_add_cfg",		1,	{get_svr_add_cfg_handler, NULL,0}, "<full path, file name> - additional servers file.  Default search for servers_additional.cfg\n          in ./extra, /etc, or /etc/inadyn-mt."},
 	{"--if",			1,	{get_if_name_handler, NULL,0}, "<net interface name> - network interface.  Defaults to system configured default."},
-	{"--addr_pref",			1,	{get_addr_pref_handler, NULL,0}, "<pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp> -  ipv6 address preference for\n          DDNS update.  Defaults to pub."},
-	{NULL,				0,{0, NULL,0},"" }
+        {"--addr_pref",			1,	{get_addr_pref_handler, NULL,0},"<pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp> -  ipv6 address preference for DDNS update.  Defaults to pub."},
+        {NULL,				0,	{0,NULL,0},"" }
     };
 
-
 void print_help_page(void)
 {
 	printf("\n\n\n" \
@@ -281,7 +319,7 @@
 	       "\t-for dyndns.org system: \n" \
 	       "\t\tinadyn-mt -u username -p password -a my.registrated.name \n" \
 	       "\t-for freedns.afraid.org:\n" \
-	       "\t\tinadyn-mt --dyndns_system default@freedns.afraid.org -a my.registrated.name, hash -a anothername, hash2\n" \
+	       "\t\t inadyn-mt --dyndns_system default@freedns.afraid.org -a my.registrated.name,hash -a anothername,hash2\n" \
 	       "\t\t 'hash' is extracted from the grab url batch file that is downloaded from freedns.afraid.org\n\n" \
 	       "Parameters:\n");
 
@@ -299,53 +337,72 @@
 	printf("\n\n\n");
 }
 
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->p_pidfilename = (char *) safe_malloc(strlen(p_cmd->argv[current_nr]) + 1);
+	if (p_self->p_pidfilename == NULL)
+	{
+		return  RC_OUT_OF_MEMORY;
+	}
+	strcpy(p_self->p_pidfilename, p_cmd->argv[current_nr]);
+	return RC_OK;
+}
+
 static char *do_arg_to_val(struct EXP_MAPPING *p_mapping,char *identifier)
 {
-        char    *p_ret=safe_malloc(strlen("unknown identifier")+1);
+	char    		*p_ret=safe_malloc(strlen("unknown identifier")+1);
+	int			alias_index=p_mapping->alias_index;
+	DYNDNS_INFO_TYPE	info=p_mapping->p_dyndns->info[p_mapping->server_index];
 
-        strcpy(p_ret,"unknown identifier");
+	strcpy(p_ret,"unknown identifier");
 
 	if (!(identifier))
 
 		return p_ret;
 
-        DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "mapping from identifier, %s, in do_arg_to_val...\n",identifier));
+	DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "mapping from identifier, %s, in do_arg_to_val...\n",identifier));
 
-        if (!(strcmp(identifier,"IP_ADDR"))) {
+	if (!(strcmp(identifier,"IP_ADDR"))) {
 
-		if (!(p_mapping->p_dyndns->info.my_ip_address.name[ip_store]))
+		if (!(info.i_face.my_ip_address.name[ip_store]))
 
 			return p_ret;
 
-		if (!(strlen(p_mapping->p_dyndns->info.my_ip_address.name[ip_store])))
+		if (!(strlen(info.i_face.my_ip_address.name[ip_store])))
 
 			return p_ret;
 
-                p_ret=safe_realloc(p_ret,strlen(p_mapping->p_dyndns->info.my_ip_address.name[ip_store])+1);
-                strcpy(p_ret,p_mapping->p_dyndns->info.my_ip_address.name[ip_store]);
-        }
+		p_ret=safe_realloc(p_ret,strlen(info.i_face.my_ip_address.name[ip_store])+1);
+		strcpy(p_ret,info.i_face.my_ip_address.name[ip_store]);
+	}
 
-        if (!(strcmp(identifier,"ALIAS"))) {
+	if (!(strcmp(identifier,"ALIAS"))) {
 
-		if (!(p_mapping->alias_index<p_mapping->p_dyndns->alias_info.count))
+		if (!(alias_index<info.alias_info.count))
 
 			return p_ret;
 
-                p_ret=safe_realloc(p_ret,strlen(p_mapping->p_dyndns->alias_info.names[p_mapping->alias_index].name)+1);
-       	        strcpy(p_ret,p_mapping->p_dyndns->alias_info.names[p_mapping->alias_index].name);
-        }
+		p_ret=safe_realloc(p_ret,strlen(info.alias_info.names[alias_index].name)+1);
+		strcpy(p_ret,info.alias_info.names[alias_index].name);
+	}
 
 	return p_ret;
 }
 
 char *arg_to_val(void *p_context,char *token)
 {
-        struct EXP_MAPPING      *p_mapping=p_context;
-        char                    *s_ret=do_arg_to_val(p_mapping,token);
+	struct EXP_MAPPING      *p_mapping=p_context;
+	char                    *s_ret=do_arg_to_val(p_mapping,token);
 
-        DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "mapping value from identifier %s, to value %s, in arg_to_val...\n",token,s_ret));
+	DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "mapping value from identifier %s, to value %s, in arg_to_val...\n",token,s_ret));
 
-        return s_ret;
+	return s_ret;
 }
 
 static RC_TYPE help_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
@@ -363,11 +420,14 @@
 static RC_TYPE wildcard_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-	if (p_self == NULL)
-	{
+
+	if (p_self == NULL) {
+
 		return RC_INVALID_POINTER;
 	}
-	p_self->wildcard = TRUE;
+
+	p_self->info[server_index].wildcard = TRUE;
+
 	return RC_OK;
 }
 
@@ -431,7 +491,7 @@
 		p_self->dbg.p_logfilename=NULL;
 	}
 
-
+	
 #ifndef _WIN32
 
 	p_self->dbg.p_logfilename=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
@@ -441,32 +501,32 @@
 
 	if (create_file2(p_cmd->argv[current_nr]))
 
-		nt_console_name2(&p_self->dbg.p_logfilename,p_cmd->argv[current_nr]);
+		nt_console_name2(&p_self->dbg.p_logfilename,p_cmd->argv[current_nr]);	
 #endif
 
-
+	
 	return RC_OK;
 }
 
 static RC_TYPE get_username_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
-
+	
 
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_username) {
+	if (p_self->info[server_index].credentials.my_username) {
 
-		free(p_self->info.credentials.my_username);
+		free(p_self->info[server_index].credentials.my_username);
 	}
 
 	/*user*/
-	p_self->info.credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
-	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].credentials.my_username, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -479,14 +539,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_password) {
+	if (p_self->info[server_index].credentials.my_password) {
 
-		free(p_self->info.credentials.my_password);
+		free(p_self->info[server_index].credentials.my_password);
 	}
 
 	/*password*/
-	p_self->info.credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
-	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
+	p_self->info[server_index].credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	strcpy(p_self->info[server_index].credentials.my_password, (p_cmd->argv[current_nr]));
 	return RC_OK;
 }
 
@@ -512,7 +572,8 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->alias_info.count-p_self->alias_info.count_dual >= DYNDNS_MAX_ALIAS_NUMBER) {
+	if (p_self->info[server_index].alias_info.count-p_self->info[server_index].alias_info.count_dual 
+			>= DYNDNS_MAX_ALIAS_NUMBER) {
 
 		return RC_DYNDNS_TOO_MANY_ALIASES;
 	}
@@ -522,42 +583,46 @@
 
 	if (p_hash)	{
 
-		if (p_self->alias_info.hashes[p_self->alias_info.count].str)
+		if (p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str)
 
-			free(p_self->alias_info.hashes[p_self->alias_info.count].str);
+			free(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str);
 
 		/*allocate and copy hash len minus comma*/
-		p_self->alias_info.hashes[p_self->alias_info.count].str=safe_malloc(strlen(p_hash));
-		strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str,(p_hash+1));
+		p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str
+			=safe_malloc(strlen(p_hash));
+
+		strcpy(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str,(p_hash+1));
 
 		alias_len=strlen(p_hash);
 	}
+	
+	if (p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name)
 
-	if (p_self->alias_info.names[p_self->alias_info.count].name)
-
-		free(p_self->alias_info.names[p_self->alias_info.count].name);
+		free(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name);
 
 	alias_len=strlen(p_cmd->argv[current_nr])-alias_len;
 
 	/*alias*/
-	p_self->alias_info.names[p_self->alias_info.count].name=safe_malloc(alias_len+1);
-	strncpy(p_self->alias_info.names[p_self->alias_info.count].name,p_cmd->argv[current_nr],alias_len);
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name
+		=safe_malloc(alias_len+1);
+	strncpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name,
+		p_cmd->argv[current_nr],alias_len);
 
 	/*default to letting ip server determine update type*/
-	strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,"auto");
+	strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,"auto");
 
-	p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_store;
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_store;
 
 	/*IPv/type*/
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -570,7 +635,7 @@
 			}
 			else {
 
-				strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,ip_ver_str);
+				strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,ip_ver_str);
 
 				if (strcmp(ip_ver_str,"auto")) {
 
@@ -578,24 +643,24 @@
 
 						if (strcmp(ip_ver_str,"ip4"))
 
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_6;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_6;
 						else
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_4;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_4;
 					}
 				}
 
-				p_self->info.is_update_ip4=(p_self->info.is_update_ip4 || strstr(ip_ver_str,"ip4")
+				p_self->info[server_index].is_update_ip4=(p_self->info[server_index].is_update_ip4 || strstr(ip_ver_str,"ip4")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_ip6=(p_self->info.is_update_ip6 || strstr(ip_ver_str,"ip6")
+				p_self->info[server_index].is_update_ip6=(p_self->info[server_index].is_update_ip6 || strstr(ip_ver_str,"ip6")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_auto=(p_self->info.is_update_auto || strstr(ip_ver_str,"auto"));
+				p_self->info[server_index].is_update_auto=(p_self->info[server_index].is_update_auto || strstr(ip_ver_str,"auto"));
 			}
 		}
 	}
 
-	p_self->alias_info.count++;
+	p_self->info[server_index].alias_info.count++;
 
 
 	return RC_OK;
@@ -604,19 +669,19 @@
 static RC_TYPE get_alias_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT	*p_self=(DYN_DNS_CLIENT *) p_context;
-	char		ip_ver_str[8];
+	char		ip_ver_str[8]={'\0'};
 	RC_TYPE		rc=RC_OK;
 
 
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -625,7 +690,7 @@
 #else
 			if (_snprintf(ip_ver_str, 8, "%s", p_cmd->argv[current_nr+1]) < 0)	{
 #endif
-
+				
 				return RC_DYNDNS_INVALID_OPTION;
 			}
 		}
@@ -643,7 +708,7 @@
 
 		if ((RC_OK==(rc=do_get_alias_handler(p_cmd,current_nr,p_context,"ip6"))))
 
-			p_self->alias_info.count_dual++;
+			p_self->info[server_index].alias_info.count_dual++;
 	}
 
 	return rc;
@@ -719,57 +784,74 @@
 /** Returns the svr name and port if the format is :
  * name[:port] url.
  */
-static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_INFO_TYPE *info)
+static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_SERVER_NAME *info)
 {
 	RC_TYPE	rc;
-	int	port=-1;
-
-	if (info==NULL)
+    	int	port = -1;
 
+	if (info == NULL)
+	{
 		return RC_INVALID_POINTER;
+	}
 
 	/*user*/
-	info->ip_server_name.port=HTTP_DEFAULT_PORT;
+    info->port = HTTP_DEFAULT_PORT;
 
-	rc=get_name_and_port(p_cmd->argv[current_nr], &info->ip_server_name.name[ip_store], &port);
+    rc = get_name_and_port(p_cmd->argv[current_nr], &info->name, &port);
 
-	if (rc==RC_OK && port!=-1)
+    if (rc == RC_OK && port != -1)
+    {
+        info->port = port;
+    }        
 
-		info->ip_server_name.port=port;
+    if (info->url)
 
-	if (!(rc==RC_OK))
+		free(info->url);
 
-		return rc;
+    info->url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
 
-	if (!(current_nr+1<p_cmd->argc))
+    strcpy(info->url, p_cmd->argv[current_nr + 1]);
 
-		return RC_OK;
+    return rc;
+}
 
-        if (0==(strncmp(p_cmd->argv[current_nr+1],"-",1)))
+static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
 
-		return RC_OK;
+    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info[server_index].ip_server_name));
+}
 
-        if (info->ip_server_url)
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	RC_TYPE		rc;
+	DYN_DNS_CLIENT	*p_self=(DYN_DNS_CLIENT *) p_context;
+	int		i;
 
-                free(info->ip_server_url);
 
-	info->ip_server_url=safe_malloc(strlen(p_cmd->argv[current_nr+1])+1);
+    if ((RC_OK==(rc=set_url_param(p_cmd,current_nr,&p_self->ip_server_name_global)))) {
 
-	strcpy(info->ip_server_url, p_cmd->argv[current_nr+1]);
+		for (i=0;i<MAX_DNS_SERVER;i++) {
 
-	return RC_OK;
-}
+			if (!(p_self->info[i].ip_server_name.name)) {
 
-static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
-{
+				p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->ip_server_name_global.name)+1);
+				strcpy(p_self->info[i].ip_server_name.name,p_self->ip_server_name_global.name);
 
-    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info));
+				p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->ip_server_name_global.url)+1);
+				strcpy(p_self->info[i].ip_server_name.url,p_self->ip_server_name_global.url);
+
+				p_self->info[i].ip_server_name.port=p_self->ip_server_name_global.port;
+			}
+		}
+	}
+
+	return rc;
 }
 
 static RC_TYPE get_ip_server_host_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-	DYN_DNS_CLIENT	*p_self=p_context;
+	DYN_DNS_CLIENT  *p_self=p_context;
 
 
 	if (p_self==NULL)
@@ -784,8 +866,8 @@
 
 		return RC_DYNDNS_INVALID_OPTION;
 
-	p_self->info.ip_server_host=safe_realloc(p_self->info.ip_server_host,strlen(p_cmd->argv[current_nr]+1));
-	strcpy(p_self->info.ip_server_host,p_cmd->argv[current_nr]);
+	p_self->info[server_index].ip_server_host=safe_realloc(p_self->info[server_index].ip_server_host,strlen(p_cmd->argv[current_nr]+1));
+	strcpy(p_self->info[server_index].ip_server_host,p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -796,49 +878,93 @@
     return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info_online_status));
 }
 
+static char dns_system_index_of(char *p_key,DYN_DNS_CLIENT *p_self)
+{
+
+	char i;
+
+	DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "Searching among servers, for key:  %s, in dns_system_index_of...\n",p_key));
+
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "Compairing index:  %s, in dns_system_index_of...\n",p_self->info[i].p_dns_system->p_key));
+
+		if (0==strcmp(p_key,p_self->info[i].p_dns_system->p_key)) {
+
+			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Returning index of already entered server:  %s, in dns_system_index_of...\n",p_self->info[i].p_dns_system->p_key));
+
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static DYNDNS_SYSTEM *get_dns_system(char *src_key)
+{
+	DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
+
+
+	for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it) {
+
+		if (strcmp(it->system.p_key, src_key) == 0) {
+
+			return &it->system;
+		}
+	}
+
+	return NULL;
+}
+
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
 	RC_TYPE		rc;
 	int		port = -1;
 
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
 
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.dyndns_server_name.name[ip_store], &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.dyndns_server_name.port = port;
+	p_self->info[server_index].dyndns_server_name.port = HTTP_DEFAULT_PORT;
+	rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].dyndns_server_name.name, &port);
+	if (rc==RC_OK) {
+
+		if (port != -1) {
+
+			p_self->info[server_index].dyndns_server_name.port = port;
+		}
     }
+
+
 	return rc;
 }
 
 RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
-	DYN_DNS_CLIENT		*p_self = (DYN_DNS_CLIENT *) p_context;
-
-
+	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.dyndns_server_url)
+	if (p_self->info[server_index].dyndns_server_name.url)
 
-		free(p_self->info.dyndns_server_url);
+		free(p_self->info[server_index].dyndns_server_name.url);
 
-	p_self->info.dyndns_server_url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
-	strcpy(p_self->info.dyndns_server_url,p_cmd->argv[current_nr]);
+	p_self->info[server_index].dyndns_server_name.url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+
+	/*url*/
+	strcpy(p_self->info[server_index].dyndns_server_name.url, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
 
 static RC_TYPE get_dns_server_host_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
-	DYN_DNS_CLIENT	*p_self=p_context;
+	DYN_DNS_CLIENT  *p_self=p_context;
 
 
 	if (p_self==NULL)
@@ -852,9 +978,9 @@
 	if (!(strncmp(p_cmd->argv[current_nr],"-",1)))
 
 		return RC_DYNDNS_INVALID_OPTION;
-	
-	p_self->info.dyndns_server_host=safe_realloc(p_self->info.dyndns_server_host,strlen(p_cmd->argv[current_nr]+1));
-	strcpy(p_self->info.dyndns_server_host,p_cmd->argv[current_nr]);
+
+	p_self->info[server_index].dyndns_server_host=safe_realloc(p_self->info[server_index].dyndns_server_host,strlen(p_cmd->argv[current_nr]+1));
+	strcpy(p_self->info[server_index].dyndns_server_host,p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -864,8 +990,8 @@
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
-	RC_TYPE		rc;
-	int		port = -1;
+    	RC_TYPE		rc;
+    	int		port = -1;
 
 	if (p_self == NULL)
 	{
@@ -873,11 +999,11 @@
 	}
 
 	/*user*/
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.proxy_server_name.name[ip_store], &port);
+    p_self->info[server_index].proxy_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].proxy_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.proxy_server_name.port = port;
+        p_self->info[server_index].proxy_server_name.port = port;
     }
 	return rc;
 }
@@ -968,11 +1094,11 @@
 	}
 
 	if ((adjust < DYNDNS_MIN_FORCED_UPDATE_ADJUST) || (adjust > DYNDNS_MAX_FORCED_UPDATE_ADJUST)) {
-
+		
 		DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "forced_update_adjust, %d, not [%d..%d]...\n",adjust,DYNDNS_MIN_FORCED_UPDATE_ADJUST,DYNDNS_MAX_FORCED_UPDATE_ADJUST));
 
 		return RC_DYNDNS_INVALID_OPTION;
-	}
+	} 
 	else {
 
 		p_self->forced_update_adjust=(float) adjust*-1;
@@ -980,7 +1106,7 @@
 		p_self->forced_update_adjust=p_self->forced_update_adjust/10+.5f;
 	}
 
-
+	
 	return RC_OK;
 }
 
@@ -1068,49 +1194,16 @@
 static RC_TYPE set_file_param(char **dest, char *dir,char *file_name)
 {
 	RC_TYPE	rc=RC_FILE_IO_OPEN_ERROR;
-	char	*src_ptr=NULL;
+	char	*src_ptr=NULL;	
 	int	is_file_exists;
-	char	*p_cwd=NULL;
-	int	p_trailing;
-
-
-	if (dir[0]==DIR_DELIM_STR[0] || dir[1]==':') {
-
-		p_cwd=dir;
-	}
-	else {
-
-		p_cwd=cross_platform_cwd(&p_cwd);
-
-		if (dir[0]=='.' && !(dir[1]=='.'))
-
-			dir++;
-
-		if(dir[0]==DIR_DELIM_STR[0])
-
-			dir++;
-	}
-
-	p_trailing=strlen(dir)-1;
-
-	if (p_trailing>=0)
-
-		if (dir[p_trailing]==DIR_DELIM_STR[0])
-
-			dir[p_trailing]='\0';
+	int	slen;
+	
 
-	if (p_cwd==dir || !(strlen(dir))) {
+	slen=strlen(dir)+strlen(DIR_DELIM_STR)+strlen(file_name)+1;
 
-		src_ptr=safe_malloc(strlen(p_cwd)+strlen(file_name)+2);
+	src_ptr=safe_malloc(slen);
 
-		sprintf(src_ptr,"%s" DIR_DELIM_STR "%s",p_cwd,file_name);
-	}
-	else {
-
-		src_ptr=safe_malloc(strlen(p_cwd)+strlen(dir)+strlen(file_name)+3);
-
-		sprintf(src_ptr,"%s" DIR_DELIM_STR "%s" DIR_DELIM_STR "%s",p_cwd,dir,file_name);
-	}
+	sprintf(src_ptr,"%s" DIR_DELIM_STR "%s",dir,file_name);
 
 	if (!(is_file_exists=is_file(src_ptr)))
 
@@ -1124,19 +1217,15 @@
 
 		nt_console_name2(dest,src_ptr);
 #else
+		*dest=safe_malloc(slen);
 
-		*dest=safe_malloc(strlen(src_ptr)+1);
-
-		strcpy(*dest,src_ptr);
+		sprintf(*dest, "%s" DIR_DELIM_STR "%s",dir,file_name);
 #endif
-
+		
 	}
 
 	free(src_ptr);
 
-	if (!(p_cwd==dir))
-
-		free(p_cwd);
 
 	return rc;
 }
@@ -1145,6 +1234,7 @@
 {
 
 	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
+
 	char		*ip_cache=NULL;
 	char		*time_cache=NULL;
 
@@ -1158,7 +1248,7 @@
 
 		if (p_self->ip_cache) {
 
-			free(p_self->ip_cache);
+			free(p_self->ip_cache);			
 		}
 
 		p_self->ip_cache=ip_cache;
@@ -1174,9 +1264,29 @@
 		p_self->time_cache=time_cache;
 	}
 
+
 	return RC_OK;
 }
 
+DYNDNS_SYSTEM *create_custom_ddns(DYNDNS_SYSTEM *p_dns_system,char *p_key)
+{
+	DYNDNS_SYSTEM	*p_ret=safe_malloc(sizeof(DYNDNS_SYSTEM));
+
+	memcpy(p_ret,p_dns_system,sizeof(DYNDNS_SYSTEM));
+
+	p_ret->p_specific_data=NULL;
+
+	p_ret->p_key=safe_malloc(strlen(p_key)+1);
+	strcpy(p_ret->p_key,p_key);
+
+	/*these are presently const, but who knows -
+	  we definately need them null*/
+	p_ret->p_dyndns_server_name=NULL;
+	p_ret->p_dyndns_server_url=NULL;
+
+	return p_ret;
+}
+
 static char *read_line(FILE *f_handle)
 {
 	char	c;
@@ -1304,67 +1414,150 @@
 	return RC_OK;
 }
 
-static DYNDNS_SYSTEM *get_dns_system(char *src_key)
+/*input is a space delimited string of server parameter options,
+  the first of which must be the unique (relative to system hard
+  coded servers, and those in system additional servers file)
+  identifier for the given server.
+
+  return the unique server identifiier.
+*/
+static char *svr_add_cfg_key(char **s_ret,char *p_server)
 {
-	DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
+	char	*p_delim;
+	char	*in_str=safe_malloc(strlen(p_server)+1);
 
+	strcpy(in_str,p_server);
 
-	for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it) {
+	p_delim=strpbrk(in_str," ");
 
-		if (strcmp(it->system.p_key, src_key) == 0) {
+	*(p_delim)='\0';
 
-			return &it->system;
-		}
-	}
+	*s_ret=safe_malloc(p_delim-in_str+1);
 
-	return NULL;
+	strcpy(*s_ret,in_str);
+
+	free(in_str);
+
+	return *s_ret;
 }
 
 /**
-    Searches the DYNDNS system by the argument.
-    Input is like: system@server.name
-    system=statdns|custom|dyndns|default
-    server name = dyndns.org | freedns.afraid.org
-    The result is a pointer in the table of DNS systems.
+	Searches the DYNDNS system by the argument.
+	Input is like: system@server.name
+	system=statdns|custom|dyndns|default
+	server name = dyndns.org | freedns.afraid.org
+	The result is a pointer in the table of DNS systems.
+
+	Argument may also be searched within additional
+	preconfigured servers program file.  So if miss
+	on DYNDNS system, check the file.
+
+	custom@blah_blah (USER_DEFINED_SERVER) may appear
+	more than once in multi-services version of the
+	program.
+
+	Both custom, and additional servers are allocated
+	based on DYNDNS system custom server type.  Ad-
+	ditional type are qualified relative to pre-
+	configuration defined in file.
 */
 static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
-	DYNDNS_SYSTEM *p_dns_system = NULL;
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-
+	DYNDNS_SYSTEM	*p_dns_system;
+	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
+	char		*p_server=NULL;
+	int		ndx;
 
 	if (p_self == NULL)
 
 		return RC_INVALID_POINTER;
 
-	if (NULL==(p_dns_system=get_dns_system(p_cmd->argv[current_nr]))) {
+	/*new or existing server name can appear anywhere in config or command line.  if new, increment the global
+	  index but, first check if it's already in list of servers and set index (or counter) correspondingly
+	  to it.  all "info" (server info structure) related handlers will use this index (or counter) until
+	  a new, or other existing name appears.*/
 
-		char	*p_server;
+	if (!(p_self->srv_cnt<MAX_DNS_SERVER))
 
+		return RC_DYNDNS_TOO_MANY_SERVERS;
+
+	/*search system table first, then additional preconfigured servers file*/
+	if (!(p_dns_system=get_dns_system(p_cmd->argv[current_nr]))) {
 
 		if (!(p_self->servers_additional))
 
 			return RC_DYNDNS_INVALID_OPTION;
 
+		/*p_server gets a string like:  default@server.com --cmd_option param --cmd_option2 param...*/
 		if (!(p_server=get_additional_server(p_self->servers_additional,p_cmd->argv[current_nr])))
 
 			return RC_DYNDNS_INVALID_OPTION;
+	}
 
+	if (p_dns_system) {
+
+		/*note if more than one 'custom' no way to 'recall' it in config
+		  so we create a new one every time with dyndns.c system table
+		  custom entry as template.
+		*/
+		if ((0==strcmp(USER_DEFINED_SERVER,p_dns_system->p_key))) {
+
+			p_dns_system=create_custom_ddns(p_dns_system,USER_DEFINED_SERVER);
+
+			server_index=p_self->srv_cnt;
+
+			p_self->srv_cnt++;
+		}
 		else {
+			if (!(-1==(ndx=dns_system_index_of(p_dns_system->p_key,p_self))))
 
-			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Additional server:  %s\n",p_server));
+				server_index=ndx;
+			else {
+				server_index=p_self->srv_cnt;
 
-			add_server_params_to_cmd(p_cmd,p_server,current_nr);
+				p_self->srv_cnt++;
+			}
+		}
+	}
+	else {
+		if (p_server) {
+
+			char	*p_key;
+
+			if (!(-1==(ndx=dns_system_index_of(svr_add_cfg_key(&p_key,p_server),p_self)))) {
 
-			free(p_server);
+				DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "found existing configured server:  %s\n",p_key));
+
+				server_index=ndx;
+
+				p_dns_system=p_self->info[server_index].p_dns_system;
+			}
+			else {
+				DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Additional server:  %s\n",p_server));
 
-			p_dns_system=get_dns_system(USER_DEFINED_SERVER);
+				add_server_params_to_cmd(p_cmd,p_server,current_nr);
+
+				free(p_server);
+
+				p_dns_system=create_custom_ddns(get_dns_system(USER_DEFINED_SERVER),p_key);
+
+				server_index=p_self->srv_cnt;
+
+				p_self->srv_cnt++;
+			}
+
+			free(p_key);
 		}
 	}
 
-	p_self->info.p_dns_system = p_dns_system;
-	strcpy(p_self->ipv6_priv_ext.addr_pref,"pub");
-	p_self->ipv6_priv_ext.flags=IPV6_PREFER_SRC_PUBLIC;
+	p_self->info[server_index].p_dns_system = p_dns_system;
+
+	/*if not reconfiguring already entered server*/
+	if (!(strlen(p_self->info[server_index].ipv6_priv_ext.addr_pref))) {
+
+		strcpy(p_self->info[server_index].ipv6_priv_ext.addr_pref,"pub");
+		p_self->info[server_index].ipv6_priv_ext.flags=IPV6_PREFER_SRC_PUBLIC;
+	}
 
 	return RC_OK;
 }
@@ -1372,9 +1565,9 @@
 static RC_TYPE get_debug_level_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-	#define ASCII_ZERO     48
+	#define ASCII_ZERO	48
 
-	int                    dwLevel=0;
+	int	dwLevel=0;
 
 
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -1491,6 +1684,7 @@
 	if (p_self==NULL)
 
 		return RC_INVALID_POINTER;
+	
 
 	p_self->retry_pending_off=(!(p_self->retry_pending_off));
 
@@ -1505,11 +1699,11 @@
 
 
 	/*
-	use harded coded defaults if have
+	use harded coded defaults if have 
 	--lang_file parameter with no option --
 	otherwise, use option indicated language
-	strings file, and if not there, program
-	will automatically use locale indicated
+	strings file, and if not there, program 
+	will automatically use locale indicated 
 	language strings file, defaulting to
 	en.lng if locale indicated file not
 	present.
@@ -1711,13 +1905,13 @@
 static RC_TYPE get_config_rsp_params_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-	return do_get_rsp_params_handler(p_cmd,current_nr,p_context,&((DYN_DNS_CLIENT*) p_context)->rsp_config_codes);
+	return do_get_rsp_params_handler(p_cmd,current_nr,p_context,&((DYN_DNS_CLIENT*) p_context)->info[server_index].rsp_config_codes);
 }
 
 static RC_TYPE get_success_rsp_params_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-	return do_get_rsp_params_handler(p_cmd,current_nr,p_context,&((DYN_DNS_CLIENT*) p_context)->rsp_success_codes);
+	return do_get_rsp_params_handler(p_cmd,current_nr,p_context,&((DYN_DNS_CLIENT*) p_context)->info[server_index].rsp_success_codes);
 }
 
 static RC_TYPE get_ip_param_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
@@ -1737,22 +1931,22 @@
 
 		return RC_DYNDNS_INVALID_OPTION;
 
-	p_self->ip_param=safe_realloc(p_self->ip_param,strlen(p_cmd->argv[current_nr])+1);
-	strcpy(p_self->ip_param,p_cmd->argv[current_nr]);
+	p_self->info[server_index].ip_param=safe_realloc(p_self->info[server_index].ip_param,strlen(p_cmd->argv[current_nr])+1);
+	strcpy(p_self->info[server_index].ip_param,p_cmd->argv[current_nr]);
 
 	if (current_nr+1<p_cmd->argc) {
 
 		if (strncmp(p_cmd->argv[current_nr+1],"-",1)) {
 
-			p_self->id_param=safe_realloc(p_self->id_param,strlen(p_cmd->argv[current_nr+1])+1);
-			strcpy(p_self->id_param,p_cmd->argv[current_nr+1]);
+			p_self->info[server_index].id_param=safe_realloc(p_self->info[server_index].id_param,strlen(p_cmd->argv[current_nr+1])+1);
+			strcpy(p_self->info[server_index].id_param,p_cmd->argv[current_nr+1]);
 
 			if (current_nr+2<p_cmd->argc) {
 
 				if (strncmp(p_cmd->argv[current_nr+2],"-",1)) {
 
-					p_self->pw_param=safe_realloc(p_self->pw_param,strlen(p_cmd->argv[current_nr+2])+1);
-					strcpy(p_self->pw_param,p_cmd->argv[current_nr+2]);
+					p_self->info[server_index].pw_param=safe_realloc(p_self->info[server_index].pw_param,strlen(p_cmd->argv[current_nr+2])+1);
+					strcpy(p_self->info[server_index].pw_param,p_cmd->argv[current_nr+2]);
 				}
 			}
 		}
@@ -1769,7 +1963,7 @@
 
 		return RC_INVALID_POINTER;
 
-	p_self->is_ip_in_svr_rsp=1;
+	p_self->info[server_index].is_ip_in_svr_rsp=1;
 
 	return RC_OK;
 }
@@ -1815,9 +2009,9 @@
 
 		return RC_DYNDNS_INVALID_OPTION;
 
-	p_self->if_name=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].if_name=safe_realloc(p_self->info[server_index].if_name,strlen(p_cmd->argv[current_nr])+1);
 
-	strcpy(p_self->if_name,p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].if_name,p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -1913,7 +2107,7 @@
 
 		return RC_DYNDNS_INVALID_OPTION;
 
-	return set_priv_ext(p_cmd->argv[current_nr],&p_self->ipv6_priv_ext);
+	return set_priv_ext(p_cmd->argv[current_nr],&p_self->info[server_index].ipv6_priv_ext);
 }
 
 #ifdef USE_SNDFILE
@@ -2076,7 +2270,7 @@
 /*
 	Allow wave attenuation to -120db
 
-	User interface gain [-10..10] (present values of related constants)
+	User interface gain [-10..10] (present values of related constants) 
 	is translated to [-20..0]
 
 	This in turn is translated according to waveout.c's WAVE_DECIBEL_STEP
@@ -2101,12 +2295,12 @@
 		gain=DYNDNS_DEFAULT_WAVE_GAIN;
 
 	else
-		gain=DYNDNS_MIN_WAVE_GAIN+gain;
+		gain=DYNDNS_MIN_WAVE_GAIN+gain;		
 
 
 	p_self->wave_gain=gain*DYNDNS_DECIBEL_STEP/WAVE_DECIBEL_STEP;
 
-
+	
 	return RC_OK;
 }
 
@@ -2181,7 +2375,7 @@
 
 		DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "status_interval, %s, not [%i..%i]...\n",p_cmd->argv[current_nr],
 					DYNDNS_MIN_STATUS_INTERVAL,DYNDNS_MAX_STATUS_INTERVAL));
-
+		
 
 		return RC_DYNDNS_INVALID_OPTION;
 	}
@@ -2231,13 +2425,11 @@
 static RC_TYPE push_in_buffer(char* p_src, int src_len, char *p_buffer, int* p_act_len, int max_len)
 {
 	if (*p_act_len + src_len > max_len)
-
+	{
 		return RC_FILE_IO_OUT_OF_BUFFER;
-
+	}
 	memcpy(p_buffer + *p_act_len,p_src, src_len);
-
 	*p_act_len += src_len;
-
 	return RC_OK;
 }
 
@@ -2254,7 +2446,7 @@
 
 typedef struct
 {
-	FILE		*p_file;
+	FILE 		*p_file;
 	PARSER_STATE	state;
 } OPTION_FILE_PARSER;
 
@@ -2481,10 +2673,10 @@
 */
 static RC_TYPE parser_utf_8_read_option(OPTION_FILE_PARSER *p_cfg, char *p_buffer, int maxlen)
 {
-	RC_TYPE rc = RC_OK;
-	BOOL parse_end = FALSE;
-	int count = 0;
-	char c_buff[7];
+	RC_TYPE	rc = RC_OK;
+	BOOL	parse_end = FALSE;
+	int	count = 0;
+	char	c_buff[7];
 
 
 	*p_buffer = 0;
@@ -2537,11 +2729,11 @@
 		- add data to buffer
 		- do not forget a 0 at the end
  * States:
- * NEW_LINE - wait here until some option. Add '--' if not already there
- * SPACE - between options. Like NEW_LINE but no additions
- * DATA - real data. Stop on space.
- * COMMENT - everything beginning with # until EOLine
- * ESCAPE - everything that is otherwise (incl. spaces). Next char is raw copied.
+ * NEW_LINE	- wait here until some option. Add '--' if not already there
+ * SPACE	- between options. Like NEW_LINE but no additions
+ * DATA		- real data. Stop on space.
+ * COMMENT	- everything beginning with # until EOLine
+ * ESCAPE	- everything that is otherwise (incl. spaces). Next char is raw copied.
 */
 static RC_TYPE parser_utf_16_read_option(OPTION_FILE_PARSER *p_cfg, char *p_buffer, int maxlen)
 {
@@ -2621,12 +2813,12 @@
 	const int		buffer_size = DYNDNS_SERVER_NAME_LENGTH;
 	OPTION_FILE_PARSER	parser;
 
-	UTF_PARSE_FUNC		parse_func=parser_utf_8_read_option;
+	UTF_PARSE_FUNC parse_func=parser_utf_8_read_option;
 
 #ifdef _WIN32
 
-	int		is_bom=0;	/*win32 utf byte order mark?*/
-	int		is_bom_8=0;
+	int	is_bom=0;	/*win32 utf byte order mark?*/
+	int	is_bom_8=0;
 #endif
 
 
@@ -2695,7 +2887,7 @@
 
 		while(!feof(p_file))
 		{
-			rc = parse_func(&parser,p_tmp_buffer, buffer_size-1);
+			rc = parse_func(&parser,p_tmp_buffer, buffer_size);
 
 			if (rc != RC_OK)
 			{
@@ -2806,7 +2998,7 @@
 	return rc;
 }
 
-static RC_TYPE do_get_default_infile_config(char *in_file,DYN_DNS_CLIENT *p_self,CMD_OPTION_ERR_HANDLER_FUNC pf_err_handler)
+RC_TYPE do_get_default_infile_config(char *in_file,DYN_DNS_CLIENT *p_self,CMD_OPTION_ERR_HANDLER_FUNC pf_err_handler)
 {
 
 	RC_TYPE	rc = RC_OK;
@@ -2843,42 +3035,27 @@
 
 /*
 	try inadyn-mt config file first
-	and if it's not there, try mt
+	and if it's not there, try mt 
 	config file
 */
-static RC_TYPE get_default_infile_config(DYN_DNS_CLIENT *p_self,CMD_OPTION_ERR_HANDLER_FUNC pf_err_handler)
+RC_TYPE get_default_infile_config(DYN_DNS_CLIENT *p_self,CMD_OPTION_ERR_HANDLER_FUNC pf_err_handler)
 {
 
-	RC_TYPE rc=RC_FILE_IO_OPEN_ERROR;
+	RC_TYPE rc = RC_OK;
 
-/*
-	char	root[6];
-	char	path[]=".";
-	char	input_file[]="inadyn-mt.conf";
-	char	*dest;
 
-this bit is good for Windows 'cause no default config file location, but not sure
-the most graceful way to integrate - in general, windows, or otherwise.  though it
-might seem helpful, it could be more interference than not.
+	rc = do_get_default_infile_config(DYNDNS_MT_DEFAULT_CONFIG_FILE,p_self,pf_err_handler);
 
-	if ((dest=searchedProgFile(NULL,&dest,get_root(root),path,3,input_file))) {
+	if (rc==RC_FILE_IO_OPEN_ERROR) {
 
-		rc=do_get_default_infile_config(dest,p_self,pf_err_handler);
+		rc = do_get_default_infile_config(DYNDNS_MT_DEFAULT_CONFIG_FILE_OLD,p_self,pf_err_handler);
 
-		free(dest);
-	}
-*/
+		if (rc==RC_FILE_IO_OPEN_ERROR) {
 
-#ifndef _WIN32
-
-	if (rc==RC_FILE_IO_OPEN_ERROR)
-
-		if (RC_FILE_IO_OPEN_ERROR==(rc=do_get_default_infile_config(DYNDNS_MT_DEFAULT_CONFIG_FILE,p_self,pf_err_handler)))
-
-			if (RC_FILE_IO_OPEN_ERROR==(rc=do_get_default_infile_config(DYNDNS_MT_DEFAULT_CONFIG_FILE_OLD,p_self,pf_err_handler)))
+			rc = do_get_default_infile_config(DYNDNS_DEFAULT_CONFIG_FILE,p_self,pf_err_handler);
+		}
+	}
 
-				rc=do_get_default_infile_config(DYNDNS_DEFAULT_CONFIG_FILE,p_self,pf_err_handler);
-#endif
 
 	return rc;
 }
@@ -2903,7 +3080,6 @@
 	RC_TYPE	rc = RC_OK;
 	FILE	*fp;
 	char	cached_time[80];
-	int	len;
 
 
 	do
@@ -2933,77 +3109,80 @@
 			break;
 		}
 
-
-		/*ip server*/
-		if (!(p_self->info.ip_server_name.name[ip_store]))
+		/*settings that may change due to cmd line options*/
 		{
-			p_self->info.ip_server_name.name[ip_store]=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_name)+1);
-			strcpy(p_self->info.ip_server_name.name[ip_store], p_self->info.p_dns_system->p_ip_server_name);
-		}
+			int	len=0;
+			int	i;
 
-		/*this presently cannot not happen (see command table, option params number and option params default number)
-		  unless there was no ip_server_name as well, but that may change, so this this remains as a condition separate
-		  from ip_server_name check.
-		*/
-		if (!(p_self->info.ip_server_url))
-		{
-			p_self->info.ip_server_url=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_url)+1);
-			strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);
-		}
+			if (!(p_self->info_online_status.name))
+			{
+				p_self->info_online_status.name=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
+				strcpy(p_self->info_online_status.name,DYNDNS_MY_ONLINE_CHECK);
 
-		if (!(p_self->info_online_status.ip_server_name.name[ip_store]))
-		{
-			p_self->info_online_status.ip_server_name.name[ip_store]=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
-			strcpy(p_self->info_online_status.ip_server_name.name[ip_store],DYNDNS_MY_ONLINE_CHECK);
+				p_self->info_online_status.url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
+				strcpy(p_self->info_online_status.url,DYNDNS_MY_ONLINE_CHECK_URL);
 
-			p_self->info_online_status.ip_server_name.port=80;
-		}
+				p_self->info_online_status.port=80;
+			}
 
-		if (!(p_self->info_online_status.ip_server_url))
-		{
-                       p_self->info_online_status.ip_server_url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
-                       strcpy(p_self->info_online_status.ip_server_url,DYNDNS_MY_ONLINE_CHECK_URL);
-		}
+			if (!(p_self->srv_cnt))
 
-		/*dyndns server*/
-		if (!(p_self->info.dyndns_server_name.name[ip_store]))
-		{
-			if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_name)))) {
+				p_self->srv_cnt=1; /*default server set in main*/
 
-				p_self->info.dyndns_server_name.name[ip_store]=safe_malloc(len+1);
-        			strcpy(p_self->info.dyndns_server_name.name[ip_store], p_self->info.p_dns_system->p_dyndns_server_name);
-			}
-		}
+			for (i=0;i<p_self->srv_cnt;i++) {
 
-		if (!(p_self->info.dyndns_server_url))
-		{
-			if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_url)))) {
+    				/*dyndns server*/
+				if (!(p_self->info[i].dyndns_server_name.name))
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_name)))) {
 
-				p_self->info.dyndns_server_url=safe_malloc(len+1);
-      				strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
-			}
-		}
+						p_self->info[i].dyndns_server_name.name=safe_malloc(len+1);
+        					strcpy(p_self->info[i].dyndns_server_name.name, p_self->info[i].p_dns_system->p_dyndns_server_name);
+					}
+				}
 
+ 				/*ip server*/
+				if (!(p_self->info[i].ip_server_name.name))
+				{
+					p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_name)+1);
+					strcpy(p_self->info[i].ip_server_name.name, p_self->info[i].p_dns_system->p_ip_server_name);
 
-		/*check if the neccessary params have been provided*/
-		if ((!(p_self->info.dyndns_server_name.name[ip_store])) || (!(p_self->info.ip_server_name.name[ip_store]))
-			|| (!(p_self->info.dyndns_server_url)) || (p_self->alias_info.count == 0))
+					p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_url)+1);
+					strcpy(p_self->info[i].ip_server_name.url, p_self->info[i].p_dns_system->p_ip_server_url);
+				}
 
-		{
-			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
-			break;
-		}
 
-		if (!(p_self->info.dyndns_server_host)) {
+				if (!(p_self->info[i].dyndns_server_name.url))
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_url)))) {
+
+						p_self->info[i].dyndns_server_name.url=safe_malloc(len+1);
+    						strcpy(p_self->info[i].dyndns_server_name.url, p_self->info[i].p_dns_system->p_dyndns_server_url);
+					}
+				}
+
+				if (!(p_self->info[i].dyndns_server_host)) {
+
+					p_self->info[i].dyndns_server_host=safe_malloc(strlen(p_self->info[i].dyndns_server_name.name)+1);
+
+					strcpy(p_self->info[i].dyndns_server_host,p_self->info[i].dyndns_server_name.name);
+				}
 
-			p_self->info.dyndns_server_host=safe_malloc(strlen(p_self->info.dyndns_server_name.name[ip_store])+1);
-			strcpy(p_self->info.dyndns_server_host,p_self->info.dyndns_server_name.name[ip_store]);
+				if (!(p_self->info[i].ip_server_host)) {
+
+					p_self->info[i].ip_server_host=safe_malloc(strlen(p_self->info[i].ip_server_name.name)+1);
+					strcpy(p_self->info[i].ip_server_host,p_self->info[i].ip_server_name.name);
+				}
+			}
 		}
 
-		if (!(p_self->info.ip_server_host)) {
+		/*check if the neccessary params have been provided*/
+		if ((!(p_self->info[0].dyndns_server_name.name)) || (!(p_self->info[0].ip_server_name.name))
+			|| (!(p_self->info[0].dyndns_server_name.url)) || (p_self->info[0].alias_info.count == 0))
 
-			p_self->info.ip_server_host=safe_malloc(strlen(p_self->info.ip_server_name.name[ip_store])+1);
-			strcpy(p_self->info.ip_server_host,p_self->info.ip_server_name.name[ip_store]);
+		{
+			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
+			break;
 		}
 
 		/*forced update*/
@@ -3030,7 +3209,6 @@
 
 					p_self->forced_update_period_sec-=dif;
 
-
 					/*unsigned wrap around?*/
 
 					if (fup_store<p_self->forced_update_period_sec)
