This patch has been created from AVM's opensrc packages for 7490.06.20 and 7272.06.10-labor
by applying to the kernel sources they contain the following command:

    diff -durN --no-dereference -x fusiv_src -x flash_update 7490.06.20 7272.06.10-labor > this.patch

Note: we intentionally apply this patch to the 3490.06.20 sources (and not to the 7490.06.20)
      to keep minor avm_nand driver updates 3490.06.20 contains compared to the 7490.06.20 package.

--- linux-2.6.32/.config
+++ linux-2.6.32/.config
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.32.61
-# Wed Jun  4 14:01:11 2014
+# Wed Mar 12 16:23:08 2014
 #
 CONFIG_MIPS=y
 
@@ -64,22 +64,33 @@
 # CONFIG_AMAZON_SE is not set
 # CONFIG_AR9 is not set
 CONFIG_IFX_CLOCK_CHANGE=y
-CONFIG_VR9=y
+# CONFIG_VR9 is not set
+CONFIG_DMA_PACKET_ARBITRATION_ENABLED=y
+# CONFIG_HN1 is not set
+CONFIG_AR10=y
+
+#
+# AR10 Boards
+#
+# CONFIG_AR10_REF_BOARD is not set
+CONFIG_AR10_AVM_FRITZ_BOX=y
 
 #
-# VR9 Boards
+# AR10 Boards Family
 #
-# CONFIG_VR9_REF_BOARD is not set
-CONFIG_VR9_AVM_FRITZ_BOX=y
-# CONFIG_LTQ_RT288 is not set
+CONFIG_AR10_EVAL_BOARD=y
+# CONFIG_AR10_FAMILY_BOARD_1_1 is not set
+# CONFIG_AR10_FAMILY_BOARD_1_2 is not set
+# CONFIG_AR10_FAMILY_BOARD_2 is not set
+
+#
+# Emulator Support
+#
+# CONFIG_USE_EMULATOR is not set
 
 #
 # Extra Configuration
 #
-CONFIG_DMA_PACKET_ARBITRATION_ENABLED=y
-# CONFIG_GRX_25M_MODEL is not set
-# CONFIG_HN1 is not set
-# CONFIG_AR10 is not set
 CONFIG_AR9VR9_C55_MEMORY_SIZE=0x0
 CONFIG_AR9VR9_C55_MEMORY_START=0x0
 # CONFIG_AR9VR9_AVM_CPUFREQ is not set
@@ -183,7 +194,7 @@
 CONFIG_SYS_SUPPORTS_MULTITHREADING=y
 CONFIG_MIPS_MT_FPAFF=y
 # CONFIG_MIPS_VPE_LOADER is not set
-CONFIG_PERFCTRS=y
+# CONFIG_PERFCTRS is not set
 CONFIG_MTSCHED=y
 # CONFIG_MIPS_MT_SMTC_IM_BACKSTOP is not set
 # CONFIG_MIPS_MT_SMTC_IRQAFF is not set
@@ -210,7 +221,7 @@
 CONFIG_HAVE_MLOCKED_PAGE_BIT=y
 CONFIG_KSM=y
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-# CONFIG_AVM_LOW_MEMORY_STRATEGY is not set
+CONFIG_AVM_LOW_MEMORY_STRATEGY=y
 CONFIG_SMP=y
 CONFIG_SMP_UP=y
 CONFIG_SYS_SUPPORTS_SMP=y
@@ -228,7 +239,6 @@
 # CONFIG_HZ_1000 is not set
 # CONFIG_HZ_1024 is not set
 CONFIG_SYS_SUPPORTS_100HZ=y
-CONFIG_SYS_SUPPORTS_250HZ=y
 CONFIG_SYS_SUPPORTS_1000HZ=y
 CONFIG_HZ=100
 CONFIG_PREEMPT_NONE=y
@@ -370,9 +380,14 @@
 # CONFIG_IFX_PCIE_PHY_25MHZ_MODE is not set
 # CONFIG_IFX_PCIE_PHY_100MHZ_MODE is not set
 CONFIG_IFX_PCIE_1ST_CORE=y
-CONFIG_IFX_PCIE_HW_SWAP=y
-# CONFIG_IFX_PCIE_INBOUND_NO_HW_SWAP is not set
-# CONFIG_IFX_PCIE_VR9_A11_HRST is not set
+# CONFIG_IFX_PCIE_HW_SWAP is not set
+CONFIG_IFX_PCIE_INBOUND_NO_HW_SWAP=y
+CONFIG_IFX_PCIE_2ND_CORE=y
+# CONFIG_IFX_PCIE1_HW_SWAP is not set
+CONFIG_IFX_PCIE1_INBOUND_NO_HW_SWAP=y
+CONFIG_IFX_PCIE_3RD_CORE=y
+# CONFIG_IFX_PCIE2_HW_SWAP is not set
+CONFIG_IFX_PCIE2_INBOUND_NO_HW_SWAP=y
 # CONFIG_PCIEASPM is not set
 CONFIG_ARCH_SUPPORTS_MSI=y
 # CONFIG_PCI_MSI is not set
@@ -382,7 +397,6 @@
 # CONFIG_PCI_STUB is not set
 # CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
 # CONFIG_PCI_IOV is not set
-# CONFIG_IFX_PCI is not set
 CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 # CONFIG_HOTPLUG_PCI is not set
@@ -535,8 +549,7 @@
 CONFIG_BRIDGE=y
 # CONFIG_BRIDGE_SNOOPING is not set
 # CONFIG_NET_DSA is not set
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 CONFIG_LLC=y
 # CONFIG_LLC2 is not set
@@ -633,9 +646,7 @@
 # CONFIG_DEVTMPFS is not set
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
@@ -701,7 +712,6 @@
 # CONFIG_MTD_INTEL_VR_NOR is not set
 CONFIG_MTD_PLATRAM=y
 CONFIG_MTD_PLATNOR=y
-# CONFIG_MTD_IFX_NOR is not set
 
 #
 # Self-contained MTD device drivers
@@ -739,9 +749,12 @@
 # CONFIG_MTD_ALAUDA is not set
 # CONFIG_MTD_NAND_COMPLETE_AVM is not set
 CONFIG_MTD_IFX_NAND_LATCH_ENABLE=y
-# CONFIG_MTD_IFX_NAND is not set
-CONFIG_MTD_IFX_HSNAND=y
-CONFIG_MTD_IFX_HSNAND_FLASH_SIZE=4
+CONFIG_MTD_IFX_NAND=y
+CONFIG_MTD_IFX_NAND_FLASH_SIZE=4
+# CONFIG_MTD_IFX_HSNAND is not set
+# CONFIG_MTD_IFX_MLCNAND is not set
+# CONFIG_NAND_CS0 is not set
+CONFIG_NAND_CS1=y
 # CONFIG_MTD_ONENAND is not set
 
 #
@@ -905,10 +918,12 @@
 # CONFIG_ATHRS27_PHY is not set
 # CONFIG_AR8033_PHY is not set
 CONFIG_LANTIQ_11G_PHY=y
-CONFIG_WLAN_OFFLOAD_PHY=y
+# CONFIG_WLAN_OFFLOAD_PHY is not set
 # CONFIG_NETDEV_10000 is not set
 # CONFIG_TR is not set
-# CONFIG_WLAN is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -952,8 +967,6 @@
 # CONFIG_ATM_HE is not set
 # CONFIG_ATM_SOLOS is not set
 # CONFIG_IFX_ATM is not set
-# CONFIG_IFX_PTM is not set
-# CONFIG_IFX_ADTRAN_PTM is not set
 CONFIG_IFX_ETHSW_API=y
 
 #
@@ -965,8 +978,6 @@
 # CONFIG_LTQ_STP is not set
 # CONFIG_LTQ_VLAN is not set
 # CONFIG_LTQ_WOL is not set
-# CONFIG_IFX_ETHSW_API_COC is not set
-# CONFIG_IFX_ETHSW_API_COC_PMCU is not set
 # CONFIG_GPHY_DRIVER is not set
 CONFIG_IFX_PPA_NAPI_ENABLE=y
 CONFIG_IFX_PPA=y
@@ -980,14 +991,11 @@
 CONFIG_IFX_PPA_QOS_WFQ=y
 CONFIG_IFX_PPA_QOS_RATE_SHAPING=y
 CONFIG_IFX_PPA_DATAPATH=m
-# CONFIG_IFX_PPA_A5 is not set
+CONFIG_IFX_PPA_A5=y
 # CONFIG_IFX_PPA_D5 is not set
-CONFIG_IFX_PPA_E5=y
-# CONFIG_IFX_PPE_E5_OFFCHIP_BONDING is not set
+# CONFIG_IFX_PPA_E5 is not set
 CONFIG_IFX_PPA_IPv6_ENABLE=y
-CONFIG_PTM_VECTORING=y
-# CONFIG_IFX_VECTOR_TIMER_CHECK is not set
-# CONFIG_IFX_7PORT_SWITCH is not set
+# CONFIG_PTM_VECTORING is not set
 CONFIG_IFX_ETH_FRAMEWORK=y
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
@@ -1056,7 +1064,10 @@
 #
 # Userland interfaces
 #
-# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
@@ -1108,7 +1119,6 @@
 CONFIG_SERIAL_AVM_ASC=y
 CONFIG_SERIAL_AVM_ASC_CONSOLE=y
 # CONFIG_SERIAL_IFX_ASC is not set
-# CONFIG_SERIAL_IFX_USIF_UART is not set
 CONFIG_UNIX98_PTYS=y
 # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
 CONFIG_LEGACY_PTYS=y
@@ -1158,13 +1168,13 @@
 CONFIG_IFX_PMU_POWER_GATING=y
 CONFIG_IFX_GPIO=y
 CONFIG_IFX_RCU=y
-# CONFIG_IFX_SI is not set
 # CONFIG_IFX_LEDC is not set
-CONFIG_IFX_WDT=y
-CONFIG_DSL_MEI_CPE_DRV=y
+# CONFIG_IFX_WDT is not set
+CONFIG_IFXMIPS_DSL_CPE_MEI=y
+# CONFIG_DSL_MEI_CPE_DRV is not set
 # CONFIG_IFX_PMON is not set
-# CONFIG_IFX_DCDC is not set
 CONFIG_IFX_TS=y
+# CONFIG_IFX_INA219 is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_COMPAT=y
@@ -1243,7 +1253,6 @@
 CONFIG_SPI_BITBANG=y
 CONFIG_IFX_SPI=y
 # CONFIG_IFX_SPI_DEBUG is not set
-# CONFIG_IFX_SPI_ASYNCHRONOUS is not set
 CONFIG_IFX_SPI_FLASH=y
 # CONFIG_IFX_SPI_AT45_FLASH is not set
 # CONFIG_IFX_USIF_SPI is not set
@@ -1345,8 +1354,7 @@
 # USB Host Controller Drivers
 #
 # CONFIG_USB_C67X00_HCD is not set
-CONFIG_USB_XHCI_HCD=n
-# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+# CONFIG_USB_XHCI_HCD is not set
 # CONFIG_USB_EHCI_HCD is not set
 # CONFIG_USB_OXU210HP_HCD is not set
 # CONFIG_USB_ISP116X_HCD is not set
@@ -1373,7 +1381,7 @@
 #
 # USB Device Class drivers
 #
-CONFIG_USB_ACM=n
+# CONFIG_USB_ACM is not set
 CONFIG_USB_PRINTER=n
 # CONFIG_USB_WDM is not set
 # CONFIG_USB_TMC is not set
@@ -1418,10 +1426,10 @@
 # CONFIG_USB_SERIAL_CH341 is not set
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-CONFIG_USB_SERIAL_CP210X=n
+# CONFIG_USB_SERIAL_CP210X is not set
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-CONFIG_USB_SERIAL_FTDI_SIO=n
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1793,7 +1801,7 @@
 # CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_OBJECTS is not set
 # CONFIG_DEBUG_SLAB is not set
-CONFIG_DEBUG_SLAB_DOUBLE_FREE=y
+# CONFIG_DEBUG_SLAB_DOUBLE_FREE is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
 # CONFIG_RT_MUTEX_TESTER is not set
 CONFIG_DEBUG_SPINLOCK=y
--- linux-2.6.32/drivers/net/avm_cpmac/configs/avmnet_hw_config.h
+++ linux-2.6.32/drivers/net/avm_cpmac/configs/avmnet_hw_config.h
@@ -62,6 +62,11 @@
 #include "config_HW214.h"
 #endif
 
+#if (defined(CONFIG_MACH_ATHEROS) && defined(CONFIG_MACH_QCA953x)) || (defined(CONFIG_ATH79) && defined(CONFIG_SOC_QCA953X))
+#include "config_HW215.h"
+#include "config_HW216.h"
+#endif
+
 #ifndef NUM_ENTITY
 #if defined(NUM_ENTITY)
 #  undef NUM_ENTITY
@@ -307,6 +312,23 @@
         .avm_devices = avmnet_hw214_avm_devices
     },
 #endif /*--- #if defined(CONFIG_MACH_QCA955x) ---*/
+#if (defined(CONFIG_MACH_ATHEROS) && defined(CONFIG_MACH_QCA953x)) || (defined(CONFIG_ATH79) && defined(CONFIG_SOC_QCA953X))
+    {
+        // 310 II
+        .hw_id = 215,
+        .config = &avmnet_HW215,
+        .nr_avm_devices = NUM_ENTITY( avmnet_hw215_avm_devices ),
+        .avm_devices = avmnet_hw215_avm_devices
+    },
+    {
+        // Repeater AC 1160
+        .hw_id = 216,
+        .config = &avmnet_HW216,
+        .nr_avm_devices = NUM_ENTITY( avmnet_hw216_avm_devices ),
+        .avm_devices = avmnet_hw216_avm_devices
+    },
+
+#endif /*--- #if (defined(CONFIG_MACH_ATHEROS) && defined(CONFIG_MACH_QCA953x)) || (defined(CONFIG_ATH79) && defined(CONFIG_SOC_QCA953X)) ---*/
 };
 
 #endif
--- /dev/null
+++ linux-2.6.32/drivers/net/avm_cpmac/configs/config_HW215.h
@@ -0,0 +1,127 @@
+#if !defined(__AVM_NET_CFG_ATHEROS_HW215)
+#define __AVM_NET_CFG_ATHEROS_HW215
+
+#include <avmnet_module.h>
+#include <avmnet_config.h>
+#include "../switch/atheros/atheros_mac.h"
+#include "../phy/avmnet_ar803x.h"
+#include "../phy/avmnet_ar8326.h"
+
+#include <atheros.h>
+
+extern avmnet_module_t hw215_gmac1, hw215_ath_switch, hw215_module_eth0;
+
+avmnet_device_t avmnet_hw215_avm_device_0 ____cacheline_aligned =
+{
+   .device            = NULL,
+   .device_name       = "eth0",
+   .external_port_no  = 0,
+   .device_ops        = {
+                          /*--- .ndo_get_stats        = athr_gmac_get_stats, ---*/
+                          .ndo_open             = avmnet_netdev_open,
+                          .ndo_stop             = avmnet_netdev_stop,
+                          /*--- .ndo_do_ioctl         = athr_gmac_do_ioctl, ---*/
+                          .ndo_tx_timeout       = athr_gmac_tx_timeout,
+                          .ndo_start_xmit       = athr_gmac_hard_start
+                        },
+   .mac_module        = &hw215_gmac1,
+   .vlanID            = 1, // GMAC1, SW MAC 1
+   .sizeof_priv       = sizeof(avmnet_netdev_priv_t),
+   .device_setup      = athr_gmac_setup_eth,
+   .device_setup_priv = athr_gmac_setup_eth_priv,
+};
+
+avmnet_device_t *avmnet_hw215_avm_devices[] = {
+    &avmnet_hw215_avm_device_0
+}; 
+
+avmnet_module_t avmnet_HW215 ____cacheline_aligned =
+{
+    .name           = "athmac",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata       = { .mac = { .flags = 0 }},
+
+    .init           = athmac_init,
+    .setup          = athmac_setup,
+    .exit           = athmac_exit,
+    
+    .parent         = NULL,
+    .num_children   = 1,
+    .children       = { &hw215_gmac1 }
+};
+
+avmnet_module_t hw215_gmac1 ____cacheline_aligned =
+{
+    .name           = "gmac1",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata.mac   = {  .flags = AVMNET_CONFIG_FLAG_BASEADDR
+                                | AVMNET_CONFIG_FLAG_IRQ
+                                | AVMNET_CONFIG_FLAG_SWITCHPORT,
+                         .base_addr = ATH_GE1_BASE, 
+                         .irq = ATH_CPU_IRQ_GE1, 
+                         .mac_nr = 1
+                      },
+
+    .init           = athmac_gmac_init,
+    .setup          = athmac_gmac_setup,
+    .exit           = athmac_gmac_exit,
+
+    .reg_read       = athmac_reg_read,
+    .reg_write      = athmac_reg_write,
+    .lock           = athmac_lock,
+    .unlock         = athmac_unlock,
+    .status_changed = athmac_status_changed,
+    .poll           = athmac_poll,
+    .set_status     = athgmac_set_status,
+    .setup_irq      = athmac_setup_irq,
+
+    .parent         = &avmnet_HW215,
+    .num_children   = 1,
+    .children       = { &hw215_ath_switch },
+};
+
+avmnet_module_t hw215_ath_switch ____cacheline_aligned =
+{
+    .name           = "ar8326",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata       = { .swi = { .flags = AVMNET_CONFIG_FLAG_IRQ, .irq = ATH_MISC_IRQ_ENET_LINK }},
+
+    .init           = avmnet_ar8326_init,
+    .setup          = avmnet_ar8326_setup,
+    .exit           = avmnet_ar8326_exit,
+
+    .reg_read       = avmnet_s27_rd_phy,
+    .reg_write      = avmnet_s27_wr_phy,
+    .lock           = avmnet_s27_lock,
+    .unlock         = avmnet_s27_unlock,
+    .status_changed = avmnet_ar8326_status_changed,
+    .poll           = avmnet_ar8326_status_poll,
+    .set_status     = avmnet_ar8326_set_status,
+    .setup_irq      = avmnet_ar8326_setup_interrupt,
+
+    .parent         = &hw215_gmac1,
+    .num_children   = 1,
+    .children       = { &hw215_module_eth0 }
+};
+
+avmnet_module_t hw215_module_eth0 ____cacheline_aligned =
+{
+    .name           = "ar803x0",
+    .device_id      = &avmnet_hw215_avm_device_0,
+    .type           = avmnet_modtype_phy,
+    .priv           = NULL,
+    .initdata.phy   = { .flags = AVMNET_CONFIG_FLAG_MDIOADDR | AVMNET_CONFIG_FLAG_INTERNAL, .mdio_addr = 0 },
+
+     AR803X_STDFUNCS,
+    
+    .ethtool_ops    = AR803X_ETHOPS,
+
+    .parent         = &hw215_ath_switch,
+    .num_children   = 0,
+    .children       = {}
+};
+
+#endif
--- /dev/null
+++ linux-2.6.32/drivers/net/avm_cpmac/configs/config_HW216.h
@@ -0,0 +1,127 @@
+#if !defined(__AVM_NET_CFG_ATHEROS_HW216)
+#define __AVM_NET_CFG_ATHEROS_HW216
+
+#include <avmnet_module.h>
+#include <avmnet_config.h>
+#include "../switch/atheros/atheros_mac.h"
+#include "../phy/avmnet_ar803x.h"
+#include "../phy/avmnet_ar8326.h"
+
+#include <atheros.h>
+
+extern avmnet_module_t hw216_gmac1, hw216_ath_switch, hw216_module_eth0;
+
+avmnet_device_t avmnet_hw216_avm_device_0 ____cacheline_aligned =
+{
+   .device            = NULL,
+   .device_name       = "eth0",
+   .external_port_no  = 0,
+   .device_ops        = {
+                          /*--- .ndo_get_stats        = athr_gmac_get_stats, ---*/
+                          .ndo_open             = avmnet_netdev_open,
+                          .ndo_stop             = avmnet_netdev_stop,
+                          /*--- .ndo_do_ioctl         = athr_gmac_do_ioctl, ---*/
+                          .ndo_tx_timeout       = athr_gmac_tx_timeout,
+                          .ndo_start_xmit       = athr_gmac_hard_start
+                        },
+   .mac_module        = &hw216_gmac1,
+   .vlanID            = 1, // GMAC1, SW MAC 1
+   .sizeof_priv       = sizeof(avmnet_netdev_priv_t),
+   .device_setup      = athr_gmac_setup_eth,
+   .device_setup_priv = athr_gmac_setup_eth_priv,
+};
+
+avmnet_device_t *avmnet_hw216_avm_devices[] = {
+    &avmnet_hw216_avm_device_0
+}; 
+
+avmnet_module_t avmnet_HW216 ____cacheline_aligned =
+{
+    .name           = "athmac",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata       = { .mac = { .flags = 0 }},
+
+    .init           = athmac_init,
+    .setup          = athmac_setup,
+    .exit           = athmac_exit,
+    
+    .parent         = NULL,
+    .num_children   = 1,
+    .children       = { &hw216_gmac1 }
+};
+
+avmnet_module_t hw216_gmac1 ____cacheline_aligned =
+{
+    .name           = "gmac1",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata.mac   = {  .flags = AVMNET_CONFIG_FLAG_BASEADDR
+                                | AVMNET_CONFIG_FLAG_IRQ
+                                | AVMNET_CONFIG_FLAG_SWITCHPORT,
+                         .base_addr = ATH_GE1_BASE, 
+                         .irq = ATH_CPU_IRQ_GE1, 
+                         .mac_nr = 1
+                      },
+
+    .init           = athmac_gmac_init,
+    .setup          = athmac_gmac_setup,
+    .exit           = athmac_gmac_exit,
+
+    .reg_read       = athmac_reg_read,
+    .reg_write      = athmac_reg_write,
+    .lock           = athmac_lock,
+    .unlock         = athmac_unlock,
+    .status_changed = athmac_status_changed,
+    .poll           = athmac_poll,
+    .set_status     = athgmac_set_status,
+    .setup_irq      = athmac_setup_irq,
+
+    .parent         = &avmnet_HW216,
+    .num_children   = 1,
+    .children       = { &hw216_ath_switch },
+};
+
+avmnet_module_t hw216_ath_switch ____cacheline_aligned =
+{
+    .name           = "ar8326",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata       = { .swi = { .flags = AVMNET_CONFIG_FLAG_IRQ, .irq = ATH_MISC_IRQ_ENET_LINK }},
+
+    .init           = avmnet_ar8326_init,
+    .setup          = avmnet_ar8326_setup,
+    .exit           = avmnet_ar8326_exit,
+
+    .reg_read       = avmnet_s27_rd_phy,
+    .reg_write      = avmnet_s27_wr_phy,
+    .lock           = avmnet_s27_lock,
+    .unlock         = avmnet_s27_unlock,
+    .status_changed = avmnet_ar8326_status_changed,
+    .poll           = avmnet_ar8326_status_poll,
+    .set_status     = avmnet_ar8326_set_status,
+    .setup_irq      = avmnet_ar8326_setup_interrupt,
+
+    .parent         = &hw216_gmac1,
+    .num_children   = 1,
+    .children       = { &hw216_module_eth0 }
+};
+
+avmnet_module_t hw216_module_eth0 ____cacheline_aligned =
+{
+    .name           = "ar803x0",
+    .device_id      = &avmnet_hw216_avm_device_0,
+    .type           = avmnet_modtype_phy,
+    .priv           = NULL,
+    .initdata.phy   = { .flags = AVMNET_CONFIG_FLAG_MDIOADDR | AVMNET_CONFIG_FLAG_INTERNAL, .mdio_addr = 0 },
+
+     AR803X_STDFUNCS,
+    
+    .ethtool_ops    = AR803X_ETHOPS,
+
+    .parent         = &hw216_ath_switch,
+    .num_children   = 0,
+    .children       = {}
+};
+
+#endif
--- linux-2.6.32/drivers/net/avm_cpmac/phy/avmnet_ar8326.c
+++ linux-2.6.32/drivers/net/avm_cpmac/phy/avmnet_ar8326.c
@@ -414,7 +414,7 @@
     value = avmnet_athrs27_reg_read(this, S27_OPMODE_REG0);
     avmnet_athrs27_reg_write(this, S27_OPMODE_REG0, value | S27_MAC0_MAC_GMII_EN);  /* Set GMII mode */
 
-    if (soc_is_ar934x()) {
+    if (soc_is_ar934x() || soc_is_qca9531()) {
         value = avmnet_athrs27_reg_read(this, S27_FLD_MASK_REG);
         // send unknown uni-, broad- and multicast frames to CPU port
         avmnet_athrs27_reg_write(this, S27_FLD_MASK_REG, value | ((1<<25) | (1<<16) | 0x1));
--- linux-2.6.32/drivers/net/avm_cpmac/phy/avmnet_ar8326.h
+++ linux-2.6.32/drivers/net/avm_cpmac/phy/avmnet_ar8326.h
@@ -4,6 +4,7 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 #define soc_is_ar934x   is_ar934x
 #define soc_is_qca955x  is_qca955x
+#define soc_is_qca9531  is_qca9531
 #define MISC_BIT_ENET_LINK RST_MISC_INTERRUPT_MASK_S26_MAC_INT_MASK_LSB
 #endif
 
--- linux-2.6.32/drivers/net/avm_cpmac/switch/atheros/atheros_gmac.c
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/atheros/atheros_gmac.c
@@ -1690,7 +1690,7 @@
     }
 
 #if ! defined(CONFIG_MACH_AR724x) && ! defined(CONFIG_SOC_AR724X)
-    if (soc_is_ar934x() || soc_is_qca955x()) {
+    if (soc_is_ar934x() || soc_is_qca955x() || soc_is_qca9531()) {
         ath_reg_rmw_set(SWITCH_CLOCK_SPARE_ADDRESS, (1 << 6));      /*--- MDIO_CLK = 100MHz ---*/
     }
 #endif
--- linux-2.6.32/drivers/net/avm_cpmac/switch/atheros/atheros_mac.h
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/atheros/atheros_mac.h
@@ -27,6 +27,7 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 #define soc_is_ar934x   is_ar934x
 #define soc_is_qca955x  is_qca955x
+#define soc_is_qca9531  is_qca9531
 #endif
 
 #define GMAC_MAX_ETH_DEVS 6
--- linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/ar10/ifxmips_ppa_datapath_ar10_a5.c
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/ar10/ifxmips_ppa_datapath_ar10_a5.c
@@ -1660,20 +1660,17 @@
 	ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0,
 			"reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned",
 			reg_desc.dataptr);
-	skb_to_free = get_skb_pointer(reg_desc.dataptr);
-	dev_kfree_skb_any(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 	put_skb_to_dbg_pool(skb);
 
     /*  detach from protocol    */
     skb_to_free = skb;
-    if( (skb = skb_break_away_from_protocol(skb)) == NULL) {
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
         skb = skb_to_free;
 		ret = -ENOMEM;
 		goto ALLOC_SKB_TX_FAIL;
     }
 
-    dev_kfree_skb_any(skb_to_free);
-
     put_skb_to_dbg_pool(skb);
 #if defined(DEBUG_MIRROR_PROC) && DEBUG_MIRROR_PROC
 	if (g_mirror_netdev != NULL) {
@@ -1805,7 +1802,6 @@
 	unsigned long sys_flag;
 	volatile struct tx_descriptor *desc;
 	struct tx_descriptor reg_desc;
-	struct sk_buff *skb_to_free;
 
 	if (((uni_cell_header->pti == ATM_PTI_SEGF5
 			|| uni_cell_header->pti == ATM_PTI_E2EF5)
@@ -1860,8 +1856,7 @@
 	ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0,
 			"reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned",
 			reg_desc.dataptr);
-	skb_to_free = get_skb_pointer(reg_desc.dataptr);
-	dev_kfree_skb_any(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 	put_skb_to_dbg_pool(skb);
 
 	/*  setup descriptor    */
@@ -2154,17 +2149,15 @@
 
     /*  free previous skb   */
     ASSERT((reg_desc.dataptr & 31) == 0, "reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned", reg_desc.dataptr);
-    skb_to_free = get_skb_pointer(reg_desc.dataptr);
-    dev_kfree_skb_any(skb_to_free);
+    free_skb_clear_dataptr(&reg_desc);
 
     /*  detach from protocol    */
     skb_to_free = skb;
-    if( (skb = skb_break_away_from_protocol(skb)) == NULL) {
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
         skb = skb_to_free;
 		goto ALLOC_SKB_TX_FAIL;
     }
 
-    dev_kfree_skb_any(skb_to_free);
     put_skb_to_dbg_pool(skb);
 
 #if defined(DEBUG_MIRROR_PROC) && DEBUG_MIRROR_PROC
@@ -3502,7 +3495,6 @@
         volatile struct tx_descriptor *desc =
                 &CPU_TO_WAN_SWAP_DESC_BASE[g_cpu_to_wan_swap_desc_pos];
         struct tx_descriptor reg_desc = { 0 };
-        struct sk_buff *skb_to_free;
 
         dbg("CPU_TO_WAN_SWAP_SIG");
         while (desc->own == 0) {
@@ -3519,9 +3511,7 @@
                 g_cpu_to_wan_swap_desc_pos = 0;
 
             /*  free previous skb   */
-            skb_to_free = get_skb_pointer(desc->dataptr);
-            if (skb_to_free != NULL)
-                dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(desc);
             put_skb_to_dbg_pool(new_skb);
 
             /*  update descriptor   */
@@ -3740,7 +3730,6 @@
     unsigned long sys_flag;
     volatile struct tx_descriptor *desc;
     struct tx_descriptor reg_desc;
-    struct sk_buff *skb_to_free;
     int byteoff;
     int conn;
 
@@ -3843,8 +3832,7 @@
     else
         dma_alignment_atm_bad_count++;
 
-    skb_to_free = get_skb_pointer(reg_desc.dataptr);
-    dev_kfree_skb_any(skb_to_free);
+    free_skb_clear_dataptr(&reg_desc);
     put_skb_to_dbg_pool(skb);
 
     /*  update descriptor   */
@@ -5555,10 +5543,14 @@
 
 static INLINE void free_dma(void) {
     volatile struct tx_descriptor *p;
-    struct sk_buff *skb_to_free;
     unsigned int i;
 
     printk(KERN_ERR "[%s] g_eth_wan_mode = %d, g_wanqos_en=%d\n", __func__, g_eth_wan_mode, g_wanqos_en );
+
+	dma_device_unregister(g_dma_device_ppe);
+	dma_device_release(g_dma_device_ppe);
+	g_dma_device_ppe = NULL;
+
     if ( g_eth_wan_mode == 0 || g_wanqos_en )
     {
         // can be cleared here (CPU -> Shared-Mem)
@@ -5566,8 +5558,7 @@
         p = (volatile struct tx_descriptor *)CPU_TO_WAN_TX_DESC_BASE;
         for ( i = 0; i < CPU_TO_WAN_TX_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+        	free_skb_clear_dataptr(p);
             p++;
         }
 
@@ -5576,8 +5567,7 @@
         p = (volatile struct tx_descriptor *)DSL_WAN_TX_DESC_BASE(0);
         for ( i = 0; i < WAN_TX_DESC_NUM_TOTAL; i++ )
         {
-            skb_to_free = get_skb_pointer(g_eth_wan_mode == 0 ? p->dataptr << 2 : p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+        	free_skb_clear_dataptr_shift(p, ((g_eth_wan_mode == 0) ? 2 : 0));
             p++;
         }
     }
@@ -5593,8 +5583,7 @@
         p = (volatile struct tx_descriptor *)CPU_TO_WAN_SWAP_DESC_BASE;
         for ( i = 0; i < CPU_TO_WAN_SWAP_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+        	free_skb_clear_dataptr(p);
             p++;
         }
     }
@@ -5607,8 +5596,7 @@
         p = (volatile struct tx_descriptor *)WAN_RX_DESC_BASE(0);
         for ( i = 0; i < WAN_RX_DESC_NUM(0); i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+        	free_skb_clear_dataptr(p);
             p++;
         }
 
@@ -5617,8 +5605,7 @@
         p = (volatile struct tx_descriptor *)WAN_RX_DESC_BASE(1);
         for ( i = 0; i < WAN_RX_DESC_NUM(1); i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr << 2);
-            dev_kfree_skb_any(skb_to_free);
+        	free_skb_clear_dataptr_shift(p, 2);
             p++;
         }
     }
@@ -5633,8 +5620,7 @@
         if ( g_eth_wan_mode != 0 && !g_wanqos_en )
             break;
 #endif
-        skb_to_free = get_skb_pointer(p->dataptr);
-        dev_kfree_skb_any(skb_to_free);
+        free_skb_clear_dataptr(p);
         p++;
     }
 
@@ -5644,8 +5630,7 @@
     p = (volatile struct tx_descriptor *)DMA_RX_CH2_DESC_BASE;
     for ( i = 0; i < DMA_RX_CH2_DESC_NUM; i++ )
     {
-        skb_to_free = get_skb_pointer(p->dataptr);
-        dev_kfree_skb_any(skb_to_free);
+    	free_skb_clear_dataptr(p);
         p++;
     }
 #endif
@@ -5658,15 +5643,11 @@
         p = (volatile struct tx_descriptor *)DMA_TX_CH1_DESC_BASE;
         for ( i = 0; i < DMA_TX_CH1_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
     }
 
-	dma_device_unregister(g_dma_device_ppe);
-	dma_device_release(g_dma_device_ppe);
-	g_dma_device_ppe = NULL;
 
 #if defined(DEBUG_SKB_SWAP) && DEBUG_SKB_SWAP
     for ( i = 0; i < NUM_ENTITY(g_dbg_skb_swap_pool); i++ )
--- linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/ar10/ifxmips_ppa_hal_ar10_a5.h
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/ar10/ifxmips_ppa_hal_ar10_a5.h
@@ -314,7 +314,9 @@
 /*
  *  Helper Macro
  */
-#define NUM_ENTITY(x)                           (sizeof(x) / sizeof(*(x)))
+#ifndef NUM_ENTITY
+#define NUM_ENTITY ARRAY_SIZE
+#endif
 #define BITSIZEOF_UINT32                        (sizeof(uint32_t) * 8)
 #define BITSIZEOF_UINT16                        (sizeof(uint16_t) * 8)
 
--- linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/ar9/ifxmips_ppa_datapath_ar9_a5.c
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/ar9/ifxmips_ppa_datapath_ar9_a5.c
@@ -240,8 +240,6 @@
 
 #define ENABLE_LED_FRAMEWORK                    0
 
-#define ENABLE_NO_DELAY_ATM_SKB_FREE            1
-
 #define ENABLE_CONFIGURABLE_DSL_VLAN            1
 
 #if defined(CONFIG_IFX_PPA_DIRECTPATH_TX_QUEUE_SIZE)
@@ -1410,16 +1408,12 @@
 static INLINE struct sk_buff *alloc_skb_rx(void);
 static struct sk_buff *alloc_skb_tx_aligned(struct sk_buff *, int);
 static INLINE struct sk_buff *alloc_skb_tx(int);
-static struct sk_buff* skb_break_away_from_protocol(struct sk_buff *);
 static INLINE void __get_skb_from_dbg_pool(struct sk_buff *, const char *, unsigned int);
 #define get_skb_from_dbg_pool(skb)  __get_skb_from_dbg_pool(skb, __FUNCTION__, __LINE__)
-static INLINE struct sk_buff *__get_skb_pointer(unsigned int, const char *, unsigned int);
-#define get_skb_pointer(dataptr)    __get_skb_pointer(dataptr, __FUNCTION__, __LINE__)
 static INLINE void __put_skb_to_dbg_pool(struct sk_buff *, const char *, unsigned int);
 #define put_skb_to_dbg_pool(skb)    __put_skb_to_dbg_pool(skb, __FUNCTION__, __LINE__)
 static struct sk_buff* atm_alloc_tx(struct atm_vcc *, unsigned int);
 static INLINE void atm_free_tx_skb_vcc(struct sk_buff *skb);
-static INLINE void atm_free_tx_skb_vcc_delayed(struct sk_buff *skb);
 
 /*
  *  Mailbox handler
@@ -2183,11 +2177,9 @@
         return -EBUSY;
     }
 
-#if defined(ENABLE_NO_DELAY_ATM_SKB_FREE) && ENABLE_NO_DELAY_ATM_SKB_FREE
     skb_get(skb);
     atm_free_tx_skb_vcc(skb);
     ATM_SKB(skb)->vcc = NULL;
-#endif
 
     conn = find_vcc(vcc);
     if ( conn < 0 )
@@ -2328,10 +2320,6 @@
         /*  write back to physical memory   */
         dma_cache_wback((u32)skb->data - byteoff - sizeof(struct sk_buff *), skb->len + byteoff + sizeof(struct sk_buff *));
 #endif
-#if !defined(ENABLE_NO_DELAY_ATM_SKB_FREE) || !ENABLE_NO_DELAY_ATM_SKB_FREE
-        /*  before putting in TX queue, do something to prevent atm_may_send fail   */
-        atomic_sub(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);
-#endif
 		dma_alignment_atm_good_count++;
 #if defined(CONFIG_AVMNET_DEBUG) 
 		if ( g_dbg_datapath & DBG_ENABLE_MASK_DEBUG_ALIGNMENT )
@@ -2358,13 +2346,15 @@
 
     /*  free previous skb   */
     ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0, "reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned", reg_desc.dataptr);
-    skb_to_free = get_skb_pointer(reg_desc.dataptr);
-    atm_free_tx_skb_vcc_delayed(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 
     /*  detach from protocol    */
     skb_to_free = skb;
-    skb = skb_break_away_from_protocol(skb);
-    dev_kfree_skb_any(skb_to_free);
+
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
+        skb = skb_to_free;
+		goto ALLOC_SKB_TX_FAIL;
+    }
 
     put_skb_to_dbg_pool(skb);
 
@@ -2440,11 +2430,7 @@
     if ( vcc->qos.aal == ATM_AAL5 )
         g_atm_priv_data.wtx_drop_pdu++;
     UPDATE_VCC_STAT(conn, tx_dropped, 1);
-#if defined(ENABLE_NO_DELAY_ATM_SKB_FREE) && ENABLE_NO_DELAY_ATM_SKB_FREE
     atm_free_tx_skb_vcc(skb);
-#else
-    atm_free_tx_skb_vcc_delayed(skb);
-#endif
     return ret;
 }
 
@@ -2510,8 +2496,8 @@
 
     /*  free previous skb   */
     ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0, "reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned", reg_desc.dataptr);
-    skb_to_free = get_skb_pointer(reg_desc.dataptr);
-    atm_free_tx_skb_vcc_delayed(skb_to_free);
+
+	free_skb_clear_dataptr(&reg_desc);
     put_skb_to_dbg_pool(skb);
 
     /*  setup descriptor    */
@@ -2771,13 +2757,15 @@
 
     /*  free previous skb   */
     ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0, "reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned", reg_desc.dataptr);
-    skb_to_free = get_skb_pointer(reg_desc.dataptr);
-    dev_kfree_skb_any(skb_to_free);
+
+    free_skb_clear_dataptr(desc);
 
     /*  detach from protocol    */
     skb_to_free = skb;
-    skb = skb_break_away_from_protocol(skb);
-    dev_kfree_skb_any(skb_to_free);
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
+        skb = skb_to_free;
+		goto ALLOC_SKB_TX_FAIL;
+    }
 
     put_skb_to_dbg_pool(skb);
 
@@ -3933,36 +3921,6 @@
     }
 }
 
-static INLINE void atm_free_tx_skb_vcc_delayed(struct sk_buff *skb)
-{
-#if !defined(ENABLE_NO_DELAY_ATM_SKB_FREE) || !ENABLE_NO_DELAY_ATM_SKB_FREE
-    struct atm_vcc* vcc;
-    int i;
-
-    ASSERT((u32)skb > 0x80000000, "atm_free_tx_skb_vcc: skb = %08X", (u32)skb);
-
-    vcc = ATM_SKB(skb)->vcc;
-
-    if ( (unsigned int)vcc >= KSEG0 && (unsigned int)vcc->pop >= KSEG0 )
-    {
-        for ( i = 0; i < ATM_PORT_NUMBER; i++ )
-            if ( vcc->dev == g_atm_priv_data.port[i].dev )
-                break;
-
-        if ( i < ATM_PORT_NUMBER && find_vcc(vcc) >= 0 )
-        {
-            ASSERT(atomic_read(&skb->users) != 0, "atm_free_tx_skb_vcc(vcc->pop): skb->users == 0, skb = %08X", (u32)skb);
-            atomic_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);
-            vcc->pop(vcc, skb);
-            return;
-        }
-    }
-#endif
-
-    //  Else
-    ASSERT(atomic_read(&skb->users) != 0, "atm_free_tx_skb_vcc(dev_kfree_skb_any): skb->users == 0, skb = %08X", (u32)skb);
-    dev_kfree_skb_any(skb);
-}
 
 static irqreturn_t mailbox0_irq_handler(int irq, void *dev_id)
 {
@@ -4093,9 +4051,7 @@
                 g_cpu_to_wan_swap_desc_pos = 0;
 
             /*  free previous skb   */
-            skb_to_free = get_skb_pointer(desc->dataptr);
-            if ( skb_to_free != NULL )
-                dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(desc);
             put_skb_to_dbg_pool(new_skb);
 
             /*  update descriptor   */
@@ -4492,8 +4448,7 @@
 	else
 		dma_alignment_atm_bad_count++;
 
-	skb_to_free = get_skb_pointer(reg_desc.dataptr);
-	dev_kfree_skb_any(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 	put_skb_to_dbg_pool(skb);
 
 	/*  update descriptor   */
@@ -6626,21 +6581,23 @@
     struct sk_buff *skb_to_free;
     int i;
 
+    dma_device_unregister(g_dma_device_ppe);
+    dma_device_release(g_dma_device_ppe);
+    g_dma_device_ppe = NULL;
+
     if ( g_eth_wan_mode == 0 || g_wanqos_en )
     {
         p = (volatile struct tx_descriptor *)CPU_TO_WAN_TX_DESC_BASE;
         for ( i = 0; i < CPU_TO_WAN_TX_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
 
         p = (volatile struct tx_descriptor *)DSL_WAN_TX_DESC_BASE(0);
         for ( i = 0; i < WAN_TX_DESC_NUM_TOTAL; i++ )
         {
-            skb_to_free = get_skb_pointer(g_eth_wan_mode == 0 ? p->dataptr << 2 : p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr_shift(p, (g_eth_wan_mode == 0)?2:0 );
             p++;
         }
     }
@@ -6650,16 +6607,14 @@
         p = (volatile struct tx_descriptor *)WAN_RX_DESC_BASE(0);
         for ( i = 0; i < WAN_RX_DESC_NUM(0); i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
 
         p = (volatile struct tx_descriptor *)WAN_RX_DESC_BASE(1);
         for ( i = 0; i < WAN_RX_DESC_NUM(1); i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr << 2);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr_shift(p, 2);
             p++;
         }
     }
@@ -6667,16 +6622,14 @@
     p = (volatile struct tx_descriptor *)DMA_RX_CH1_DESC_BASE;
     for ( i = 0; i < DMA_RX_CH1_DESC_NUM; i++ )
     {
-        skb_to_free = get_skb_pointer(p->dataptr);
-        dev_kfree_skb_any(skb_to_free);
+        free_skb_clear_dataptr(p);
         p++;
     }
 
     p = (volatile struct tx_descriptor *)DMA_RX_CH2_DESC_BASE;
     for ( i = 0; i < DMA_RX_CH2_DESC_NUM; i++ )
     {
-        skb_to_free = get_skb_pointer(p->dataptr);
-        dev_kfree_skb_any(skb_to_free);
+        free_skb_clear_dataptr(p);
         p++;
     }
 
@@ -6685,15 +6638,11 @@
         p = (volatile struct tx_descriptor *)DMA_TX_CH1_DESC_BASE;
         for ( i = 0; i < DMA_TX_CH1_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+        	free_skb_clear_dataptr(p);
             p++;
         }
     }
 
-    dma_device_unregister(g_dma_device_ppe);
-    dma_device_release(g_dma_device_ppe);
-    g_dma_device_ppe = NULL;
 
 #if defined(DEBUG_SKB_SWAP) && DEBUG_SKB_SWAP
     for ( i = 0; i < NUM_ENTITY(g_dbg_skb_swap_pool); i++ )
--- linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/common/ifxmips_ppa_datapath_common.h
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/common/ifxmips_ppa_datapath_common.h
@@ -184,11 +184,26 @@
 /*
  *  Buffer Management
  */
-static struct sk_buff* skb_break_away_from_protocol(struct sk_buff *);
+static struct sk_buff* skb_break_away_from_protocol_avm(struct sk_buff *);
+
 static INLINE void __get_skb_from_dbg_pool(struct sk_buff *, const char *, unsigned int);
 #define get_skb_from_dbg_pool(skb)  __get_skb_from_dbg_pool(skb, __FUNCTION__, __LINE__)
-static INLINE struct sk_buff *__get_skb_pointer(unsigned int, const char *, unsigned int);
-#define get_skb_pointer(dataptr)    __get_skb_pointer(dataptr, __FUNCTION__, __LINE__)
+
+static INLINE void __free_skb_clear_dataptr( unsigned int dataptr, const char *func_name, unsigned int line_num);
+
+#define free_skb_clear_dataptr(descr)   \
+	do { \
+		smp_mb(); \
+		__free_skb_clear_dataptr((descr)->dataptr, __FUNCTION__, __LINE__); \
+	} while(0)
+
+#define free_skb_clear_dataptr_shift(descr, shift)    \
+	do { \
+		smp_mb(); \
+		__free_skb_clear_dataptr((((descr)->dataptr) << (shift)), __FUNCTION__, __LINE__); \
+	} while(0)
+
+
 static INLINE void __put_skb_to_dbg_pool(struct sk_buff *, const char *, unsigned int);
 #define put_skb_to_dbg_pool(skb)    __put_skb_to_dbg_pool(skb, __FUNCTION__, __LINE__)
 
@@ -3686,8 +3701,7 @@
 	ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0,
 			"reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned",
 			reg_desc.dataptr);
-	skb_to_free = get_skb_pointer(reg_desc.dataptr);
-	dev_kfree_skb_any(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 	put_skb_to_dbg_pool(skb);
 
 	/*  setup descriptor    */
@@ -5999,39 +6013,25 @@
 /*------------------------------------------------------------------------------------------*\
 \*------------------------------------------------------------------------------------------*/
 
-static struct sk_buff* skb_break_away_from_protocol(struct sk_buff *skb) {
-	struct sk_buff *new_skb;
-
-	if (skb_shared(skb)) {
-		// destructor is NULL after skb_clone
-		new_skb = skb_clone(skb, GFP_ATOMIC);
-		if (new_skb == NULL)
-			return NULL;
-	} else
-		new_skb = skb_get(skb);
+static struct sk_buff* skb_break_away_from_protocol_avm(struct sk_buff *skb) {
+	skb = skb_share_check(skb, GFP_ATOMIC);
+	if (skb == NULL)
+		return NULL;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
-	dst_release(new_skb->dst);
-	new_skb->dst = NULL;
-#else
-	skb_dst_drop(new_skb);
-#endif
+	skb_dst_drop(skb);
 #ifdef CONFIG_XFRM
-	secpath_put(new_skb->sp);
-	new_skb->sp = NULL;
+	secpath_put(skb->sp);
+	skb->sp = NULL;
 #endif
 	/*
-	 *  ccb: why does lantiq not use skb_orphan?
+	 *  ccb: use orphan instead of lantiq concept
 	 */
-    if ( new_skb->destructor )
-    {
-        WARN_ON(in_irq());
-        new_skb->destructor(new_skb);
-        new_skb->destructor = NULL;
-    }
-	return new_skb;
+	skb_orphan(skb);
+	return skb;
 }
 
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
 static INLINE void __get_skb_from_dbg_pool(
 		struct sk_buff *skb __attribute__((unused)),
 		const char *func_name __attribute__((unused)),
@@ -6050,20 +6050,61 @@
 #endif
 }
 
-static INLINE struct sk_buff *__get_skb_pointer(unsigned int dataptr, const char *func_name, unsigned int line_num)
-{
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+static INLINE void __put_skb_to_dbg_pool(struct sk_buff *skb __attribute__((unused)),
+		const char *func_name __attribute__((unused)), unsigned int line_num __attribute__((unused))) {
+#if defined(DEBUG_SKB_SWAP) && DEBUG_SKB_SWAP
+	int i;
+
+	for ( i = 0; i < NUM_ENTITY(g_dbg_skb_swap_pool) && g_dbg_skb_swap_pool[i] != NULL; i++ );
+	if ( i == NUM_ENTITY(g_dbg_skb_swap_pool) )
+	{
+		err("%s:%d: g_dbg_skb_swap_pool overrun", func_name, line_num);
+	}
+	else
+	g_dbg_skb_swap_pool[i] = skb;
+#endif
+}
+
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+
+
+static INLINE struct sk_buff **dmadataptr_to_skbptr(unsigned int dataptr){
     unsigned int skb_dataptr;
+
+    skb_dataptr = (dataptr - 4) | KSEG1;
+    return (struct sk_buff **)skb_dataptr;
+}
+
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+
+
+static INLINE void __free_skb_clear_dataptr(unsigned int dataptr, const char *func_name, unsigned int line_num) {
+    struct sk_buff **skbp;
     struct sk_buff *skb;
 
-    //  usually, CPE memory is less than 256M bytes
-    //  so NULL means invalid pointer
+
+    /*
+     * usually, CPE memory is less than 256M bytes
+     * so NULL means invalid pointer
+     */
     if ( dataptr == 0 ) {
-        dbg("dataptr is 0, it's supposed to be invalid pointer");
-        return NULL;
+        DBG_SKB_FREE("dataptr is 0, caller=%s at line %d\n", func_name, line_num);
+        return;
     }
 
-    skb_dataptr = (dataptr - 4) | KSEG1;
-    skb = *(struct sk_buff **)skb_dataptr;
+    skbp = dmadataptr_to_skbptr( dataptr );
+    skb = *skbp;
+    if (!skb){
+        DBG_SKB_FREE("implicit skb at dma dataptr %#x is 0, caller=%s at line %d\n", dataptr, func_name, line_num);
+    	return;
+    }
+    *skbp = NULL;
+
+    dev_kfree_skb_any(skb);
 
     __get_skb_from_dbg_pool(skb, func_name, line_num);
 
@@ -6074,23 +6115,15 @@
 			func_name, line_num, (unsigned int)skb, (unsigned int)skb->data, dataptr
 			);
 
-    return skb;
+	smp_mb();
+
+    return;
 }
 
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+
 
-static INLINE void __put_skb_to_dbg_pool(struct sk_buff *skb __attribute__((unused)),
-		const char *func_name __attribute__((unused)), unsigned int line_num __attribute__((unused))) {
-#if defined(DEBUG_SKB_SWAP) && DEBUG_SKB_SWAP
-	int i;
 
-	for ( i = 0; i < NUM_ENTITY(g_dbg_skb_swap_pool) && g_dbg_skb_swap_pool[i] != NULL; i++ );
-	if ( i == NUM_ENTITY(g_dbg_skb_swap_pool) )
-	{
-		err("%s:%d: g_dbg_skb_swap_pool overrun", func_name, line_num);
-	}
-	else
-	g_dbg_skb_swap_pool[i] = skb;
-#endif
-}
 
 #endif // #ifndef _IFXMIPS_PPA_DATAPATH_COMMON
--- linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/common/swi_ifx_common.h
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/common/swi_ifx_common.h
@@ -37,6 +37,8 @@
 
 #define INIT_HW                                 1
 
+#define ENABLE_DBG_SKB_FREE						1
+
 #if defined(CONFIG_AVMNET_DEBUG) 
 #define DEBUG_DUMP_INIT                         0
 #define DEBUG_DUMP_SKB                          1
@@ -75,6 +77,12 @@
   #define ENABLE_DBG_PROC                       0
 #endif
 
+#if defined(ENABLE_DBG_SKB_FREE) && ENABLE_DBG_SKB_FREE
+#define DBG_SKB_FREE(format, arg...)                     do { printk(KERN_ERR format "\n", ##arg); } while ( 0 )
+#else
+#define DBG_SKB_FREE(format, arg...)
+#endif
+
 #if defined(ENABLE_DBG_PROC) && ENABLE_DBG_PROC
 #define err(format, arg...)                     do { if ( unlikely(g_dbg_datapath & DBG_ENABLE_MASK_ERR) ) printk(KERN_ERR __FILE__ ":%d:%s: " format "\n", __LINE__, __FUNCTION__, ##arg); } while ( 0 )
 #else
--- linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/vr9/ifxmips_ppa_datapath_vr9_a5.c
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/vr9/ifxmips_ppa_datapath_vr9_a5.c
@@ -849,7 +849,7 @@
 static INLINE void clear_local_variables(void);
 static INLINE void init_communication_data_structures(int);
 static INLINE int alloc_dma(void);
-static INLINE void free_dma(void);
+static void free_dma(void);
 
 /*
  *  DSL Data Led help function
@@ -1675,18 +1675,16 @@
 	ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0,
 			"reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned",
 			reg_desc.dataptr);
-	skb_to_free = get_skb_pointer(reg_desc.dataptr);
-	dev_kfree_skb_any(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 	put_skb_to_dbg_pool(skb);
 
     /*  detach from protocol    */
     skb_to_free = skb;
-    if( (skb = skb_break_away_from_protocol(skb)) == NULL) {
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
         skb = skb_to_free;
 		ret = -ENOMEM;
 		goto ALLOC_SKB_TX_FAIL;
     }
-    dev_kfree_skb_any(skb_to_free);
 
     put_skb_to_dbg_pool(skb);
 #if defined(DEBUG_MIRROR_PROC) && DEBUG_MIRROR_PROC
@@ -1788,7 +1786,6 @@
 	unsigned long sys_flag;
 	volatile struct tx_descriptor *desc;
 	struct tx_descriptor reg_desc;
-	struct sk_buff *skb_to_free;
 
 	if (((uni_cell_header->pti == ATM_PTI_SEGF5
 			|| uni_cell_header->pti == ATM_PTI_E2EF5)
@@ -1843,8 +1840,7 @@
 	ASSERT((reg_desc.dataptr & (DMA_TX_ALIGNMENT - 1)) == 0,
 			"reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned",
 			reg_desc.dataptr);
-	skb_to_free = get_skb_pointer(reg_desc.dataptr);
-	dev_kfree_skb_any(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 	put_skb_to_dbg_pool(skb);
 
 	/*  setup descriptor    */
@@ -2178,16 +2174,14 @@
 
     /*  free previous skb   */
     ASSERT((reg_desc.dataptr & (DMA_ALIGNMENT - 1)) == 0, "reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned", reg_desc.dataptr);
-    skb_to_free = get_skb_pointer(reg_desc.dataptr);
-    dev_kfree_skb_any(skb_to_free);
+    free_skb_clear_dataptr(&reg_desc);
 
     /*  detach from protocol    */
     skb_to_free = skb;
-    if( (skb = skb_break_away_from_protocol(skb)) == NULL) {
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
         skb = skb_to_free;
 		goto ALLOC_SKB_TX_FAIL;
     }
-    dev_kfree_skb_any(skb_to_free);
 
     put_skb_to_dbg_pool(skb);
 
@@ -3598,7 +3592,6 @@
         volatile struct tx_descriptor *desc =
                 &CPU_TO_WAN_SWAP_DESC_BASE[g_cpu_to_wan_swap_desc_pos];
         struct tx_descriptor reg_desc = { 0 };
-        struct sk_buff *skb_to_free;
 
         dbg("CPU_TO_WAN_SWAP_SIG");
         while (desc->own == 0) {
@@ -3615,9 +3608,7 @@
                 g_cpu_to_wan_swap_desc_pos = 0;
 
             /*  free previous skb   */
-            skb_to_free = get_skb_pointer(desc->dataptr);
-            if (skb_to_free != NULL)
-                dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(desc);
             put_skb_to_dbg_pool(new_skb);
 
             /*  update descriptor   */
@@ -3847,7 +3838,6 @@
 	unsigned long sys_flag;
 	volatile struct tx_descriptor *desc;
 	struct tx_descriptor reg_desc;
-	struct sk_buff *skb_to_free;
 	int byteoff;
 	int conn;
 
@@ -3954,8 +3944,7 @@
 	else
 		dma_alignment_atm_bad_count++;
 
-	skb_to_free = get_skb_pointer(reg_desc.dataptr);
-	dev_kfree_skb_any(skb_to_free);
+	free_skb_clear_dataptr(&reg_desc);
 	put_skb_to_dbg_pool(skb);
 
 	/*  update descriptor   */
@@ -5669,26 +5658,30 @@
 	ALLOC_SKB_POOL_FAIL: return ret;
 }
 
-static INLINE void free_dma(void) {
+static void free_dma(void) {
     volatile struct tx_descriptor *p;
-    struct sk_buff *skb_to_free;
     int i;
 
+    // first do dma_device unregister (which removes many skb's) and sets
+    // pch->opt[i]=NULL
+    dma_device_unregister(g_dma_device_ppe);
+	dma_device_release(g_dma_device_ppe);
+	g_dma_device_ppe = NULL;
+
+    // after that we can walk through the channels and clear remaining skbs
     if ( g_eth_wan_mode == 0 || g_wanqos_en )
     {
         p = (volatile struct tx_descriptor *)CPU_TO_WAN_TX_DESC_BASE;
         for ( i = 0; i < CPU_TO_WAN_TX_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
 
         p = (volatile struct tx_descriptor *)DSL_WAN_TX_DESC_BASE(0);
         for ( i = 0; i < WAN_TX_DESC_NUM_TOTAL; i++ )
         {
-            skb_to_free = get_skb_pointer(g_eth_wan_mode == 0 ? p->dataptr << 2 : p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr_shift(p, (g_eth_wan_mode == 0)?2:0 );
             p++;
         }
     }
@@ -5698,8 +5691,7 @@
         p = (volatile struct tx_descriptor *)CPU_TO_WAN_SWAP_DESC_BASE;
         for ( i = 0; i < CPU_TO_WAN_SWAP_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
     }
@@ -5709,16 +5701,14 @@
         p = (volatile struct tx_descriptor *)WAN_RX_DESC_BASE(0);
         for ( i = 0; i < WAN_RX_DESC_NUM(0); i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
 
         p = (volatile struct tx_descriptor *)WAN_RX_DESC_BASE(1);
         for ( i = 0; i < WAN_RX_DESC_NUM(1); i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr << 2);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr_shift(p, 2);
             p++;
         }
     }
@@ -5730,8 +5720,7 @@
         if ( g_eth_wan_mode != 0 && !g_wanqos_en )
             break;
 #endif
-        skb_to_free = get_skb_pointer(p->dataptr);
-        dev_kfree_skb_any(skb_to_free);
+        free_skb_clear_dataptr(p);
         p++;
     }
 
@@ -5739,8 +5728,7 @@
     p = (volatile struct tx_descriptor *)DMA_RX_CH2_DESC_BASE;
     for ( i = 0; i < DMA_RX_CH2_DESC_NUM; i++ )
     {
-        skb_to_free = get_skb_pointer(p->dataptr);
-        dev_kfree_skb_any(skb_to_free);
+        free_skb_clear_dataptr(p);
         p++;
     }
 #endif
@@ -5750,15 +5738,11 @@
         p = (volatile struct tx_descriptor *)DMA_TX_CH1_DESC_BASE;
         for ( i = 0; i < DMA_TX_CH1_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
     }
 
-	dma_device_unregister(g_dma_device_ppe);
-	dma_device_release(g_dma_device_ppe);
-	g_dma_device_ppe = NULL;
 
 #if defined(DEBUG_SKB_SWAP) && DEBUG_SKB_SWAP
     for ( i = 0; i < NUM_ENTITY(g_dbg_skb_swap_pool); i++ )
@@ -6699,7 +6683,6 @@
     vcc_map_skb_prio_qos_queue = NULL;
     vcc_set_nr_qos_queues = NULL;
 
-
 	free_dma();
 
 	clear_share_buffer();
--- linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/vr9/ifxmips_ppa_datapath_vr9_e5.c
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/ifx/vr9/ifxmips_ppa_datapath_vr9_e5.c
@@ -1209,17 +1209,14 @@
 			skb->len + byteoff + sizeof(struct sk_buff *));
 
 	/*  free previous skb   */
-	skb_to_free = get_skb_pointer(desc->dataptr);
-	if (skb_to_free != NULL)
-		dev_kfree_skb_any(skb_to_free); // hier stuerzt es ab (Unhandled kernel unaligned access)
+	free_skb_clear_dataptr(desc);
 
 	/*  detach from protocol    */
 	skb_to_free = skb;
-    if( (skb = skb_break_away_from_protocol(skb)) == NULL) {
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
         skb = skb_to_free;
 		goto ALLOC_SKB_TX_FAIL;
     }
-	dev_kfree_skb_any(skb_to_free);
 
 	put_skb_to_dbg_pool(skb);
 
@@ -1561,16 +1558,14 @@
 
     /*  free previous skb   */
     ASSERT((reg_desc.dataptr & 31) == 0, "reg_desc.dataptr (0x%#x) must be 8 DWORDS aligned", reg_desc.dataptr);
-    skb_to_free = get_skb_pointer(reg_desc.dataptr);
-    dev_kfree_skb_any(skb_to_free);
+    free_skb_clear_dataptr(&reg_desc);
 
     /*  detach from protocol    */
     skb_to_free = skb;
-    if( (skb = skb_break_away_from_protocol(skb)) == NULL) {
+    if( (skb = skb_break_away_from_protocol_avm(skb)) == NULL) {
         skb = skb_to_free;
 		goto ALLOC_SKB_TX_FAIL;
     }
-    dev_kfree_skb_any(skb_to_free);
 
     put_skb_to_dbg_pool(skb);
 
@@ -2077,7 +2072,6 @@
 		struct sk_buff *new_skb;
 		volatile struct tx_descriptor *desc = &CPU_TO_WAN_SWAP_DESC_BASE[g_cpu_to_wan_swap_desc_pos];
 		struct tx_descriptor reg_desc = { 0 };
-		struct sk_buff *skb_to_free;
 
 #if defined(CONFIG_AVMNET_DEBUG) 
 		if ( g_dbg_datapath & DBG_ENABLE_MASK_DEBUG_MAILBOX )
@@ -2097,9 +2091,7 @@
 				g_cpu_to_wan_swap_desc_pos = 0;
 
 			/*  free previous skb   */
-			skb_to_free = get_skb_pointer(desc->dataptr);
-			if (skb_to_free != NULL)
-				dev_kfree_skb_any(skb_to_free);
+			free_skb_clear_dataptr(desc);
 			put_skb_to_dbg_pool(new_skb);
 
 			/*  update descriptor   */
@@ -4431,9 +4423,12 @@
 static INLINE void free_dma(void)
 {
     volatile struct tx_descriptor *p;
-    struct sk_buff *skb_to_free;
     int i;
 
+    dma_device_unregister(g_dma_device_ppe);
+	dma_device_release(g_dma_device_ppe);
+	g_dma_device_ppe = NULL;
+
     if ( g_eth_wan_mode == 0 || g_wanqos_en )
     {
         if ( g_eth_wan_mode == 0 && g_dsl_bonding )
@@ -4443,16 +4438,14 @@
                 p = (volatile struct tx_descriptor *)E1_FRAG_RX_DESC_BASE(0);
                 for ( i = 0; i < E1_FRAG_RX_DESC_NUM; i++ )
                 {
-                    skb_to_free = get_skb_pointer(p->dataptr);
-                    dev_kfree_skb_any(skb_to_free);
+                    free_skb_clear_dataptr(p);
                     p++;
                 }
 
                 p = (volatile struct tx_descriptor *)B1_RX_LINK_LIST_DESC_BASE;
                 for ( i = 0; i < B1_RX_LINK_LIST_DESC_NUM; i++ )
                 {
-                    skb_to_free = get_skb_pointer(p->dataptr);
-                    dev_kfree_skb_any(skb_to_free);
+                    free_skb_clear_dataptr(p);
                     p++;
                 }
             }
@@ -4462,8 +4455,7 @@
             p = (volatile struct tx_descriptor *)CPU_TO_WAN_TX_DESC_BASE;
             for ( i = 0; i < CPU_TO_WAN_TX_DESC_NUM; i++ )
             {
-                skb_to_free = get_skb_pointer(p->dataptr);
-                dev_kfree_skb_any(skb_to_free);
+                free_skb_clear_dataptr(p);
                 p++;
             }
         }
@@ -4473,8 +4465,7 @@
             p = (volatile struct tx_descriptor *)WAN_TX_DESC_BASE(0);
             for ( i = 0; i < WAN_TX_DESC_NUM_TOTAL; i++ )
             {
-                skb_to_free = get_skb_pointer(p->dataptr);
-                dev_kfree_skb_any(skb_to_free);
+                free_skb_clear_dataptr(p);
                 p++;
             }
         }
@@ -4484,8 +4475,7 @@
             p = (volatile struct tx_descriptor *)CPU_TO_WAN_SWAP_DESC_BASE;
             for ( i = 0; i < CPU_TO_WAN_SWAP_DESC_NUM; i++ )
             {
-                skb_to_free = get_skb_pointer(p->dataptr);
-                dev_kfree_skb_any(skb_to_free);
+                free_skb_clear_dataptr(p);
                 p++;
             }
         }
@@ -4501,8 +4491,7 @@
             if ( g_eth_wan_mode != 0 && !g_wanqos_en )
                 break;
   #endif
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
     }
@@ -4512,8 +4501,7 @@
     p = (volatile struct tx_descriptor *)DMA_RX_CH2_DESC_BASE;
     for ( i = 0; i < DMA_RX_CH2_DESC_NUM; i++ )
     {
-        skb_to_free = get_skb_pointer(p->dataptr);
-        dev_kfree_skb_any(skb_to_free);
+        free_skb_clear_dataptr(p);
         p++;
     }
 #endif
@@ -4523,16 +4511,11 @@
         p = (volatile struct tx_descriptor *)DMA_TX_CH1_DESC_BASE;
         for ( i = 0; i < DMA_TX_CH1_DESC_NUM; i++ )
         {
-            skb_to_free = get_skb_pointer(p->dataptr);
-            dev_kfree_skb_any(skb_to_free);
+            free_skb_clear_dataptr(p);
             p++;
         }
     }
 
-	// AVM: we do this in dma_shutdown_gracefully
-	dma_device_unregister(g_dma_device_ppe);
-	dma_device_release(g_dma_device_ppe);
-	g_dma_device_ppe = NULL;
 
 #if defined(DEBUG_SKB_SWAP) && DEBUG_SKB_SWAP
     for ( i = 0; i < NUM_ENTITY(g_dbg_skb_swap_pool); i++ )
--- linux-2.6.32/include/linux/avm_pa.h
+++ linux-2.6.32/include/linux/avm_pa.h
@@ -1,7 +1,7 @@
 /*
  *     Definitions for AVM packet acceleration
  *
- * Copyright (c) 2011-2013 AVM GmbH <info@avm.de>
+ * Copyright (c) 2011-2014 AVM GmbH <info@avm.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -137,7 +137,7 @@
    struct packet_type    *ptype; /* avm_pa_framing_ptype */
 };
 
-#define AVM_PA_PID_ECFG_VERSION 2
+#define AVM_PA_PID_ECFG_VERSION 3
 struct avm_pa_pid_ecfg {
     int           version;
 	/* version 0 */
@@ -152,6 +152,9 @@
 	/* version 2 */
 	void  (*rx_slow)(void *arg, PKT *pkt);
     void  *rx_slow_arg;
+	/* version 3 */
+#define AVM_PA_PID_GROUP_WLAN_STA             1
+	int   pid_group;
 };
 
 struct avm_pa_vpid_cfg {
--- linux-2.6.32/net/avm_pa/avm_pa.c
+++ linux-2.6.32/net/avm_pa/avm_pa.c
@@ -1,10 +1,10 @@
-#define AVM_PA_VERSION "4.3.8 2014-07-08"
+#define AVM_PA_VERSION "4.3.9 2014-07-29"
 /*
  * Packet Accelerator Interface
  *
  * vim:set expandtab shiftwidth=3 softtabstop=3:
  * 
- * Copyright (c) 2011-2013 AVM GmbH <info@avm.de>
+ * Copyright (c) 2011-2014 AVM GmbH <info@avm.de>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -84,6 +84,10 @@
  *   DEAD   -> pa_session_gc()       -> FREE
  *
  * Changes for 4.3.8:
+ * - Pid groups eingefuehrt (WLAN-Repeater 1750)
+ * - Ingress Pid change check only for unicast
+ *
+ * Changes for 4.3.8:
  * - Bugfix: bridge packets were cut, when third position of
  *           mac address was 0x00, because ethernet header
  *           was used as IP/IPv6 header, and packets were
@@ -2387,6 +2391,7 @@
    struct avm_pa_global *ctx = &pa_glob;
    u32 hash = macaddr_hash(mac);
    struct avm_pa_macaddr *p;
+   int pid_group = PA_PID(ctx, pid_handle)->ecfg.pid_group;
    int pid_changed = 0;
    AVM_PA_LOCK_DECLARE;
 
@@ -2394,9 +2399,13 @@
    
    for (p = ctx->macaddr_hash[hash%CONFIG_AVM_PA_MAX_SESSION]; p; p = p->link) {
       if (memcmp(mac, &p->mac, ETH_ALEN) == 0) {
-         if (   p->pid_handle != pid_handle
-             && PA_PID(ctx, p->pid_handle)->ingress_pid_handle != pid_handle)
-            pid_changed = 1;
+         if (p->pid_handle != pid_handle) {
+            struct avm_pa_pid *pid = PA_PID(ctx, p->pid_handle);
+            if (pid->ingress_pid_handle != pid_handle) {
+               if (pid_group == 0 || pid_group != pid->ecfg.pid_group)
+                  pid_changed = 1;
+            }
+         }
          break;
       }
    }
@@ -3609,8 +3618,10 @@
    if ((ethh = pa_get_ethhdr(pid->ingress_framing, pkt)) != 0) {
       if ((session = pa_bsession_search(pid, ethh_hash(ethh), ethh)) != 0)
          goto accelerate;
-      if ((pid->ecfg.flags & AVM_PA_PID_FLAG_NO_PID_CHANGED_CHECK) == 0)
-         pa_check_and_handle_ingress_pid_change(ethh->h_source, pid_handle);
+      if ((ethh->h_dest[0] & 1) == 0) {
+         if ((pid->ecfg.flags & AVM_PA_PID_FLAG_NO_PID_CHANGED_CHECK) == 0)
+            pa_check_and_handle_ingress_pid_change(ethh->h_source, pid_handle);
+      }
    }
 
    info->ingress_pid_handle = pid_handle;
@@ -4334,6 +4345,8 @@
       return -1;
    memset(&pid->ecfg, 0, sizeof(struct avm_pa_pid_ecfg));
    switch (ecfg->version) {
+      case 3:
+        pid->ecfg.pid_group = ecfg->pid_group;
       case 2:
         pid->ecfg.rx_slow = ecfg->rx_slow;
         pid->ecfg.rx_slow_arg = ecfg->rx_slow_arg;
