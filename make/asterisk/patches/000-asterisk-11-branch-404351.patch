--- addons/chan_ooh323.c
+++ addons/chan_ooh323.c
@@ -294,8 +294,6 @@
 static int usecnt = 0;
 AST_MUTEX_DEFINE_STATIC(usecnt_lock);
 
-AST_MUTEX_DEFINE_STATIC(ooh323c_cmd_lock);
-
 static long callnumber = 0;
 AST_MUTEX_DEFINE_STATIC(ooh323c_cn_lock);
 
@@ -694,7 +692,7 @@
 			ooh323_destroy(p);
 			ast_mutex_unlock(&iflock);
 			return NULL;
-		} else if (gH323ep.gkClient && gH323ep.gkClient->state != GkClientRegistered) {
+		} else if (!gH323ep.gkClient || (gH323ep.gkClient && gH323ep.gkClient->state != GkClientRegistered)) {
 			ast_log(LOG_ERROR, "Gatekeeper client is configured but not registered\n");
 			*cause = AST_CAUSE_NORMAL_TEMPORARY_FAILURE;
 			return NULL;
@@ -749,7 +747,6 @@
       		}
 
       		ast_mutex_unlock(&p->lock);
-      		ast_mutex_lock(&ooh323c_cmd_lock);
 		ast_cond_init(&p->rtpcond, NULL);
       		ooMakeCall(data, p->callToken, AST_MAX_EXTENSION, NULL);
 		ast_mutex_lock(&p->lock);
@@ -758,7 +755,6 @@
 		}
 		ast_mutex_unlock(&p->lock);
 		ast_cond_destroy(&p->rtpcond);
-      		ast_mutex_unlock(&ooh323c_cmd_lock);
 	}
 
 	restart_monitor();
@@ -2490,11 +2486,23 @@
 					return NULL;
 				}
 			} else if (!strcasecmp(v->name, "e164")) {
-				if (!(peer->e164 = ast_strdup(v->value))) {
-					ast_log(LOG_ERROR, "Could not allocate memory for e164 of "
+				int valid = 1;
+				const char *tmp;
+				for(tmp = v->value; *tmp; tmp++) {
+					if (!isdigit(*tmp)) {
+						valid = 0;
+						break;
+					}
+				}
+				if (valid) {
+					if (!(peer->e164 = ast_strdup(v->value))) {
+						ast_log(LOG_ERROR, "Could not allocate memory for e164 of "
 											 "peer %s\n", name);
-					ooh323_delete_peer(peer);
-					return NULL;
+						ooh323_delete_peer(peer);
+						return NULL;
+					}
+				} else {
+					ast_log(LOG_ERROR, "Invalid e164: %s for peer %s\n", v->value, name);
 				}
 			} else  if (!strcasecmp(v->name, "email")) {
 				if (!(peer->email = ast_strdup(v->value))) {
@@ -2625,6 +2633,9 @@
 
 static int ooh323_do_reload(void)
 {
+	struct ooAliases * pNewAlias = NULL;
+	struct ooh323_peer *peer = NULL;
+
 	if (gH323Debug) {
 		ast_verb(0, "---   ooh323_do_reload\n");
 	}
@@ -2644,6 +2655,46 @@
 		ooGkClientStart(gH323ep.gkClient);
 	}
 
+	/* Set aliases if any */
+	if (gH323Debug) {
+		ast_verb(0, "updating local aliases\n");
+	}
+
+	for (pNewAlias = gAliasList; pNewAlias; pNewAlias = pNewAlias->next) {
+		switch (pNewAlias->type) {
+		case T_H225AliasAddress_h323_ID:
+			ooH323EpAddAliasH323ID(pNewAlias->value);
+			break;
+		case T_H225AliasAddress_dialedDigits:	
+			ooH323EpAddAliasDialedDigits(pNewAlias->value);
+			break;
+		case T_H225AliasAddress_email_ID:	
+			ooH323EpAddAliasEmailID(pNewAlias->value);
+			break;
+		default:
+            		;
+		}
+	}
+
+	ast_mutex_lock(&peerl.lock);
+	peer = peerl.peers;
+	while (peer) {
+		if(peer->h323id) {
+			ooH323EpAddAliasH323ID(peer->h323id);
+		}
+		if(peer->email) {
+			ooH323EpAddAliasEmailID(peer->email);
+		}
+		if(peer->e164) {
+			ooH323EpAddAliasDialedDigits(peer->e164);
+		}
+       		if(peer->url) {
+			ooH323EpAddAliasURLID(peer->url);
+		}
+		peer = peer->next;
+	}
+	ast_mutex_unlock(&peerl.lock);
+
 	if (gH323Debug) {
 		ast_verb(0, "+++   ooh323_do_reload\n");
 	}
@@ -2727,6 +2778,7 @@
 	  		free(prev);
 		}
 		gAliasList = NULL;
+		ooH323EpClearAllAliases();
 	}
 
 	/* Inintialize everything to default */
@@ -2843,17 +2895,29 @@
 			gAliasList = pNewAlias;
 			pNewAlias = NULL;
 		} else if (!strcasecmp(v->name, "e164")) {
-         		pNewAlias = ast_calloc(1, sizeof(struct ooAliases));
-			if (!pNewAlias) {
-				ast_log(LOG_ERROR, "Failed to allocate memory for e164 alias\n");
-				ast_config_destroy(cfg);
-				return 1;
+			int valid = 1;
+			const char *tmp;
+			for(tmp = v->value; *tmp; tmp++) {
+				if (!isdigit(*tmp)) {
+					valid = 0;
+					break;
+				}
+			}
+			if (valid) {
+         			pNewAlias = ast_calloc(1, sizeof(struct ooAliases));
+				if (!pNewAlias) {
+					ast_log(LOG_ERROR, "Failed to allocate memory for e164 alias\n");
+					ast_config_destroy(cfg);
+					return 1;
+				}
+				pNewAlias->type =  T_H225AliasAddress_dialedDigits;
+				pNewAlias->value = strdup(v->value);
+				pNewAlias->next = gAliasList;
+				gAliasList = pNewAlias;
+				pNewAlias = NULL;
+			} else {
+				ast_log(LOG_ERROR, "Invalid e164: %s\n", v->value);
 			}
-			pNewAlias->type =  T_H225AliasAddress_dialedDigits;
-			pNewAlias->value = strdup(v->value);
-			pNewAlias->next = gAliasList;
-			gAliasList = pNewAlias;
-			pNewAlias = NULL;
 		} else if (!strcasecmp(v->name, "email")) {
          		pNewAlias = ast_calloc(1, sizeof(struct ooAliases));
 			if (!pNewAlias) {
@@ -3425,6 +3489,9 @@
 	case GkClientFailed:
 		ast_cli(a->fd, "%-20s%s\n", "GK state:", "Failed");
 		break;
+	case GkClientStopped:
+		ast_cli(a->fd, "%-20s%s\n", "GK state:", "Shutdown");
+		break;
 	default:
 		break;
 	}
@@ -3850,6 +3917,13 @@
 			ast_verb(1, "Reloading H.323\n");
 			ooh323_do_reload();
 		}
+		if (gH323ep.gkClient && gH323ep.gkClient->state == GkClientStopped) {
+			ooGkClientDestroy();
+			ast_verb(0, "Restart stopped gatekeeper client\n");
+			ooGkClientInit(gRasGkMode, (gRasGkMode == RasUseSpecificGatekeeper) ? 
+									gGatekeeper : 0, 0);
+			ooGkClientStart(gH323ep.gkClient);
+		}
 
 		/* Check for interfaces needing to be killed */
 		ast_mutex_lock(&iflock);
--- addons/ooh323c/src/oochannels.c
+++ addons/ooh323c/src/oochannels.c
@@ -603,11 +603,7 @@
       if(gH323ep.gkClient->state == GkClientFailed ||
          gH323ep.gkClient->state == GkClientGkErr)
       {
-         if(ooGkClientHandleClientOrGkFailure(gH323ep.gkClient)!=OO_OK)
-         {
-            //ooStopMonitorCalls(); //Function calling ooProcessFDSETsAndTimers is responsible for this.
-            return OO_FAILED;
-         }
+         ooGkClientHandleClientOrGkFailure(gH323ep.gkClient);
       }
    }
 
--- addons/ooh323c/src/ooGkClient.c
+++ addons/ooh323c/src/ooGkClient.c
@@ -2851,13 +2851,13 @@
       {
          OOTRACEERR1("Error: Gatekeeper error detected. Closing GkClient as "
                      "Gk mode is UseSpecifcGatekeeper\n");
-         ooGkClientDestroy();
+	 pGkClient->state = GkClientStopped;
          return OO_FAILED;
       }
       else{
          OOTRACEERR1("Error: Gatekeeper error detected. Closing GkClient. NEED"
                     " to implement recovery by rediscovering another gk\n");
-         ooGkClientDestroy();
+	 pGkClient->state = GkClientStopped;
          return OO_FAILED;
       }
    }
--- addons/ooh323c/src/ooGkClient.h
+++ addons/ooh323c/src/ooGkClient.h
@@ -108,7 +108,8 @@
    GkClientRegistered, /* registered with gk */
    GkClientUnregistered,
    GkClientGkErr,/*Gk is not responding, in discover mode can look for new GK*/
-   GkClientFailed
+   GkClientFailed,
+   GkClientStopped
 };
    
 
--- addons/ooh323c/src/ooTimer.c
+++ addons/ooh323c/src/ooTimer.c
@@ -17,7 +17,6 @@
 #include "asterisk.h"
 #include "asterisk/lock.h"
 
-#include "ootypes.h"
 #include "ooDateTime.h"
 #include "ooTimer.h"
 #include "ootrace.h"
@@ -102,7 +101,6 @@
 void ooTimerFireExpired (OOCTXT* pctxt, DList *pList)
 {
    OOTimer* pTimer;
-   int ret = OO_OK;
 
    while (pList->count > 0) {
       pTimer = (OOTimer*) pList->head->data;
@@ -114,7 +112,7 @@
           */
          if (pTimer->reRegister) ooTimerReset (pctxt, pList, pTimer);
 
-	 ret = (*pTimer->timeoutCB)(pTimer->cbData);
+         (*pTimer->timeoutCB)(pTimer->cbData);
 
          if (!pTimer->reRegister) {
             ooTimerDelete (pctxt, pList, pTimer);
@@ -122,8 +120,6 @@
       }
       else break;
    }
-
-   return (void)ret;
 }
 
 int ooTimerInsertEntry (OOCTXT* pctxt, DList *pList, OOTimer* pTimer)
--- apps/app_chanspy.c
+++ apps/app_chanspy.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370955 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
 
 #include <ctype.h>
 #include <errno.h>
@@ -363,7 +363,7 @@
 	OPTION_NAME              = (1 << 12),   /* Say the name of the person on whom we will spy */
 	OPTION_DTMF_SWITCH_MODES = (1 << 13),   /* Allow numeric DTMF to switch between chanspy modes */
 	OPTION_DTMF_EXIT         = (1 << 14),	/* Set DTMF to exit, added for DAHDIScan integration */
-	OPTION_DTMF_CYCLE        = (1 << 15),	/* Custom DTMF for cycling next avaliable channel, (default is '*') */
+	OPTION_DTMF_CYCLE        = (1 << 15),	/* Custom DTMF for cycling next available channel, (default is '*') */
 	OPTION_DAHDI_SCAN        = (1 << 16),	/* Scan groups in DAHDIScan mode */
 	OPTION_STOP              = (1 << 17),
 	OPTION_EXITONHANGUP      = (1 << 18),   /* Hang up when the spied-on channel hangs up. */
--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400741 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402686 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -960,6 +960,32 @@
 	return 0;
 }
 
+void conf_update_user_mute(struct conference_bridge_user *user)
+{
+	int mute_user;
+	int mute_system;
+	int mute_effective;
+
+	/* User level mute request. */
+	mute_user = user->muted;
+
+	/* System level mute request. */
+	mute_system = user->playing_moh
+		/*
+		 * Do not allow waitmarked users to talk to anyone unless there
+		 * is a marked user present.
+		 */
+		|| (!user->conference_bridge->markedusers
+			&& ast_test_flag(&user->u_profile, USER_OPT_WAITMARKED));
+
+	mute_effective = mute_user || mute_system;
+
+	ast_debug(1, "User %s is %s: user:%d system:%d.\n",
+		ast_channel_name(user->chan), mute_effective ? "muted" : "unmuted",
+		mute_user, mute_system);
+	user->features.mute = mute_effective;
+}
+
 void conf_moh_stop(struct conference_bridge_user *user)
 {
 	user->playing_moh = 0;
@@ -1105,9 +1131,7 @@
 	if (ast_test_flag(&first_participant->u_profile, USER_OPT_MUSICONHOLD)) {
 		conf_moh_stop(first_participant);
 	}
-	if (!ast_test_flag(&first_participant->u_profile, USER_OPT_STARTMUTED)) {
-		first_participant->features.mute = 0;
-	}
+	conf_update_user_mute(first_participant);
 }
 
 void conf_ended(struct conference_bridge *conference_bridge)
@@ -1558,7 +1582,7 @@
 
 	if (ast_strlen_zero(data)) {
 		ast_log(LOG_WARNING, "%s requires an argument (conference name[,options])\n", app);
-		res = -1; /* invalid PIN */
+		res = -1;
 		goto confbridge_cleanup;
 	}
 
@@ -1609,7 +1633,7 @@
 		if (conf_set_menu_to_user(conference_bridge_user.menu_name, &conference_bridge_user)) {
 			ast_log(LOG_WARNING, "Conference menu %s does not exist and can not be applied to confbridge user.\n",
 				args.menu_name);
-			res = -1; /* invalid PIN */
+			res = -1;
 			goto confbridge_cleanup;
 		}
 	}
@@ -1631,7 +1655,7 @@
 	if (ast_test_flag(&conference_bridge_user.u_profile, USER_OPT_TALKER_DETECT)) {
 		char *conf_name = ast_strdup(args.conf_name); /* this is freed during feature cleanup */
 		if (!(conf_name)) {
-			res = -1; /* invalid PIN */
+			res = -1;
 			goto confbridge_cleanup;
 		}
 		ast_bridge_features_set_talk_detector(&conference_bridge_user.features,
@@ -1642,7 +1666,7 @@
 
 	/* Look for a conference bridge matching the provided name */
 	if (!(conference_bridge = join_conference_bridge(args.conf_name, &conference_bridge_user))) {
-		res = -1; /* invalid PIN */
+		res = -1;
 		goto confbridge_cleanup;
 	}
 
@@ -1652,7 +1676,8 @@
 
 	/* If the caller should be joined already muted, make it so */
 	if (ast_test_flag(&conference_bridge_user.u_profile, USER_OPT_STARTMUTED)) {
-		conference_bridge_user.features.mute = 1;
+		/* Set user level mute request. */
+		conference_bridge_user.muted = 1;
 	}
 
 	if (ast_test_flag(&conference_bridge_user.u_profile, USER_OPT_DROP_SILENCE)) {
@@ -1769,12 +1794,23 @@
 	struct conference_bridge_user *conference_bridge_user,
 	struct ast_channel *chan)
 {
-	/* Mute or unmute yourself, note we only allow manipulation if they aren't waiting for a marked user or if marked users exist */
-	if (!ast_test_flag(&conference_bridge_user->u_profile, USER_OPT_WAITMARKED) || conference_bridge->markedusers) {
-		conference_bridge_user->features.mute = (!conference_bridge_user->features.mute ? 1 : 0);
-		ast_test_suite_event_notify("CONF_MUTE", "Message: participant %s %s\r\nConference: %s\r\nChannel: %s", ast_channel_name(chan), conference_bridge_user->features.mute ? "muted" : "unmuted", conference_bridge_user->b_profile.name, ast_channel_name(chan));
-	}
-	return ast_stream_and_wait(chan, (conference_bridge_user->features.mute ?
+	int mute;
+
+	/* Toggle user level mute request. */
+	mute = !conference_bridge_user->muted;
+	conference_bridge_user->muted = mute;
+
+	conf_update_user_mute(conference_bridge_user);
+	ast_test_suite_event_notify("CONF_MUTE",
+		"Message: participant %s %s\r\n"
+		"Conference: %s\r\n"
+		"Channel: %s",
+		ast_channel_name(chan),
+		mute ? "muted" : "unmuted",
+		conference_bridge_user->b_profile.name,
+		ast_channel_name(chan));
+
+	return ast_stream_and_wait(chan, (mute ?
 		conf_get_sound(CONF_SOUND_MUTED, conference_bridge_user->b_profile.sounds) :
 		conf_get_sound(CONF_SOUND_UNMUTED, conference_bridge_user->b_profile.sounds)),
 		"");
@@ -1784,22 +1820,27 @@
 {
 	struct conference_bridge_user *participant = NULL;
 	const char *sound_to_play;
+	int mute;
 
 	ao2_lock(conference_bridge);
 
-	/* If already muted, then unmute */
-	conference_bridge->muted = conference_bridge->muted ? 0 : 1;
-	sound_to_play = conf_get_sound((conference_bridge->muted ? CONF_SOUND_PARTICIPANTS_MUTED : CONF_SOUND_PARTICIPANTS_UNMUTED),
-		conference_bridge_user->b_profile.sounds);
+	/* Toggle bridge level mute request. */
+	mute = !conference_bridge->muted;
+	conference_bridge->muted = mute;
 
 	AST_LIST_TRAVERSE(&conference_bridge->active_list, participant, list) {
 		if (!ast_test_flag(&participant->u_profile, USER_OPT_ADMIN)) {
-			participant->features.mute = conference_bridge->muted;
+			/* Set user level to bridge level mute request. */
+			participant->muted = mute;
+			conf_update_user_mute(participant);
 		}
 	}
 
 	ao2_unlock(conference_bridge);
 
+	sound_to_play = conf_get_sound((mute ? CONF_SOUND_PARTICIPANTS_MUTED : CONF_SOUND_PARTICIPANTS_UNMUTED),
+		conference_bridge_user->b_profile.sounds);
+
 	/* The host needs to hear it seperately, as they don't get the audio from play_sound_helper */
 	ast_stream_and_wait(conference_bridge_user->chan, sound_to_play, "");
 
@@ -2219,12 +2260,14 @@
 
 static void handle_cli_confbridge_list_item(struct ast_cli_args *a, struct conference_bridge_user *participant)
 {
-	ast_cli(a->fd, "%-29s ", ast_channel_name(participant->chan));
-	ast_cli(a->fd, "%-17s", participant->u_profile.name);
-	ast_cli(a->fd, "%-17s", participant->b_profile.name);
-	ast_cli(a->fd, "%-17s", participant->menu_name);
-	ast_cli(a->fd, "%-17s", S_COR(ast_channel_caller(participant->chan)->id.number.valid, ast_channel_caller(participant->chan)->id.number.str, "<unknown>"));
-	ast_cli(a->fd, "\n");
+	ast_cli(a->fd, "%-30s %-16s %-16s %-16s %-16s %s\n",
+		ast_channel_name(participant->chan),
+		participant->u_profile.name,
+		participant->b_profile.name,
+		participant->menu_name,
+		S_COR(ast_channel_caller(participant->chan)->id.number.valid,
+			ast_channel_caller(participant->chan)->id.number.str, "<unknown>"),
+		AST_CLI_YESNO(participant->muted));
 }
 
 static char *handle_cli_confbridge_list(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
@@ -2267,8 +2310,8 @@
 			ast_cli(a->fd, "No conference bridge named '%s' found!\n", a->argv[2]);
 			return CLI_SUCCESS;
 		}
-		ast_cli(a->fd, "Channel                       User Profile     Bridge Profile   Menu             CallerID\n");
-		ast_cli(a->fd, "============================= ================ ================ ================ ================\n");
+		ast_cli(a->fd, "Channel                        User Profile     Bridge Profile   Menu             CallerID         Muted\n");
+		ast_cli(a->fd, "============================== ================ ================ ================ ================ =====\n");
 		ao2_lock(bridge);
 		AST_LIST_TRAVERSE(&bridge->active_list, participant, list) {
 			handle_cli_confbridge_list_item(a, participant);
@@ -2335,8 +2378,18 @@
 		}
 	}
 	if (participant) {
-		participant->features.mute = mute;
-		ast_test_suite_event_notify("CONF_MUTE", "Message: participant %s %s\r\nConference: %s\r\nChannel: %s", ast_channel_name(participant->chan), participant->features.mute ? "muted" : "unmuted", bridge->b_profile.name, ast_channel_name(participant->chan));
+		/* Set user level mute request. */
+		participant->muted = mute ? 1 : 0;
+
+		conf_update_user_mute(participant);
+		ast_test_suite_event_notify("CONF_MUTE",
+			"Message: participant %s %s\r\n"
+			"Conference: %s\r\n"
+			"Channel: %s",
+			ast_channel_name(participant->chan),
+			mute ? "muted" : "unmuted",
+			bridge->b_profile.name,
+			ast_channel_name(participant->chan));
 	} else {
 		res = -2;;
 	}
@@ -2596,6 +2649,7 @@
 		"Channel: %s\r\n"
 		"Admin: %s\r\n"
 		"MarkedUser: %s\r\n"
+		"Muted: %s\r\n"
 		"\r\n",
 		id_text,
 		bridge->name,
@@ -2603,7 +2657,8 @@
 		S_COR(ast_channel_caller(participant->chan)->id.name.valid, ast_channel_caller(participant->chan)->id.name.str, "<no name>"),
 		ast_channel_name(participant->chan),
 		ast_test_flag(&participant->u_profile, USER_OPT_ADMIN) ? "Yes" : "No",
-		ast_test_flag(&participant->u_profile, USER_OPT_MARKEDUSER) ? "Yes" : "No");
+		ast_test_flag(&participant->u_profile, USER_OPT_MARKEDUSER) ? "Yes" : "No",
+		participant->muted ? "Yes" : "No");
 }
 
 static int action_confbridgelist(struct mansession *s, const struct message *m)
@@ -3051,11 +3106,11 @@
 {
 	struct conference_bridge_user *only_participant = AST_LIST_FIRST(&conference_bridge->active_list);
 
-	/* Turn on MOH/mute if the single participant is set up for it */
+	/* Turn on MOH if the single participant is set up for it */
 	if (ast_test_flag(&only_participant->u_profile, USER_OPT_MUSICONHOLD)) {
-		only_participant->features.mute = 1;
 		conf_moh_start(only_participant);
 	}
+	conf_update_user_mute(only_participant);
 }
 
 void conf_remove_user_waiting(struct conference_bridge *conference_bridge, struct conference_bridge_user *cbu)
--- apps/app_mixmonitor.c
+++ apps/app_mixmonitor.c
@@ -39,7 +39,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398011 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_MONITOR_DIR */
 #include "asterisk/stringfields.h"
@@ -1078,7 +1078,7 @@
 
 	ast_mutex_lock(&mixmonitor_ds->lock);
 
-	/* closing the filestream here guarantees the file is avaliable to the dialplan
+	/* closing the filestream here guarantees the file is available to the dialplan
 	 * after calling StopMixMonitor */
 	mixmonitor_ds_close_fs(mixmonitor_ds);
 
--- apps/app_queue.c
+++ apps/app_queue.c
@@ -63,7 +63,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401433 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402646 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -1550,7 +1550,7 @@
 	ao2_lock(q);
 	mem_iter = ao2_iterator_init(q->members, 0);
 	for (; (member = ao2_iterator_next(&mem_iter)); ao2_ref(member, -1)) {
-		if ((max_penalty && (member->penalty > max_penalty)) || (min_penalty && (member->penalty < min_penalty))) {
+		if ((max_penalty != INT_MAX && member->penalty > max_penalty) || (min_penalty != INT_MAX && member->penalty < min_penalty)) {
 			if (conditions & QUEUE_EMPTY_PENALTY) {
 				ast_debug(4, "%s is unavailable because his penalty is not between %d and %d\n", member->membername, min_penalty, max_penalty);
 				continue;
@@ -4680,26 +4680,55 @@
 */
 static void update_qe_rule(struct queue_ent *qe)
 {
-	int max_penalty = qe->pr->max_relative ? qe->max_penalty + qe->pr->max_value : qe->pr->max_value;
-	int min_penalty = qe->pr->min_relative ? qe->min_penalty + qe->pr->min_value : qe->pr->min_value;
-	char max_penalty_str[20], min_penalty_str[20];
-	/* a relative change to the penalty could put it below 0 */
-	if (max_penalty < 0) {
-		max_penalty = 0;
-	}
-	if (min_penalty < 0) {
-		min_penalty = 0;
+	int max_penalty = INT_MAX;
+
+	if (qe->max_penalty != INT_MAX) {
+		char max_penalty_str[20];
+
+		if (qe->pr->max_relative) {
+			max_penalty = qe->max_penalty + qe->pr->max_value;
+		} else {
+			max_penalty = qe->pr->max_value;
+		}
+
+		/* a relative change to the penalty could put it below 0 */
+		if (max_penalty < 0) {
+			max_penalty = 0;
+		}
+
+		snprintf(max_penalty_str, sizeof(max_penalty_str), "%d", max_penalty);
+		pbx_builtin_setvar_helper(qe->chan, "QUEUE_MAX_PENALTY", max_penalty_str);
+		qe->max_penalty = max_penalty;
+		ast_debug(3, "Setting max penalty to %d for caller %s since %d seconds have elapsed\n",
+			qe->max_penalty, ast_channel_name(qe->chan), qe->pr->time);
 	}
-	if (min_penalty > max_penalty) {
-		min_penalty = max_penalty;
+
+	if (qe->min_penalty != INT_MAX) {
+		char min_penalty_str[20];
+		int min_penalty;
+
+		if (qe->pr->min_relative) {
+			min_penalty = qe->min_penalty + qe->pr->min_value;
+		} else {
+			min_penalty = qe->pr->min_value;
+		}
+
+		/* a relative change to the penalty could put it below 0 */
+		if (min_penalty < 0) {
+			min_penalty = 0;
+		}
+
+		if (max_penalty != INT_MAX && min_penalty > max_penalty) {
+			min_penalty = max_penalty;
+		}
+
+		snprintf(min_penalty_str, sizeof(min_penalty_str), "%d", min_penalty);
+		pbx_builtin_setvar_helper(qe->chan, "QUEUE_MIN_PENALTY", min_penalty_str);
+		qe->min_penalty = min_penalty;
+		ast_debug(3, "Setting min penalty to %d for caller %s since %d seconds have elapsed\n",
+			qe->min_penalty, ast_channel_name(qe->chan), qe->pr->time);
 	}
-	snprintf(max_penalty_str, sizeof(max_penalty_str), "%d", max_penalty);
-	snprintf(min_penalty_str, sizeof(min_penalty_str), "%d", min_penalty);
-	pbx_builtin_setvar_helper(qe->chan, "QUEUE_MAX_PENALTY", max_penalty_str);
-	pbx_builtin_setvar_helper(qe->chan, "QUEUE_MIN_PENALTY", min_penalty_str);
-	qe->max_penalty = max_penalty;
-	qe->min_penalty = min_penalty;
-	ast_debug(3, "Setting max penalty to %d and min penalty to %d for caller %s since %d seconds have elapsed\n", qe->max_penalty, qe->min_penalty, ast_channel_name(qe->chan), qe->pr->time);
+
 	qe->pr = AST_LIST_NEXT(qe->pr, list);
 }
 
@@ -4848,8 +4877,8 @@
 	unsigned char usepenalty = (membercount <= q->penaltymemberslimit) ? 0 : 1;
 
 	if (usepenalty) {
-		if ((qe->max_penalty && (mem->penalty > qe->max_penalty)) ||
-			(qe->min_penalty && (mem->penalty < qe->min_penalty))) {
+		if ((qe->max_penalty != INT_MAX && mem->penalty > qe->max_penalty) ||
+			(qe->min_penalty != INT_MAX && mem->penalty < qe->min_penalty)) {
 			return -1;
 		}
 	} else {
@@ -6998,10 +7027,10 @@
 		} else {
 			ast_log(LOG_WARNING, "${QUEUE_MAX_PENALTY}: Invalid value (%s), channel %s.\n",
 				max_penalty_str, ast_channel_name(chan));
-			max_penalty = 0;
+			max_penalty = INT_MAX;
 		}
 	} else {
-		max_penalty = 0;
+		max_penalty = INT_MAX;
 	}
 
 	if ((min_penalty_str = pbx_builtin_getvar_helper(chan, "QUEUE_MIN_PENALTY"))) {
@@ -7010,10 +7039,10 @@
 		} else {
 			ast_log(LOG_WARNING, "${QUEUE_MIN_PENALTY}: Invalid value (%s), channel %s.\n",
 				min_penalty_str, ast_channel_name(chan));
-			min_penalty = 0;
+			min_penalty = INT_MAX;
 		}
 	} else {
-		min_penalty = 0;
+		min_penalty = INT_MAX;
 	}
 	ast_channel_unlock(chan);
 
--- apps/app_sms.c
+++ apps/app_sms.c
@@ -40,7 +40,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403855 $")
 
 #include <dirent.h>
 #include <ctype.h>
--- apps/confbridge/conf_state.c
+++ apps/confbridge/conf_state.c
@@ -57,12 +57,11 @@
  */
 static void conf_mute_moh_inactive_waitmarked(struct conference_bridge_user *user)
 {
-	/* Be sure we are muted so we can't talk to anybody else waiting */
-	user->features.mute = 1;
 	/* Start music on hold if needed */
 	if (ast_test_flag(&user->u_profile, USER_OPT_MUSICONHOLD)) {
 		conf_moh_start(user);
 	}
+	conf_update_user_mute(user);
 }
 
 void conf_default_join_waitmarked(struct conference_bridge_user *cbu)
--- apps/confbridge/conf_state_inactive.c
+++ apps/confbridge/conf_state_inactive.c
@@ -61,7 +61,7 @@
 static void join_marked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
-	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/conf_state_multi.c
+++ apps/confbridge/conf_state_multi.c
@@ -54,11 +54,13 @@
 static void join_unmarked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 }
 
 static void join_marked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/conf_state_multi_marked.c
+++ apps/confbridge/conf_state_multi_marked.c
@@ -60,11 +60,13 @@
 static void join_active(struct conference_bridge_user *cbu)
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 }
 
 static void join_marked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 }
 
 static void leave_active(struct conference_bridge_user *cbu)
@@ -95,8 +97,8 @@
 		AST_LIST_TRAVERSE_SAFE_BEGIN(&cbu->conference_bridge->active_list, cbu_iter, list) {
 			/* Kick ENDMARKED cbu_iters */
 			if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_ENDMARKED)) {
-				if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED) &&
-						  !ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
+				if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED)
+					&& !ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
 					AST_LIST_REMOVE_CURRENT(list);
 					cbu_iter->conference_bridge->activeusers--;
 					AST_LIST_INSERT_TAIL(&cbu_iter->conference_bridge->waiting_list, cbu_iter, list);
@@ -104,17 +106,18 @@
 				}
 				cbu_iter->kicked = 1;
 				ast_bridge_remove(cbu_iter->conference_bridge->bridge, cbu_iter->chan);
-			} else if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED) &&
-					!ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
+			} else if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED)
+				&& !ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
 				AST_LIST_REMOVE_CURRENT(list);
 				cbu_iter->conference_bridge->activeusers--;
 				AST_LIST_INSERT_TAIL(&cbu_iter->conference_bridge->waiting_list, cbu_iter, list);
 				cbu_iter->conference_bridge->waitingusers++;
-				/* Handle muting/moh of cbu_iter if necessary */
+
+				/* Handle moh of cbu_iter if necessary */
 				if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_MUSICONHOLD)) {
-					cbu_iter->features.mute = 1;
 					conf_moh_start(cbu_iter);
 				}
+				conf_update_user_mute(cbu_iter);
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
@@ -170,7 +173,7 @@
 		conf_handle_first_marked_common(cbu);
 	}
 
-	/* Move all waiting users to active, stopping MOH and umuting if necessary */
+	/* Move all waiting users to active, stopping MOH and unmuting if necessary */
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&cbu->conference_bridge->waiting_list, cbu_iter, list) {
 		AST_LIST_REMOVE_CURRENT(list);
 		cbu->conference_bridge->waitingusers--;
@@ -179,10 +182,7 @@
 		if (cbu_iter->playing_moh) {
 			conf_moh_stop(cbu_iter);
 		}
-		/* only unmute them if they are not supposed to start muted */
-		if (!ast_test_flag(&cbu_iter->u_profile, USER_OPT_STARTMUTED)) {
-			cbu_iter->features.mute = 0;
-		}
+		conf_update_user_mute(cbu_iter);
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 }
--- apps/confbridge/conf_state_single.c
+++ apps/confbridge/conf_state_single.c
@@ -55,6 +55,7 @@
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI);
 }
@@ -63,6 +64,7 @@
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/conf_state_single_marked.c
+++ apps/confbridge/conf_state_single_marked.c
@@ -54,6 +54,7 @@
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
@@ -62,6 +63,7 @@
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -210,7 +210,7 @@
 	unsigned int markedusers;                                         /*!< Number of marked users present */
 	unsigned int waitingusers;                                        /*!< Number of waiting users present */
 	unsigned int locked:1;                                            /*!< Is this conference bridge locked? */
-	unsigned int muted:1;                                            /*!< Is this conference bridge muted? */
+	unsigned int muted:1;                                             /*!< Is this conference bridge muted? */
 	unsigned int record_state:2;                                      /*!< Whether recording is started, stopped, or should exit */
 	struct ast_channel *playback_chan;                                /*!< Channel used for playback into the conference bridge */
 	struct ast_channel *record_chan;                                  /*!< Channel used for recording the conference */
@@ -238,6 +238,7 @@
 	struct ast_bridge_features features;         /*!< Bridge features structure */
 	struct ast_bridge_tech_optimizations tech_args; /*!< Bridge technology optimizations for talk detection */
 	unsigned int suspended_moh;                  /*!< Count of active suspended MOH actions. */
+	unsigned int muted:1;                        /*!< Has the user requested to be muted? */
 	unsigned int kicked:1;                       /*!< User has been kicked from the conference */
 	unsigned int playing_moh:1;                  /*!< MOH is currently being played to the user */
 	AST_LIST_HEAD_NOLOCK(, post_join_action) post_join_list; /*!< List of sounds to play after joining */;
@@ -364,6 +365,15 @@
 void conf_ended(struct conference_bridge *conference_bridge);
 
 /*!
+ * \brief Update the actual mute status of the user and set it on the bridge.
+ *
+ * \param user User to update the mute status.
+ *
+ * \return Nothing
+ */
+void conf_update_user_mute(struct conference_bridge_user *user);
+
+/*!
  * \brief Stop MOH for the conference user.
  *
  * \param user Conference user to stop MOH on.
--- channels/chan_dahdi.c
+++ channels/chan_dahdi.c
@@ -49,7 +49,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401705 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402709 $")
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <pthread.h>
@@ -1800,11 +1800,8 @@
 		 * a failure and die, and returning 2 means no event was received. */
 		res = read(p->subs[index].dfd, buf, sizeof(buf));
 		if (res < 0) {
-			if (errno != ELAST) {
-				ast_log(LOG_WARNING, "read returned error: %s\n", strerror(errno));
-				callerid_free(p->cs);
-				return -1;
-			}
+			ast_log(LOG_WARNING, "read returned error: %s\n", strerror(errno));
+			return -1;
 		}
 
 		if (analog_p->ringt > 0) {
--- channels/chan_iax2.c
+++ channels/chan_iax2.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401016 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
 
 #include <sys/mman.h>
 #include <dirent.h>
@@ -2808,7 +2808,7 @@
  * \brief Schedules delayed removal of iax2_pvt call number data
  *
  * \note After MIN_REUSE_TIME has passed for a destroyed iax2_pvt, the callno is
- * avaliable again, and the address from the previous connection must be decremented
+ * available again, and the address from the previous connection must be decremented
  * from the peercnts table.  This function schedules these operations to take place.
  */
 static void sched_delay_remove(struct sockaddr_in *sin, struct callno_entry *callno_entry)
--- channels/chan_sip.c
+++ channels/chan_sip.c
@@ -210,7 +210,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401884 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403635 $")
 
 #include <signal.h>
 #include <sys/signal.h>
@@ -1619,6 +1619,7 @@
 static void build_callid_pvt(struct sip_pvt *pvt);
 static void change_callid_pvt(struct sip_pvt *pvt, const char *callid);
 static void build_callid_registry(struct sip_registry *reg, const struct ast_sockaddr *ourip, const char *fromdomain);
+static void build_localtag_registry(struct sip_registry *reg);
 static void make_our_tag(struct sip_pvt *pvt);
 static int add_header(struct sip_request *req, const char *var, const char *value);
 static int add_max_forwards(struct sip_pvt *dialog, struct sip_request *req);
@@ -6106,6 +6107,7 @@
 	dialog->chanvars = copy_vars(peer->chanvars);
 	if (peer->fromdomainport)
 		dialog->fromdomainport = peer->fromdomainport;
+	dialog->callingpres = peer->callingpres;
 
 	return 0;
 }
@@ -8576,6 +8578,12 @@
 	ast_string_field_build(reg, callid, "%s@%s", generate_random_string(buf, sizeof(buf)), host);
 }
 
+/*! \brief Build SIP From tag value for REGISTER */
+static void build_localtag_registry(struct sip_registry *reg)
+{
+	ast_string_field_build(reg, localtag, "as%08lx", ast_random());
+}
+
 /*! \brief Make our SIP dialog tag */
 static void make_our_tag(struct sip_pvt *pvt)
 {
@@ -12616,7 +12624,13 @@
 	while ((candidate = ao2_iterator_next(&i))) {
 		ast_str_append(a_buf, 0, "a=candidate:%s %d %s %d ", candidate->foundation, candidate->id, candidate->transport, candidate->priority);
 		ast_str_append(a_buf, 0, "%s ", ast_sockaddr_stringify_host(&candidate->address));
-		ast_str_append(a_buf, 0, "%s typ ", ast_sockaddr_stringify_port(&candidate->address));
+
+		if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_SRFLX
+			&& candidate->id == AST_RTP_ICE_COMPONENT_RTCP) {
+			ast_str_append(a_buf, 0, "%d typ ", ast_sockaddr_port(&candidate->address) + 1);
+		} else {
+			ast_str_append(a_buf, 0, "%s typ ", ast_sockaddr_stringify_port(&candidate->address));
+		}
 
 		if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_HOST) {
 			ast_str_append(a_buf, 0, "host");
@@ -14556,29 +14570,51 @@
 
 				callee = find_ringing_channel(data->device_state_info, p);
 				if (callee) {
+					static char *anonymous = "anonymous";
+					static char *invalid = "anonymous.invalid";
 					char *cid_num;
 					char *connected_num;
 					int need;
+					int cid_num_restricted, connected_num_restricted;
 
 					ast_channel_lock(callee);
+
+					cid_num_restricted = (ast_channel_caller(callee)->id.number.presentation &
+								   AST_PRES_RESTRICTION) == AST_PRES_RESTRICTED;
 					cid_num = S_COR(ast_channel_caller(callee)->id.number.valid,
-						ast_channel_caller(callee)->id.number.str, "");
-					need = strlen(cid_num) + strlen(p->fromdomain) + sizeof("sip:@");
+							S_COR(cid_num_restricted, anonymous,
+							      ast_channel_caller(callee)->id.number.str), "");
+
+					need = strlen(cid_num) + (cid_num_restricted ? strlen(invalid) :
+								  strlen(p->fromdomain)) + sizeof("sip:@");
 					local_target = ast_alloca(need);
-					snprintf(local_target, need, "sip:%s@%s", cid_num, p->fromdomain);
+
+					snprintf(local_target, need, "sip:%s@%s", cid_num,
+						 cid_num_restricted ? invalid : p->fromdomain);
 
 					ast_xml_escape(S_COR(ast_channel_caller(callee)->id.name.valid,
-							     ast_channel_caller(callee)->id.name.str, ""),
+							     S_COR((ast_channel_caller(callee)->id.name.presentation &
+								     AST_PRES_RESTRICTION) == AST_PRES_RESTRICTED, anonymous,
+								   ast_channel_caller(callee)->id.name.str), ""),
 						       local_display, sizeof(local_display));
 
+					connected_num_restricted = (ast_channel_connected(callee)->id.number.presentation &
+								    AST_PRES_RESTRICTION) == AST_PRES_RESTRICTED;
 					connected_num = S_COR(ast_channel_connected(callee)->id.number.valid,
-						ast_channel_connected(callee)->id.number.str, "");
-					need = strlen(connected_num) + strlen(p->fromdomain) + sizeof("sip:@");
+							      S_COR(connected_num_restricted, anonymous,
+								    ast_channel_connected(callee)->id.number.str), "");
+
+					need = strlen(connected_num) + (connected_num_restricted ? strlen(invalid) :
+									strlen(p->fromdomain)) + sizeof("sip:@");
 					remote_target = ast_alloca(need);
-					snprintf(remote_target, need, "sip:%s@%s", connected_num, p->fromdomain);
+
+					snprintf(remote_target, need, "sip:%s@%s", connected_num,
+						 connected_num_restricted ? invalid : p->fromdomain);
 
 					ast_xml_escape(S_COR(ast_channel_connected(callee)->id.name.valid,
-							     ast_channel_connected(callee)->id.name.str, ""),
+							     S_COR((ast_channel_connected(callee)->id.name.presentation &
+								     AST_PRES_RESTRICTION) == AST_PRES_RESTRICTED, anonymous,
+								    ast_channel_connected(callee)->id.name.str), ""),
 						       remote_display, sizeof(remote_display));
 
 					ast_channel_unlock(callee);
@@ -15168,13 +15204,13 @@
 			return 0;
 		} else {
 			p = dialog_ref(r->call, "getting a copy of the r->call dialog in transmit_register");
-			make_our_tag(p);	/* create a new local tag for every register attempt */
 			ast_string_field_set(p, theirtag, NULL);	/* forget their old tag, so we don't match tags when getting response */
 		}
 	} else {
 		/* Build callid for registration if we haven't registered before */
 		if (!r->callid_valid) {
 			build_callid_registry(r, &internip, default_fromdomain);
+			build_localtag_registry(r);
 			r->callid_valid = TRUE;
 		}
 		/* Allocate SIP dialog for registration */
@@ -15182,6 +15218,9 @@
 			ast_log(LOG_WARNING, "Unable to allocate registration transaction (memory or socket error)\n");
 			return 0;
 		}
+
+		/* reset tag to consistent value from registry */
+		ast_string_field_set(p, tag, r->localtag);
 		
 		if (p->do_history) {
 			append_history(p, "RegistryInit", "Account: %s@%s", r->username, r->hostname);
@@ -19019,7 +19058,7 @@
 }
 
 /* the last argument is left-aligned, so we don't need a size anyways */
-#define PEERS_FORMAT2 "%-25.25s %-39.39s %-3.3s %-10.10s %-3.3s %-8s %-11s %-32.32s %s\n"
+#define PEERS_FORMAT2 "%-25.25s %-39.39s %-3.3s %-10.10s %-10.10s %-3.3s %-8s %-11s %-32.32s %s\n"
 
 /*! \brief Used in the sip_show_peers functions to pass parameters */
 struct show_peers_context {
@@ -19081,7 +19120,7 @@
 
 	if (!s) {
 		/* Normal list */
-		ast_cli(fd, PEERS_FORMAT2, "Name/username", "Host", "Dyn", "Forcerport", "ACL", "Port", "Status", "Description", (cont.realtimepeers ? "Realtime" : ""));
+		ast_cli(fd, PEERS_FORMAT2, "Name/username", "Host", "Dyn", "Forcerport", "Comedia", "ACL", "Port", "Status", "Description", (cont.realtimepeers ? "Realtime" : ""));
 	}
 
 	ao2_lock(peers);
@@ -19197,9 +19236,8 @@
 		ast_cli(fd, PEERS_FORMAT2, name,
 		tmp_host,
 		peer->host_dynamic ? " D " : "   ",	/* Dynamic or not? */
-		ast_test_flag(&peer->flags[2], SIP_PAGE3_NAT_AUTO_RPORT) ?
-			ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? " A " : " a " :
-			ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? " N " : "   ",	/* NAT=yes? */
+		force_rport_string(peer->flags),
+		comedia_string(peer->flags),
 		(!ast_acl_list_is_empty(peer->acl)) ? " A " : "   ",       /* permit/deny */
 		tmp_port, status,
 		peer->description ? peer->description : "",
@@ -19230,7 +19268,7 @@
 		ast_sockaddr_isnull(&peer->addr) ? "0" : tmp_port,
 		peer->host_dynamic ? "yes" : "no",	/* Dynamic or not? */
 		ast_test_flag(&peer->flags[2], SIP_PAGE3_NAT_AUTO_RPORT) ? "yes" : "no",
-		ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? "yes" : "no",	/* NAT=yes? */
+		ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? "yes" : "no",
 		ast_test_flag(&peer->flags[2], SIP_PAGE3_NAT_AUTO_COMEDIA) ? "yes" : "no",
 		ast_test_flag(&peer->flags[1], SIP_PAGE2_SYMMETRICRTP) ? "yes" : "no",
 		ast_test_flag(&peer->flags[1], SIP_PAGE2_VIDEOSUPPORT) ? "yes" : "no",	/* VIDEOSUPPORT=yes? */
@@ -30378,6 +30416,10 @@
 	peer->disallowed_methods = sip_cfg.disallowed_methods;
 	peer->transports = default_transports;
 	peer->default_outbound_transport = default_primary_transport;
+	if (peer->outboundproxy) {
+		ao2_ref(peer->outboundproxy, -1);
+		peer->outboundproxy = NULL;
+	}
 }
 
 /*! \brief Create temporary peer (used in autocreatepeer mode) */
--- channels/sip/include/sip.h
+++ channels/sip/include/sip.h
@@ -1406,6 +1406,7 @@
 		AST_STRING_FIELD(md5secret);  /*!< Password in md5 */
 		AST_STRING_FIELD(callback);   /*!< Contact extension */
 		AST_STRING_FIELD(peername);   /*!< Peer registering to */
+		AST_STRING_FIELD(localtag);   /*!< Local tag generated same time as callid */
 	);
 	enum sip_transport transport;   /*!< Transport for this registration UDP, TCP or TLS */
 	int portno;                     /*!< Optional port override */
--- configs/confbridge.conf.sample
+++ configs/confbridge.conf.sample
@@ -62,7 +62,7 @@
                             ;    loose the user will hear themselves briefly each
                             ;    time they begin talking until the dsp has time to
                             ;    establish that they are in fact talking.
-                            ; 2. When talk detection AMI events are enabled, this value 
+                            ; 2. When talk detection AMI events are enabled, this value
                             ;    determines when talking has begun which results in
                             ;    an AMI event to fire.  If this value is set too tight
                             ;    AMI events may be falsely triggered by variants in
@@ -248,6 +248,11 @@
 ; Below is a list of menu actions that can be assigned
 ; to a DTMF sequence.
 ;
+; To have the first DTMF digit in a sequence be the '#' character, you need to
+; escape it.  If it is not escaped then normal config file processing will
+; think it is a directive like #include.  For example:
+; \#1=toggle_mute                      ; Pressing #1 will toggle the mute setting.
+;
 ; A single DTMF sequence can have multiple actions associated with it. This is
 ; accomplished by stringing the actions together and using a ',' as the delimiter.
 ; Example:  Both listening and talking volume is reset when '5' is pressed.
@@ -270,7 +275,7 @@
                                        ; using the '&' character as a delimiter.
 ; toggle_mute      ; Toggle turning on and off mute.  Mute will make the user silent
                    ; to everyone else, but the user will still be able to listen in.
-                   ; continue to collect the dtmf sequence.
+
 ; no_op ; This action does nothing (No Operation). Its only real purpose exists for
         ; being able to reserve a sequence in the config as a menu exit sequence.
 ; decrease_listening_volume ; Decreases the channel's listening volume.
--- funcs/func_db.c
+++ funcs/func_db.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #include <regex.h>
 
--- funcs/func_env.c
+++ funcs/func_env.c
@@ -27,7 +27,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #include <sys/stat.h>   /* stat(2) */
 
--- funcs/func_lock.c
+++ funcs/func_lock.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #include <signal.h>
 
--- funcs/func_realtime.c
+++ funcs/func_realtime.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #include "asterisk/file.h"
 #include "asterisk/channel.h"
--- funcs/func_shell.c
+++ funcs/func_shell.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #include "asterisk/module.h"
 #include "asterisk/channel.h"
--- funcs/func_strings.c
+++ funcs/func_strings.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396310 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404087 $")
 
 #include <regex.h>
 #include <ctype.h>
@@ -353,7 +353,7 @@
 			<parameter name="string" required="true" />
 		</syntax>
 		<description>
-			<para>Example: ${QUOTE(ab"c"de)} will return "abcde"</para>
+			<para>Example: ${QUOTE(ab"c"de)} will return ""ab\"c\"de""</para>
 		</description>
 	</function>
 	<function name="CSV_QUOTE" language="en_US">
--- include/asterisk/rtp_engine.h
+++ include/asterisk/rtp_engine.h
@@ -322,10 +322,16 @@
 	AST_RTP_ICE_CANDIDATE_TYPE_RELAYED, /*!< ICE relayed candidate, which represents the address allocated in TURN server. */
 };
 
+/*! \brief ICE component types */
+enum ast_rtp_ice_component_type {
+	AST_RTP_ICE_COMPONENT_RTP = 1,
+	AST_RTP_ICE_COMPONENT_RTCP = 2,
+};
+
 /*! \brief Structure for an ICE candidate */
 struct ast_rtp_engine_ice_candidate {
 	char *foundation;                     /*!< Foundation identifier */
-	unsigned int id;                      /*!< Component identifier */
+	enum ast_rtp_ice_component_type id;   /*!< Component identifier */
 	char *transport;                      /*!< Transport for the media */
 	int priority;                         /*!< Priority which is used if multiple candidates can be used */
 	struct ast_sockaddr address;          /*!< Address of the candidate */
--- include/asterisk/test.h
+++ include/asterisk/test.h
@@ -45,7 +45,7 @@
 
    Create a callback function for the test using the AST_TEST_DEFINE macro.
 
-   Each defined test has three arguments avaliable to it's test code.
+   Each defined test has three arguments available to it's test code.
        \param struct ast_test_info *info
        \param enum ast_test_command cmd
        \param struct ast_test *test
--- main/asterisk.c
+++ main/asterisk.c
@@ -65,7 +65,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #include "asterisk/_private.h"
 
--- main/channel.c
+++ main/channel.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401179 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
 
 #include "asterisk/_private.h"
 
@@ -5590,7 +5590,7 @@
 			ast_cdr_setaccount(new_chan, oh->account);
 			ast_channel_unlock(new_chan);
 		}
-	} else if (caller) { /* no outgoing helper so use caller if avaliable */
+	} else if (caller) { /* no outgoing helper so use caller if available */
 		call_forward_inherit(new_chan, caller, orig);
 	}
 
@@ -6493,18 +6493,19 @@
 			newvar = ast_var_assign(&varname[1], ast_var_value(current));
 			if (newvar) {
 				AST_LIST_INSERT_TAIL(ast_channel_varshead(child), newvar, entries);
-				ast_debug(1, "Copying soft-transferable variable %s.\n", ast_var_name(newvar));
+				ast_debug(1, "Inheriting variable %s from %s to %s.\n",
+					ast_var_name(newvar), ast_channel_name(parent), ast_channel_name(child));
 			}
 			break;
 		case 2:
 			newvar = ast_var_assign(varname, ast_var_value(current));
 			if (newvar) {
 				AST_LIST_INSERT_TAIL(ast_channel_varshead(child), newvar, entries);
-				ast_debug(1, "Copying hard-transferable variable %s.\n", ast_var_name(newvar));
+				ast_debug(1, "Inheriting variable %s from %s to %s.\n",
+					ast_var_name(newvar), ast_channel_name(parent), ast_channel_name(child));
 			}
 			break;
 		default:
-			ast_debug(1, "Not copying variable %s.\n", ast_var_name(current));
 			break;
 		}
 	}
--- main/config.c
+++ main/config.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402407 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_CONFIG_DIR */
 #include "asterisk/network.h"	/* we do some sockaddr manipulation here */
@@ -1419,14 +1419,26 @@
 	} else {
 		/* Just a line (variable = value) */
 		int object = 0;
+		int is_escaped;
+
 		if (!(*cat)) {
 			ast_log(LOG_WARNING,
 				"parse error: No category context for line %d of %s\n", lineno, configfile);
 			return -1;
 		}
-		c = strchr(cur, '=');
 
-		if (c && c > cur && (*(c - 1) == '+')) {
+		is_escaped = cur[0] == '\\';
+		if (is_escaped) {
+			/* First character is escaped. */
+			++cur;
+			if (cur[0] < 33) {
+				ast_log(LOG_ERROR, "Invalid escape in line %d of %s\n", lineno, configfile);
+				return -1;
+			}
+		}
+		c = strchr(cur + is_escaped, '=');
+
+		if (c && c > cur + is_escaped && (*(c - 1) == '+')) {
 			struct ast_variable *var, *replace = NULL;
 			struct ast_str **str = ast_threadstorage_get(&appendbuf, sizeof(*str));
 
@@ -1462,8 +1474,11 @@
 				object = 1;
 				c++;
 			}
+			cur = ast_strip(cur);
 set_new_variable:
-			if ((v = ast_variable_new(ast_strip(cur), ast_strip(c), S_OR(suggested_include_file, cfg->include_level == 1 ? "" : configfile)))) {
+			if (ast_strlen_zero(cur)) {
+				ast_log(LOG_WARNING, "No variable name in line %d of %s\n", lineno, configfile);
+			} else if ((v = ast_variable_new(cur, ast_strip(c), S_OR(suggested_include_file, cfg->include_level == 1 ? "" : configfile)))) {
 				v->lineno = lineno;
 				v->object = object;
 				*last_cat = 0;
--- main/db.c
+++ main/db.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 375763 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404344 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_DB */
@@ -145,12 +145,14 @@
  * \brief Clean up the prepared SQLite3 statement
  * \note dblock should already be locked prior to calling this method
  */
-static int clean_stmt(sqlite3_stmt *stmt, const char *sql)
+static int clean_stmt(sqlite3_stmt **stmt, const char *sql)
 {
-	if (sqlite3_finalize(stmt) != SQLITE_OK) {
+	if (sqlite3_finalize(*stmt) != SQLITE_OK) {
 		ast_log(LOG_WARNING, "Couldn't finalize statement '%s': %s\n", sql, sqlite3_errmsg(astdb));
+		*stmt = NULL;
 		return -1;
 	}
+	*stmt = NULL;
 	return 0;
 }
 
@@ -160,15 +162,15 @@
  */
 static void clean_statements(void)
 {
-	clean_stmt(get_stmt, get_stmt_sql);
-	clean_stmt(del_stmt, del_stmt_sql);
-	clean_stmt(deltree_stmt, deltree_stmt_sql);
-	clean_stmt(deltree_all_stmt, deltree_all_stmt_sql);
-	clean_stmt(gettree_stmt, gettree_stmt_sql);
-	clean_stmt(gettree_all_stmt, gettree_all_stmt_sql);
-	clean_stmt(showkey_stmt, showkey_stmt_sql);
-	clean_stmt(put_stmt, put_stmt_sql);
-	clean_stmt(create_astdb_stmt, create_astdb_stmt_sql);
+	clean_stmt(&get_stmt, get_stmt_sql);
+	clean_stmt(&del_stmt, del_stmt_sql);
+	clean_stmt(&deltree_stmt, deltree_stmt_sql);
+	clean_stmt(&deltree_all_stmt, deltree_all_stmt_sql);
+	clean_stmt(&gettree_stmt, gettree_stmt_sql);
+	clean_stmt(&gettree_all_stmt, gettree_all_stmt_sql);
+	clean_stmt(&showkey_stmt, showkey_stmt_sql);
+	clean_stmt(&put_stmt, put_stmt_sql);
+	clean_stmt(&create_astdb_stmt, create_astdb_stmt_sql);
 }
 
 static int init_statements(void)
--- main/loader.c
+++ main/loader.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402288 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_MODULE_DIR */
@@ -377,6 +377,24 @@
 }
 
 #ifdef LOADABLE_MODULES
+
+static void close_lib(const char *name, void *lib)
+{
+	char *error;
+
+	if (!lib) {
+		return;
+	}
+
+	/* Clear any existing error */
+	dlerror();
+	if (dlclose(lib)) {
+		error = dlerror();
+		ast_log(AST_LOG_ERROR, "Failure in dlclose for module '%s': %s\n",
+			S_OR(name, "unknown"), S_OR(error, "Unknown error"));
+	}
+}
+
 static void unload_dynamic_module(struct ast_module *mod)
 {
 	void *lib = mod->lib;
@@ -384,9 +402,7 @@
 	/* WARNING: the structure pointed to by mod is going to
 	   disappear when this operation succeeds, so we can't
 	   dereference it */
-
-	if (lib)
-		while (!dlclose(lib));
+	close_lib(ast_module_name(mod), lib);
 }
 
 static enum ast_module_load_result load_resource(const char *resource_name, unsigned int global_symbols_only, struct ast_heap *resource_heap, int required);
@@ -435,7 +451,7 @@
 	if (resource_being_loaded != (mod = AST_LIST_LAST(&module_list))) {
 		ast_log(LOG_WARNING, "Module '%s' did not register itself during load\n", resource_in);
 		/* no, it did not, so close it and return */
-		while (!dlclose(lib));
+		close_lib(resource_in, lib);
 		/* note that the module's destructor will call ast_module_unregister(),
 		   which will free the structure we allocated in resource_being_loaded */
 		return NULL;
@@ -446,7 +462,7 @@
 	/* if we are being asked only to load modules that provide global symbols,
 	   and this one does not, then close it and return */
 	if (global_symbols_only && !wants_global) {
-		while (!dlclose(lib));
+		close_lib(resource_in, lib);
 		return NULL;
 	}
 
@@ -471,7 +487,7 @@
 	}
 #endif
 
-	while (!dlclose(lib));
+	close_lib(resource_in, lib);
 	resource_being_loaded = NULL;
 
 	/* start the load process again */
--- main/manager.c
+++ main/manager.c
@@ -47,7 +47,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398061 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404275 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use various ast_config_AST_* */
@@ -5775,20 +5775,47 @@
 {
 	/* Notify managers of change */
 	char hint[512];
-	int state = info->exten_state;
-
-	/* only interested in device state for this right now */
-	if (info->reason !=  AST_HINT_UPDATE_DEVICE) {
-		return 0;
-	}
 
 	ast_get_hint(hint, sizeof(hint), NULL, 0, NULL, context, exten);
-	/*** DOCUMENTATION
-		<managerEventInstance>
-			<synopsis>Raised when an extension state has changed.</synopsis>
-		</managerEventInstance>
-	***/
-	manager_event(EVENT_FLAG_CALL, "ExtensionStatus", "Exten: %s\r\nContext: %s\r\nHint: %s\r\nStatus: %d\r\n", exten, context, hint, state);
+
+	switch(info->reason) {
+	case AST_HINT_UPDATE_DEVICE:
+		/*** DOCUMENTATION
+			<managerEventInstance>
+				<synopsis>Raised when an extension state has changed.</synopsis>
+			</managerEventInstance>
+		***/
+		manager_event(EVENT_FLAG_CALL, "ExtensionStatus",
+			"Exten: %s\r\n"
+			"Context: %s\r\n"
+			"Hint: %s\r\n"
+			"Status: %d\r\n",
+			exten,
+			context,
+			hint,
+			info->exten_state);
+		break;
+	case AST_HINT_UPDATE_PRESENCE:
+		/*** DOCUMENTATION
+			<managerEventInstance>
+				<synopsis>Raised when a presence state has changed.</synopsis>
+			</managerEventInstance>
+		***/
+		manager_event(EVENT_FLAG_CALL, "PresenceStatus",
+			"Exten: %s\r\n"
+			"Context: %s\r\n"
+			"Hint: %s\r\n"
+			"Status: %s\r\n"
+			"Subtype: %s\r\n"
+			"Message: %s\r\n",
+			exten,
+			context,
+			hint,
+			ast_presence_state2str(info->presence_state),
+			info->presence_subtype,
+			info->presence_message);
+		break;
+	}
 	return 0;
 }
 
--- main/pbx.c
+++ main/pbx.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_SYSTEM_NAME */
@@ -4516,7 +4516,7 @@
 						ast_log(LOG_ERROR, "Unable to allocate bogus channel for variable substitution.  Function results may be blank.\n");
 					}
 				}
-				ast_debug(2, "Function result is '%s'\n", cp4 ? cp4 : "(null)");
+				ast_debug(2, "Function %s result is '%s'\n", finalvars, cp4 ? cp4 : "(null)");
 			} else {
 				/* Retrieve variable value */
 				ast_str_retrieve_variable(&substr3, 0, c, headp, finalvars);
@@ -4715,7 +4715,7 @@
 						ast_log(LOG_ERROR, "Unable to allocate bogus channel for variable substitution.  Function results may be blank.\n");
 					}
 				}
-				ast_debug(2, "Function result is '%s'\n", cp4 ? cp4 : "(null)");
+				ast_debug(2, "Function %s result is '%s'\n", vars, cp4 ? cp4 : "(null)");
 			} else {
 				/* Retrieve variable value */
 				pbx_retrieve_variable(c, vars, &cp4, workspace, VAR_BUF_SIZE, headp);
@@ -4805,25 +4805,6 @@
 	pbx_substitute_variables_helper_full(NULL, headp, cp1, cp2, count, &used);
 }
 
-static void pbx_substitute_variables(char *passdata, int datalen, struct ast_channel *c, struct ast_exten *e)
-{
-	const char *tmp;
-
-	/* Nothing more to do */
-	if (!e->data) {
-		*passdata = '\0';
-		return;
-	}
-
-	/* No variables or expressions in e->data, so why scan it? */
-	if ((!(tmp = strchr(e->data, '$'))) || (!strstr(tmp, "${") && !strstr(tmp, "$["))) {
-		ast_copy_string(passdata, e->data, datalen);
-		return;
-	}
-
-	pbx_substitute_variables_helper(c, e->data, passdata, datalen - 1);
-}
-
 /*!
  * \brief The return value depends on the action:
  *
@@ -4848,6 +4829,7 @@
 {
 	struct ast_exten *e;
 	struct ast_app *app;
+	char *substitute = NULL;
 	int res;
 	struct pbx_find_info q = { .stacklen = 0 }; /* the rest is reset in pbx_find_extension */
 	char passdata[EXT_DATA_SIZE];
@@ -4873,6 +4855,18 @@
 			if (!e->cached_app)
 				e->cached_app = pbx_findapp(e->app);
 			app = e->cached_app;
+			if (ast_strlen_zero(e->data)) {
+				*passdata = '\0';
+			} else {
+				const char *tmp;
+				if ((!(tmp = strchr(e->data, '$'))) || (!strstr(tmp, "${") && !strstr(tmp, "$["))) {
+					/* no variables to substitute, copy on through */
+					ast_copy_string(passdata, e->data, sizeof(passdata));
+				} else {
+					/* save e->data on stack for later processing after lock released */
+					substitute = ast_strdupa(e->data);
+				}
+			}
 			ast_unlock_contexts();
 			if (!app) {
 				ast_log(LOG_WARNING, "No application '%s' for extension (%s, %s, %d)\n", e->app, context, exten, priority);
@@ -4883,7 +4877,9 @@
 			if (ast_channel_exten(c) != exten)
 				ast_channel_exten_set(c, exten);
 			ast_channel_priority_set(c, priority);
-			pbx_substitute_variables(passdata, sizeof(passdata), c, e);
+			if (substitute) {
+				pbx_substitute_variables_helper(c, substitute, passdata, sizeof(passdata)-1);
+			}
 #ifdef CHANNEL_TRACE
 			ast_channel_trace_update(c);
 #endif
--- main/rtp_engine.c
+++ main/rtp_engine.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402042 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
 
 #include <math.h>
 
@@ -2183,7 +2183,7 @@
 	}
 
 	if (map < 0) {
-		ast_log(LOG_WARNING, "No Dynamic RTP mapping avaliable for format %s\n" ,ast_getformatname(format));
+		ast_log(LOG_WARNING, "No Dynamic RTP mapping available for format %s\n" ,ast_getformatname(format));
 		ast_rwlock_unlock(&static_RTP_PT_lock);
 		return;
 	}
--- main/tcptls.c
+++ main/tcptls.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403978 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
 
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
--- main/translate.c
+++ main/translate.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401620 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403015 $")
 
 #include <sys/time.h>
 #include <sys/resource.h>
@@ -521,41 +521,40 @@
 		}
 		out = p->t->frameout(p);
 	}
-	if (consume) {
-		ast_frfree(f);
-	}
-	if (out == NULL) {
-		return NULL;
-	}
-	/* we have a frame, play with times */
-	if (!ast_tvzero(delivery)) {
-		/* Regenerate prediction after a discontinuity */
-		if (ast_tvzero(path->nextout)) {
-			path->nextout = ast_tvnow();
-		}
+	if (out) {
+		/* we have a frame, play with times */
+		if (!ast_tvzero(delivery)) {
+			/* Regenerate prediction after a discontinuity */
+			if (ast_tvzero(path->nextout)) {
+				path->nextout = ast_tvnow();
+			}
 
-		/* Use next predicted outgoing timestamp */
-		out->delivery = path->nextout;
+			/* Use next predicted outgoing timestamp */
+			out->delivery = path->nextout;
 
-		/* Predict next outgoing timestamp from samples in this
-		   frame. */
-		path->nextout = ast_tvadd(path->nextout, ast_samp2tv(out->samples, ast_format_rate(&out->subclass.format)));
-		if (f->samples != out->samples && ast_test_flag(out, AST_FRFLAG_HAS_TIMING_INFO)) {
-			ast_debug(4, "Sample size different %u vs %u\n", f->samples, out->samples);
-			ast_clear_flag(out, AST_FRFLAG_HAS_TIMING_INFO);
+			/* Predict next outgoing timestamp from samples in this
+			   frame. */
+			path->nextout = ast_tvadd(path->nextout, ast_samp2tv(out->samples, ast_format_rate(&out->subclass.format)));
+			if (f->samples != out->samples && ast_test_flag(out, AST_FRFLAG_HAS_TIMING_INFO)) {
+				ast_debug(4, "Sample size different %u vs %u\n", f->samples, out->samples);
+				ast_clear_flag(out, AST_FRFLAG_HAS_TIMING_INFO);
+			}
+		} else {
+			out->delivery = ast_tv(0, 0);
+			ast_set2_flag(out, has_timing_info, AST_FRFLAG_HAS_TIMING_INFO);
+			if (has_timing_info) {
+				out->ts = ts;
+				out->len = len;
+				out->seqno = seqno;
+			}
 		}
-	} else {
-		out->delivery = ast_tv(0, 0);
-		ast_set2_flag(out, has_timing_info, AST_FRFLAG_HAS_TIMING_INFO);
-		if (has_timing_info) {
-			out->ts = ts;
-			out->len = len;
-			out->seqno = seqno;
+		/* Invalidate prediction if we're entering a silence period */
+		if (out->frametype == AST_FRAME_CNG) {
+			path->nextout = ast_tv(0, 0);
 		}
 	}
-	/* Invalidate prediction if we're entering a silence period */
-	if (out->frametype == AST_FRAME_CNG) {
-		path->nextout = ast_tv(0, 0);
+	if (consume) {
+		ast_frfree(f);
 	}
 	return out;
 }
@@ -774,7 +773,7 @@
 						matrix_get(x, z)->table_cost = newtablecost;
 						matrix_get(x, z)->multistep = 1;
 						changed++;
-						ast_debug(3, "Discovered %d cost path from %s to %s, via %s\n",
+						ast_debug(10, "Discovered %d cost path from %s to %s, via %s\n",
 							matrix_get(x, z)->table_cost,
 							ast_getformatname(ast_format_set(&tmpx, index2format(x), 0)),
 							ast_getformatname(ast_format_set(&tmpy, index2format(z), 0)),
--- main/xmldoc.c
+++ main/xmldoc.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402151 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"
@@ -2010,7 +2010,6 @@
 	node = ast_xml_find_element(ast_xml_node_get_children(node), var, NULL, NULL);
 
 	if (!node || !ast_xml_node_get_children(node)) {
-		ast_debug(1, "Cannot find variable '%s' in tree\n", var);
 		return ret;
 	}
 
--- res/res_calendar.c
+++ res/res_calendar.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404136 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/calendar.h"
@@ -766,7 +766,10 @@
 	datastore->inheritance = DATASTORE_INHERIT_FOREVER;
 
 	ao2_ref(event, +1);
+
+	ast_channel_lock(chan);
 	res = ast_channel_datastore_add(chan, datastore);
+	ast_channel_unlock(chan);
 
 	if (!(tmpstr = ast_str_create(32))) {
 		goto notify_cleanup;
--- res/res_fax.c
+++ res/res_fax.c
@@ -56,7 +56,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377657 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404351 $")
 
 #include "asterisk/io.h"
 #include "asterisk/file.h"
@@ -3343,7 +3343,7 @@
 	case AST_FRAME_VOICE:
 		/* we have no DSP this means we not detecting CNG */
 		if (!faxdetect->dsp) {
-			break;
+			return f;
 		}
 		/* We can only process some formats*/
 		switch (f->subclass.format.id) {
--- res/res_fax_spandsp.c
+++ res/res_fax_spandsp.c
@@ -50,7 +50,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 379949 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403450 $")
 
 #define SPANDSP_EXPOSE_INTERNAL_STRUCTURES
 #include <spandsp.h>
@@ -545,7 +545,7 @@
 
 	p->stats = &spandsp_global_stats.g711;
 
-	if (s->details->caps & AST_FAX_TECH_T38) {
+	if (s->details->caps & (AST_FAX_TECH_T38 | AST_FAX_TECH_AUDIO)) {
 		if ((s->details->caps & AST_FAX_TECH_AUDIO) == 0) {
 			/* audio mode was not requested, start in T.38 mode */
 			p->ist38 = 1;
@@ -555,9 +555,7 @@
 		/* init t38 stuff */
 		t38_terminal_init(&p->t38_state, caller_mode, t38_tx_packet_handler, s);
 		set_logging(&p->t38_state.logging, s->details);
-	}
 
-	if (s->details->caps & AST_FAX_TECH_AUDIO) {
 		/* init audio stuff */
 		fax_init(&p->fax_state, caller_mode);
 		set_logging(&p->fax_state.logging, s->details);
--- res/res_rtp_asterisk.c
+++ res/res_rtp_asterisk.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401620 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402345 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -177,9 +177,6 @@
 #define TRANSPORT_TURN_RTP 3
 #define TRANSPORT_TURN_RTCP 4
 
-#define COMPONENT_RTP 1
-#define COMPONENT_RTCP 2
-
 /*! \brief RTP learning mode tracking information */
 struct rtp_learning_info {
 	int max_seq;	/*!< The highest sequence number received */
@@ -541,9 +538,9 @@
 			candidates[cand_cnt].type = PJ_ICE_CAND_TYPE_RELAYED;
 		}
 
-		if (candidate->id == COMPONENT_RTP && rtp->turn_rtp) {
+		if (candidate->id == AST_RTP_ICE_COMPONENT_RTP && rtp->turn_rtp) {
 			pj_turn_sock_set_perm(rtp->turn_rtp, 1, &candidates[cand_cnt].addr, 1);
-		} else if (candidate->id == COMPONENT_RTCP && rtp->turn_rtcp) {
+		} else if (candidate->id == AST_RTP_ICE_COMPONENT_RTCP && rtp->turn_rtcp) {
 			pj_turn_sock_set_perm(rtp->turn_rtcp, 1, &candidates[cand_cnt].addr, 1);
 		}
 
@@ -1478,7 +1475,7 @@
 
 		pj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);
 
-		status = pj_ice_sess_on_rx_pkt(rtp->ice, rtcp ? COMPONENT_RTCP : COMPONENT_RTP,
+		status = pj_ice_sess_on_rx_pkt(rtp->ice, rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,
 			rtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,
 			pj_sockaddr_get_len(&address));
 		if (status != PJ_SUCCESS) {
@@ -1530,7 +1527,7 @@
 	if (rtp->ice) {
 		pj_thread_register_check();
 
-		if (pj_ice_sess_send_data(rtp->ice, rtcp ? COMPONENT_RTCP : COMPONENT_RTP, temp, len) == PJ_SUCCESS) {
+		if (pj_ice_sess_send_data(rtp->ice, rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP, temp, len) == PJ_SUCCESS) {
 			*ice = 1;
 			return 0;
 		}
@@ -1842,7 +1839,7 @@
 		rtp->ice->user_data = rtp;
 
 		/* Add all of the available candidates to the ICE session */
-		rtp_add_candidates_to_ice(instance, rtp, addr, x, COMPONENT_RTP, TRANSPORT_SOCKET_RTP, &ast_rtp_turn_rtp_sock_cb, &rtp->turn_rtp);
+		rtp_add_candidates_to_ice(instance, rtp, addr, x, AST_RTP_ICE_COMPONENT_RTP, TRANSPORT_SOCKET_RTP, &ast_rtp_turn_rtp_sock_cb, &rtp->turn_rtp);
 	}
 #endif
 
@@ -2008,7 +2005,7 @@
 				strerror(errno));
 		}
 #ifdef USE_PJPROJECT
-		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+		update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 		if (rtp_debug_test_addr(&remote_address)) {
 			ast_verbose("Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
@@ -2060,7 +2057,7 @@
 	}
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
@@ -2138,7 +2135,7 @@
 		}
 
 #ifdef USE_PJPROJECT
-		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+		update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 		if (rtp_debug_test_addr(&remote_address)) {
@@ -2304,7 +2301,7 @@
 	rtp->rtcp->rr_count++;
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTCP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTCP, &remote_address);
 #endif
 
 	if (rtcp_debug_test_addr(&remote_address)) {
@@ -2417,7 +2414,7 @@
 	rtp->rtcp->lastsrtxcount = rtp->txcount;
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTCP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTCP, &remote_address);
 #endif
 
 	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
@@ -2608,7 +2605,7 @@
 		}
 
 #ifdef USE_PJPROJECT
-		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+		update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 		if (rtp_debug_test_addr(&remote_address)) {
@@ -3489,7 +3486,7 @@
 	}
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
@@ -3949,7 +3946,7 @@
 
 #ifdef USE_PJPROJECT
 			if (rtp->ice) {
-				rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP,
+				rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP,
 							  &ast_rtp_turn_rtcp_sock_cb, &rtp->turn_rtcp);
 			}
 #endif
@@ -4242,7 +4239,7 @@
 	}
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
