--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 382385 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -3098,7 +3098,7 @@
 {
 	int res = 0;
 
-	if (conf_load_config(0)) {
+	if (conf_load_config()) {
 		ast_log(LOG_ERROR, "Unable to load config. Not loading module.\n");
 		return AST_MODULE_LOAD_DECLINE;
 	}
@@ -3145,7 +3145,7 @@
 
 static int reload(void)
 {
-	return conf_load_config(1);
+	return conf_reload_config();
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Conference Bridge Application",
--- apps/app_meetme.c
+++ apps/app_meetme.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387689 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 393929 $")
 
 #include <dahdi/user.h>
 
@@ -866,17 +866,26 @@
 	/*! This option uses the values in the sla_hold_access enum and sets the
 	 * access control type for hold on this station. */
 	unsigned int hold_access:1;
-	/*! Use count for inside sla_station_exec */
-	unsigned int ref_count;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
+/*!
+ * \brief A reference to a station
+ *
+ * This struct looks near useless at first glance.  However, its existence
+ * in the list of stations in sla_trunk means that this station references
+ * that trunk.  We use the mark to keep track of whether it needs to be
+ * removed from the sla_trunk's list of stations during a reload.
+ */
 struct sla_station_ref {
 	AST_LIST_ENTRY(sla_station_ref) entry;
 	struct sla_station *station;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
 struct sla_trunk {
-	AST_RWLIST_ENTRY(sla_trunk) entry;
 	AST_DECLARE_STRING_FIELDS(
 		AST_STRING_FIELD(name);
 		AST_STRING_FIELD(device);
@@ -900,10 +909,16 @@
 	/*! Whether this trunk is currently on hold, meaning that once a station
 	 *  connects to it, the trunk channel needs to have UNHOLD indicated to it. */
 	unsigned int on_hold:1;
-	/*! Use count for inside sla_trunk_exec */
-	unsigned int ref_count;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
+/*!
+ * \brief A station's reference to a trunk
+ *
+ * An sla_station keeps a list of trunk_refs.  This holds metadata about the
+ * stations usage of the trunk.
+ */
 struct sla_trunk_ref {
 	AST_LIST_ENTRY(sla_trunk_ref) entry;
 	struct sla_trunk *trunk;
@@ -917,10 +932,12 @@
 	 *  station.  This takes higher priority than a ring delay set at
 	 *  the station level. */
 	unsigned int ring_delay;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
-static AST_RWLIST_HEAD_STATIC(sla_stations, sla_station);
-static AST_RWLIST_HEAD_STATIC(sla_trunks, sla_trunk);
+static struct ao2_container *sla_stations;
+static struct ao2_container *sla_trunks;
 
 static const char sla_registrar[] = "SLA";
 
@@ -932,10 +949,6 @@
 	SLA_EVENT_DIAL_STATE,
 	/*! The state of a ringing trunk has changed */
 	SLA_EVENT_RINGING_TRUNK,
-	/*! A reload of configuration has been requested */
-	SLA_EVENT_RELOAD,
-	/*! Poke the SLA thread so it can check if it can perform a reload */
-	SLA_EVENT_CHECK_RELOAD,
 };
 
 struct sla_event {
@@ -991,8 +1004,6 @@
 	/*! Attempt to handle CallerID, even though it is known not to work
 	 *  properly in some situations. */
 	unsigned int attempt_callerid:1;
-	/*! A reload has been requested */
-	unsigned int reload:1;
 } sla = {
 	.thread = AST_PTHREADT_NULL,
 };
@@ -1757,7 +1768,8 @@
 
 static char *sla_show_trunks(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const struct sla_trunk *trunk;
+	struct ao2_iterator i;
+	struct sla_trunk *trunk;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1775,12 +1787,17 @@
 	            "=== Configured SLA Trunks ===================================\n"
 	            "=============================================================\n"
 	            "===\n");
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
+	i = ao2_iterator_init(sla_trunks, 0);
+	for (; (trunk = ao2_iterator_next(&i)); ao2_ref(trunk, -1)) {
 		struct sla_station_ref *station_ref;
 		char ring_timeout[16] = "(none)";
-		if (trunk->ring_timeout)
+
+		ao2_lock(trunk);
+
+		if (trunk->ring_timeout) {
 			snprintf(ring_timeout, sizeof(ring_timeout), "%u Seconds", trunk->ring_timeout);
+		}
+
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n"
 		            "=== Trunk Name:       %s\n"
 		            "=== ==> Device:       %s\n"
@@ -1794,13 +1811,16 @@
 		            ring_timeout,
 		            trunk->barge_disabled ? "No" : "Yes",
 		            sla_hold_str(trunk->hold_access));
-		AST_RWLIST_RDLOCK(&sla_stations);
-		AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry)
+
+		AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
 			ast_cli(a->fd, "===    ==> Station name: %s\n", station_ref->station->name);
-		AST_RWLIST_UNLOCK(&sla_stations);
+		}
+
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n===\n");
+
+		ao2_unlock(trunk);
 	}
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	ao2_iterator_destroy(&i);
 	ast_cli(a->fd, "=============================================================\n\n");
 
 	return CLI_SUCCESS;
@@ -1822,7 +1842,8 @@
 
 static char *sla_show_stations(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const struct sla_station *station;
+	struct ao2_iterator i;
+	struct sla_station *station;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1840,11 +1861,14 @@
 	            "=== Configured SLA Stations =================================\n"
 	            "=============================================================\n"
 	            "===\n");
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	for (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {
 		struct sla_trunk_ref *trunk_ref;
 		char ring_timeout[16] = "(none)";
 		char ring_delay[16] = "(none)";
+
+		ao2_lock(station);
+
 		if (station->ring_timeout) {
 			snprintf(ring_timeout, sizeof(ring_timeout), 
 				"%u", station->ring_timeout);
@@ -1865,7 +1889,6 @@
 		            S_OR(station->autocontext, "(none)"), 
 		            ring_timeout, ring_delay,
 		            sla_hold_str(station->hold_access));
-		AST_RWLIST_RDLOCK(&sla_trunks);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			if (trunk_ref->ring_timeout) {
 				snprintf(ring_timeout, sizeof(ring_timeout),
@@ -1885,11 +1908,12 @@
 			            trunkstate2str(trunk_ref->state),
 			            ring_timeout, ring_delay);
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n"
 		            "===\n");
+
+		ao2_unlock(station);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
+	ao2_iterator_destroy(&i);
 	ast_cli(a->fd, "============================================================\n"
 	            "\n");
 
@@ -2043,11 +2067,16 @@
 	struct sla_event *event;
 
 	if (sla.thread == AST_PTHREADT_NULL) {
+		ao2_ref(station, -1);
+		ao2_ref(trunk_ref, -1);
 		return;
 	}
 
-	if (!(event = ast_calloc(1, sizeof(*event))))
+	if (!(event = ast_calloc(1, sizeof(*event)))) {
+		ao2_ref(station, -1);
+		ao2_ref(trunk_ref, -1);
 		return;
+	}
 
 	event->type = type;
 	event->trunk_ref = trunk_ref;
@@ -2081,6 +2110,7 @@
 	struct sla_station *station;
 	struct sla_trunk_ref *trunk_ref = NULL;
 	char *trunk_name;
+	struct ao2_iterator i;
 
 	trunk_name = ast_strdupa(conf->confno);
 	strsep(&trunk_name, "_");
@@ -2089,16 +2119,23 @@
 		return;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	while ((station = ao2_iterator_next(&i))) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-			if (trunk_ref->chan == chan && !strcmp(trunk_ref->trunk->name, trunk_name))
+			if (trunk_ref->chan == chan && !strcmp(trunk_ref->trunk->name, trunk_name)) {
+				ao2_ref(trunk_ref, 1);
 				break;
+			}
 		}
-		if (trunk_ref)
+		ao2_unlock(station);
+		if (trunk_ref) {
+			/* station reference given to sla_queue_event_full() */
 			break;
+		}
+		ao2_ref(station, -1);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
+	ao2_iterator_destroy(&i);
 
 	if (!trunk_ref) {
 		ast_debug(1, "Trunk not found for event!\n");
@@ -5571,34 +5608,30 @@
 	ast_config_destroy(cfg);
 }
 
-/*! \brief Find an SLA trunk by name
- * \note This must be called with the sla_trunks container locked
+/*!
+ * \internal
+ * \brief Find an SLA trunk by name
  */
 static struct sla_trunk *sla_find_trunk(const char *name)
 {
-	struct sla_trunk *trunk = NULL;
-
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (!strcasecmp(trunk->name, name))
-			break;
-	}
+	struct sla_trunk tmp_trunk = {
+		.name = name,
+	};
 
-	return trunk;
+	return ao2_find(sla_trunks, &tmp_trunk, OBJ_POINTER);
 }
 
-/*! \brief Find an SLA station by name
- * \note This must be called with the sla_stations container locked
+/*!
+ * \internal
+ * \brief Find an SLA station by name
  */
 static struct sla_station *sla_find_station(const char *name)
 {
-	struct sla_station *station = NULL;
-
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
-		if (!strcasecmp(station->name, name))
-			break;
-	}
+	struct sla_station tmp_station = {
+		.name = name,
+	};
 
-	return station;
+	return ao2_find(sla_stations, &tmp_station, OBJ_POINTER);
 }
 
 static int sla_check_station_hold_access(const struct sla_trunk *trunk,
@@ -5622,9 +5655,11 @@
 	return 0;
 }
 
-/*! \brief Find a trunk reference on a station by name
+/*!
+ * \brief Find a trunk reference on a station by name
  * \param station the station
  * \param name the trunk's name
+ * \pre sla_station is locked
  * \return a pointer to the station's trunk reference.  If the trunk
  *         is not found, it is not idle and barge is disabled, or if
  *         it is on hold and private hold is set, then NULL will be returned.
@@ -5651,16 +5686,32 @@
 		break;
 	}
 
+	if (trunk_ref) {
+		ao2_ref(trunk_ref, 1);
+	}
+
 	return trunk_ref;
 }
 
+static void sla_station_ref_destructor(void *obj)
+{
+	struct sla_station_ref *station_ref = obj;
+
+	if (station_ref->station) {
+		ao2_ref(station_ref->station, -1);
+		station_ref->station = NULL;
+	}
+}
+
 static struct sla_station_ref *sla_create_station_ref(struct sla_station *station)
 {
 	struct sla_station_ref *station_ref;
 
-	if (!(station_ref = ast_calloc(1, sizeof(*station_ref))))
+	if (!(station_ref = ao2_alloc(sizeof(*station_ref), sla_station_ref_destructor))) {
 		return NULL;
+	}
 
+	ao2_ref(station, 1);
 	station_ref->station = station;
 
 	return station_ref;
@@ -5673,12 +5724,48 @@
 	if (!(ringing_station = ast_calloc(1, sizeof(*ringing_station))))
 		return NULL;
 
+	ao2_ref(station, 1);
 	ringing_station->station = station;
 	ringing_station->ring_begin = ast_tvnow();
 
 	return ringing_station;
 }
 
+static void sla_ringing_station_destroy(struct sla_ringing_station *ringing_station)
+{
+	if (ringing_station->station) {
+		ao2_ref(ringing_station->station, -1);
+		ringing_station->station = NULL;
+	}
+
+	ast_free(ringing_station);
+}
+
+static struct sla_failed_station *sla_create_failed_station(struct sla_station *station)
+{
+	struct sla_failed_station *failed_station;
+
+	if (!(failed_station = ast_calloc(1, sizeof(*failed_station)))) {
+		return NULL;
+	}
+
+	ao2_ref(station, 1);
+	failed_station->station = station;
+	failed_station->last_try = ast_tvnow();
+
+	return failed_station;
+}
+
+static void sla_failed_station_destroy(struct sla_failed_station *failed_station)
+{
+	if (failed_station->station) {
+		ao2_ref(failed_station->station, -1);
+		failed_station->station = NULL;
+	}
+
+	ast_free(failed_station);
+}
+
 static enum ast_device_state sla_state_to_devstate(enum sla_trunk_state state)
 {
 	switch (state) {
@@ -5701,18 +5788,25 @@
 {
 	struct sla_station *station;
 	struct sla_trunk_ref *trunk_ref;
+	struct ao2_iterator i;
 
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	while ((station = ao2_iterator_next(&i))) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			if (trunk_ref->trunk != trunk || (inactive_only ? trunk_ref->chan : 0)
-				|| trunk_ref == exclude)
+					|| trunk_ref == exclude) {
 				continue;
+			}
 			trunk_ref->state = state;
 			ast_devstate_changed(sla_state_to_devstate(state), AST_DEVSTATE_CACHABLE,
 					     "SLA:%s_%s", station->name, trunk->name);
 			break;
 		}
+		ao2_unlock(station);
+		ao2_ref(station, -1);
 	}
+	ao2_iterator_destroy(&i);
 }
 
 struct run_station_args {
@@ -5730,8 +5824,8 @@
 
 static void *run_station(void *data)
 {
-	struct sla_station *station;
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	struct ast_str *conf_name = ast_str_create(16);
 	struct ast_flags64 conf_flags = { 0 };
 	struct ast_conference *conf;
@@ -5774,6 +5868,8 @@
 	return NULL;
 }
 
+static void sla_ringing_trunk_destroy(struct sla_ringing_trunk *ringing_trunk);
+
 static void sla_stop_ringing_trunk(struct sla_ringing_trunk *ringing_trunk)
 {
 	char buf[80];
@@ -5783,10 +5879,11 @@
 	admin_exec(NULL, buf);
 	sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
 
-	while ((station_ref = AST_LIST_REMOVE_HEAD(&ringing_trunk->timed_out_stations, entry)))
-		ast_free(station_ref);
+	while ((station_ref = AST_LIST_REMOVE_HEAD(&ringing_trunk->timed_out_stations, entry))) {
+		ao2_ref(station_ref, -1);
+	}
 
-	ast_free(ringing_trunk);
+	sla_ringing_trunk_destroy(ringing_trunk);
 }
 
 static void sla_stop_ringing_station(struct sla_ringing_station *ringing_station,
@@ -5821,7 +5918,7 @@
 	}
 
 done:
-	ast_free(ringing_station);
+	sla_ringing_station_destroy(ringing_station);
 }
 
 static void sla_dial_state_callback(struct ast_dial *dial)
@@ -5873,8 +5970,10 @@
 			if (rm)
 				AST_LIST_REMOVE_CURRENT(entry);
 
-			if (trunk_ref)
+			if (trunk_ref) {
+				ao2_ref(s_trunk_ref, 1);
 				*trunk_ref = s_trunk_ref;
+			}
 
 			break;
 		}
@@ -5892,7 +5991,7 @@
 	struct sla_ringing_station *ringing_station;
 
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_stations, ringing_station, entry) {
-		struct sla_trunk_ref *s_trunk_ref = NULL;
+		RAII_VAR(struct sla_trunk_ref *, s_trunk_ref, NULL, ao2_cleanup);
 		struct sla_ringing_trunk *ringing_trunk = NULL;
 		struct run_station_args args;
 		enum ast_dial_result dial_res;
@@ -5925,7 +6024,7 @@
 				ast_dial_join(ringing_station->station->dial);
 				ast_dial_destroy(ringing_station->station->dial);
 				ringing_station->station->dial = NULL;
-				ast_free(ringing_station);
+				sla_ringing_station_destroy(ringing_station);
 				break;
 			}
 			/* Track the channel that answered this trunk */
@@ -5936,12 +6035,14 @@
 			/* Now, start a thread that will connect this station to the trunk.  The rest of
 			 * the code here sets up the thread and ensures that it is able to save the arguments
 			 * before they are no longer valid since they are allocated on the stack. */
+			ao2_ref(s_trunk_ref, 1);
 			args.trunk_ref = s_trunk_ref;
+			ao2_ref(ringing_station->station, 1);
 			args.station = ringing_station->station;
 			args.cond = &cond;
 			args.cond_lock = &cond_lock;
-			ast_free(ringing_trunk);
-			ast_free(ringing_station);
+			sla_ringing_trunk_destroy(ringing_trunk);
+			sla_ringing_station_destroy(ringing_station);
 			ast_mutex_init(&cond_lock);
 			ast_cond_init(&cond, NULL);
 			ast_mutex_lock(&cond_lock);
@@ -5995,7 +6096,7 @@
 			continue;
 		if (ast_tvdiff_ms(ast_tvnow(), failed_station->last_try) > 1000) {
 			AST_LIST_REMOVE_CURRENT(entry);
-			ast_free(failed_station);
+			sla_failed_station_destroy(failed_station);
 			break;
 		}
 		res = 1;
@@ -6048,11 +6149,9 @@
 	if (res != AST_DIAL_RESULT_TRYING) {
 		struct sla_failed_station *failed_station;
 		ast_dial_destroy(dial);
-		if (!(failed_station = ast_calloc(1, sizeof(*failed_station))))
-			return -1;
-		failed_station->station = station;
-		failed_station->last_try = ast_tvnow();
-		AST_LIST_INSERT_HEAD(&sla.failed_stations, failed_station, entry);
+		if ((failed_station = sla_create_failed_station(station))) {
+			AST_LIST_INSERT_HEAD(&sla.failed_stations, failed_station, entry);
+		}
 		return -1;
 	}
 	if (!(ringing_station = sla_create_ringing_station(station))) {
@@ -6092,6 +6191,8 @@
 			break;
 	}
 
+	ao2_ref(trunk_ref, 1);
+
 	return trunk_ref;
 }
 
@@ -6103,7 +6204,7 @@
 static int sla_check_station_delay(struct sla_station *station, 
 	struct sla_ringing_trunk *ringing_trunk)
 {
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	unsigned int delay = UINT_MAX;
 	int time_left, time_elapsed;
 
@@ -6196,7 +6297,7 @@
 			ast_dial_join(ringing_station->station->dial);
 			ast_dial_destroy(ringing_station->station->dial);
 			ringing_station->station->dial = NULL;
-			ast_free(ringing_station);
+			sla_ringing_station_destroy(ringing_station);
 		}
 	}
 	AST_LIST_TRAVERSE_SAFE_END
@@ -6353,8 +6454,10 @@
 {
 	struct sla_station *station;
 	int res = 0;
+	struct ao2_iterator i;
 
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	for (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {
 		struct sla_ringing_trunk *ringing_trunk;
 		int time_left;
 
@@ -6384,6 +6487,7 @@
 		if (time_left < *timeout)
 			*timeout = time_left;
 	}
+	ao2_iterator_destroy(&i);
 
 	return res;
 }
@@ -6425,50 +6529,19 @@
 	return 1;
 }
 
-static int sla_load_config(int reload);
-
-/*! \brief Check if we can do a reload of SLA, and do it if we can */
-static void sla_check_reload(void)
+static void sla_event_destroy(struct sla_event *event)
 {
-	struct sla_station *station;
-	struct sla_trunk *trunk;
-
-	ast_mutex_lock(&sla.lock);
-
-	if (!AST_LIST_EMPTY(&sla.event_q) || !AST_LIST_EMPTY(&sla.ringing_trunks)
-		|| !AST_LIST_EMPTY(&sla.ringing_stations) || !AST_LIST_EMPTY(&sla.failed_stations)) {
-		ast_mutex_unlock(&sla.lock);
-		return;
+	if (event->trunk_ref) {
+		ao2_ref(event->trunk_ref, -1);
+		event->trunk_ref = NULL;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
-		if (station->ref_count)
-			break;
-	}
-	AST_RWLIST_UNLOCK(&sla_stations);
-	if (station) {
-		ast_mutex_unlock(&sla.lock);
-		return;
+	if (event->station) {
+		ao2_ref(event->station, -1);
+		event->station = NULL;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (trunk->ref_count || trunk->chan || trunk->active_stations || trunk->hold_stations) {
-			break;
-		}
-	}
-	AST_RWLIST_UNLOCK(&sla_trunks);
-	if (trunk) {
-		ast_mutex_unlock(&sla.lock);
-		return;
-	}
-
-	/* yay */
-	sla_load_config(1);
-	sla.reload = 0;
-
-	ast_mutex_unlock(&sla.lock);
+	ast_free(event);
 }
 
 static void *sla_thread(void *data)
@@ -6507,27 +6580,21 @@
 			case SLA_EVENT_RINGING_TRUNK:
 				sla_handle_ringing_trunk_event();
 				break;
-			case SLA_EVENT_RELOAD:
-				sla.reload = 1;
-			case SLA_EVENT_CHECK_RELOAD:
-				break;
 			}
-			ast_free(event);
+			sla_event_destroy(event);
 			ast_mutex_lock(&sla.lock);
 		}
-
-		if (sla.reload) {
-			sla_check_reload();
-		}
 	}
 
 	ast_mutex_unlock(&sla.lock);
 
-	while ((ringing_station = AST_LIST_REMOVE_HEAD(&sla.ringing_stations, entry)))
-		ast_free(ringing_station);
+	while ((ringing_station = AST_LIST_REMOVE_HEAD(&sla.ringing_stations, entry))) {
+		sla_ringing_station_destroy(ringing_station);
+	}
 
-	while ((failed_station = AST_LIST_REMOVE_HEAD(&sla.failed_stations, entry)))
-		ast_free(failed_station);
+	while ((failed_station = AST_LIST_REMOVE_HEAD(&sla.failed_stations, entry))) {
+		sla_failed_station_destroy(failed_station);
+	}
 
 	return NULL;
 }
@@ -6548,7 +6615,8 @@
 	char conf_name[MAX_CONFNUM];
 	struct ast_conference *conf;
 	struct ast_flags64 conf_flags = { 0 };
-	struct sla_trunk_ref *trunk_ref = args->trunk_ref;
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, args->trunk_ref, ao2_cleanup);
+	RAII_VAR(struct sla_station *, station, args->station, ao2_cleanup);
 	int caller_is_saved;
 	struct ast_party_caller caller;
 	int last_state = 0;
@@ -6620,8 +6688,8 @@
 			break;
 
 		/* check that SLA station that originated trunk call is still alive */
-		if (args->station && ast_device_state(args->station->device) == AST_DEVICE_NOT_INUSE) {
-			ast_debug(3, "Originating station device %s no longer active\n", args->station->device);
+		if (station && ast_device_state(station->device) == AST_DEVICE_NOT_INUSE) {
+			ast_debug(3, "Originating station device %s no longer active\n", station->device);
 			trunk_ref->trunk->chan = NULL;
 			break;
 		}
@@ -6674,15 +6742,19 @@
 	return NULL;
 }
 
-/*! \brief For a given station, choose the highest priority idle trunk
+/*!
+ * \brief For a given station, choose the highest priority idle trunk
+ * \pre sla_station is locked
  */
 static struct sla_trunk_ref *sla_choose_idle_trunk(const struct sla_station *station)
 {
 	struct sla_trunk_ref *trunk_ref = NULL;
 
 	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-		if (trunk_ref->state == SLA_TRUNK_STATE_IDLE)
+		if (trunk_ref->state == SLA_TRUNK_STATE_IDLE) {
+			ao2_ref(trunk_ref, 1);
 			break;
+		}
 	}
 
 	return trunk_ref;
@@ -6691,8 +6763,8 @@
 static int sla_station_exec(struct ast_channel *chan, const char *data)
 {
 	char *station_name, *trunk_name;
-	struct sla_station *station;
-	struct sla_trunk_ref *trunk_ref = NULL;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	char conf_name[MAX_CONFNUM];
 	struct ast_flags64 conf_flags = { 0 };
 	struct ast_conference *conf;
@@ -6712,25 +6784,21 @@
 		return 0;
 	}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
 	station = sla_find_station(station_name);
-	if (station)
-		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
-	AST_RWLIST_UNLOCK(&sla_stations);
 
 	if (!station) {
 		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);
 		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 		return 0;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_trunks);
+	ao2_lock(station);
 	if (!ast_strlen_zero(trunk_name)) {
 		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);
-	} else
+	} else {
 		trunk_ref = sla_choose_idle_trunk(station);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	}
+	ao2_unlock(station);
 
 	if (!trunk_ref) {
 		if (ast_strlen_zero(trunk_name))
@@ -6740,8 +6808,6 @@
 				"'%s' due to access controls.\n", trunk_name);
 		}
 		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
-		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 		return 0;
 	}
 
@@ -6770,7 +6836,7 @@
 			answer_trunk_chan(ringing_trunk->trunk->chan);
 			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
 
-			free(ringing_trunk);
+			sla_ringing_trunk_destroy(ringing_trunk);
 
 			/* Queue up reprocessing ringing trunks, and then ringing stations again */
 			sla_queue_event(SLA_EVENT_RINGING_TRUNK);
@@ -6790,6 +6856,8 @@
 			.cond_lock = &cond_lock,
 			.cond = &cond,
 		};
+		ao2_ref(trunk_ref, 1);
+		ao2_ref(station, 1);
 		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
 		/* Create a thread to dial the trunk and dump it into the conference.
 		 * However, we want to wait until the trunk has been dialed and the
@@ -6809,8 +6877,6 @@
 			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
 			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
 			trunk_ref->chan = NULL;
-			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-			sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 			return 0;
 		}
 	}
@@ -6843,19 +6909,28 @@
 	
 	pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "SUCCESS");
 
-	ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-	sla_queue_event(SLA_EVENT_CHECK_RELOAD);
-
 	return 0;
 }
 
+static void sla_trunk_ref_destructor(void *obj)
+{
+	struct sla_trunk_ref *trunk_ref = obj;
+
+	if (trunk_ref->trunk) {
+		ao2_ref(trunk_ref->trunk, -1);
+		trunk_ref->trunk = NULL;
+	}
+}
+
 static struct sla_trunk_ref *create_trunk_ref(struct sla_trunk *trunk)
 {
 	struct sla_trunk_ref *trunk_ref;
 
-	if (!(trunk_ref = ast_calloc(1, sizeof(*trunk_ref))))
+	if (!(trunk_ref = ao2_alloc(sizeof(*trunk_ref), sla_trunk_ref_destructor))) {
 		return NULL;
+	}
 
+	ao2_ref(trunk, 1);
 	trunk_ref->trunk = trunk;
 
 	return trunk_ref;
@@ -6865,9 +6940,11 @@
 {
 	struct sla_ringing_trunk *ringing_trunk;
 
-	if (!(ringing_trunk = ast_calloc(1, sizeof(*ringing_trunk))))
+	if (!(ringing_trunk = ast_calloc(1, sizeof(*ringing_trunk)))) {
 		return NULL;
-	
+	}
+
+	ao2_ref(trunk, 1);
 	ringing_trunk->trunk = trunk;
 	ringing_trunk->ring_begin = ast_tvnow();
 
@@ -6882,6 +6959,16 @@
 	return ringing_trunk;
 }
 
+static void sla_ringing_trunk_destroy(struct sla_ringing_trunk *ringing_trunk)
+{
+	if (ringing_trunk->trunk) {
+		ao2_ref(ringing_trunk->trunk, -1);
+		ringing_trunk->trunk = NULL;
+	}
+
+	ast_free(ringing_trunk);
+}
+
 enum {
 	SLA_TRUNK_OPT_MOH = (1 << 0),
 };
@@ -6900,7 +6987,7 @@
 	char conf_name[MAX_CONFNUM];
 	struct ast_conference *conf;
 	struct ast_flags64 conf_flags = { 0 };
-	struct sla_trunk *trunk;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
 	struct sla_ringing_trunk *ringing_trunk;
 	AST_DECLARE_APP_ARGS(args,
 		AST_APP_ARG(trunk_name);
@@ -6924,16 +7011,11 @@
 		}
 	}
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
 	trunk = sla_find_trunk(args.trunk_name);
-	if (trunk)
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, 1);
-	AST_RWLIST_UNLOCK(&sla_trunks);
 
 	if (!trunk) {
 		ast_log(LOG_ERROR, "SLA Trunk '%s' not found!\n", args.trunk_name);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6941,8 +7023,6 @@
 		ast_log(LOG_ERROR, "Call came in on %s, but the trunk is already in use!\n",
 			args.trunk_name);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6950,8 +7030,6 @@
 
 	if (!(ringing_trunk = queue_ringing_trunk(trunk))) {
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6959,8 +7037,6 @@
 	conf = build_conf(conf_name, "", "", 1, 1, 1, chan, NULL);
 	if (!conf) {
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 	ast_set_flag64(&conf_flags, 
@@ -6994,46 +7070,37 @@
 	AST_LIST_TRAVERSE_SAFE_END;
 	ast_mutex_unlock(&sla.lock);
 	if (ringing_trunk) {
-		ast_free(ringing_trunk);
+		sla_ringing_trunk_destroy(ringing_trunk);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "UNANSWERED");
 		/* Queue reprocessing of ringing trunks to make stations stop ringing
 		 * that shouldn't be ringing after this trunk stopped. */
 		sla_queue_event(SLA_EVENT_RINGING_TRUNK);
 	}
 
-	ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-	sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
-
 	return 0;
 }
 
 static enum ast_device_state sla_state(const char *data)
 {
 	char *buf, *station_name, *trunk_name;
-	struct sla_station *station;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
 	struct sla_trunk_ref *trunk_ref;
 	enum ast_device_state res = AST_DEVICE_INVALID;
 
 	trunk_name = buf = ast_strdupa(data);
 	station_name = strsep(&trunk_name, "_");
 
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
-		if (strcasecmp(station_name, station->name))
-			continue;
-		AST_RWLIST_RDLOCK(&sla_trunks);
+	station = sla_find_station(station_name);
+	if (station) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-			if (!strcasecmp(trunk_name, trunk_ref->trunk->name))
+			if (!strcasecmp(trunk_name, trunk_ref->trunk->name)) {
+				res = sla_state_to_devstate(trunk_ref->state);
 				break;
+			}
 		}
-		if (!trunk_ref) {
-			AST_RWLIST_UNLOCK(&sla_trunks);
-			break;
-		}
-		res = sla_state_to_devstate(trunk_ref->state);
-		AST_RWLIST_UNLOCK(&sla_trunks);
+		ao2_unlock(station);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
 
 	if (res == AST_DEVICE_INVALID) {
 		ast_log(LOG_ERROR, "Could not determine state for trunk %s on station %s!\n",
@@ -7043,26 +7110,39 @@
 	return res;
 }
 
-static void destroy_trunk(struct sla_trunk *trunk)
+static int sla_trunk_release_refs(void *obj, void *arg, int flags)
 {
+	struct sla_trunk *trunk = obj;
 	struct sla_station_ref *station_ref;
 
-	if (!ast_strlen_zero(trunk->autocontext))
-		ast_context_remove_extension(trunk->autocontext, "s", 1, sla_registrar);
-
-	while ((station_ref = AST_LIST_REMOVE_HEAD(&trunk->stations, entry)))
-		ast_free(station_ref);
+	while ((station_ref = AST_LIST_REMOVE_HEAD(&trunk->stations, entry))) {
+		ao2_ref(station_ref, -1);
+	}
 
-	ast_string_field_free_memory(trunk);
-	ast_free(trunk);
+	return 0;
 }
 
-static void destroy_station(struct sla_station *station)
+static int sla_station_release_refs(void *obj, void *arg, int flags)
 {
+	struct sla_station *station = obj;
 	struct sla_trunk_ref *trunk_ref;
 
+	while ((trunk_ref = AST_LIST_REMOVE_HEAD(&station->trunks, entry))) {
+		ao2_ref(trunk_ref, -1);
+	}
+
+	return 0;
+}
+
+static void sla_station_destructor(void *obj)
+{
+	struct sla_station *station = obj;
+
+	ast_debug(1, "sla_station destructor for '%s'\n", station->name);
+
 	if (!ast_strlen_zero(station->autocontext)) {
-		AST_RWLIST_RDLOCK(&sla_trunks);
+		struct sla_trunk_ref *trunk_ref;
+
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			char exten[AST_MAX_EXTENSION];
 			char hint[AST_MAX_APP];
@@ -7073,31 +7153,43 @@
 			ast_context_remove_extension(station->autocontext, hint, 
 				PRIORITY_HINT, sla_registrar);
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 	}
 
-	while ((trunk_ref = AST_LIST_REMOVE_HEAD(&station->trunks, entry)))
-		ast_free(trunk_ref);
+	sla_station_release_refs(station, NULL, 0);
 
 	ast_string_field_free_memory(station);
-	ast_free(station);
 }
 
-static void sla_destroy(void)
+static int sla_trunk_hash(const void *obj, const int flags)
 {
-	struct sla_trunk *trunk;
-	struct sla_station *station;
+	const struct sla_trunk *trunk = obj;
+
+	return ast_str_case_hash(trunk->name);
+}
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	while ((trunk = AST_RWLIST_REMOVE_HEAD(&sla_trunks, entry)))
-		destroy_trunk(trunk);
-	AST_RWLIST_UNLOCK(&sla_trunks);
-
-	AST_RWLIST_WRLOCK(&sla_stations);
-	while ((station = AST_RWLIST_REMOVE_HEAD(&sla_stations, entry)))
-		destroy_station(station);
-	AST_RWLIST_UNLOCK(&sla_stations);
+static int sla_trunk_cmp(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj, *trunk2 = arg;
 
+	return !strcasecmp(trunk->name, trunk2->name) ? CMP_MATCH | CMP_STOP : 0;
+}
+
+static int sla_station_hash(const void *obj, const int flags)
+{
+	const struct sla_station *station = obj;
+
+	return ast_str_case_hash(station->name);
+}
+
+static int sla_station_cmp(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj, *station2 = arg;
+
+	return !strcasecmp(station->name, station2->name) ? CMP_MATCH | CMP_STOP : 0;
+}
+
+static void sla_destroy(void)
+{
 	if (sla.thread != AST_PTHREADT_NULL) {
 		ast_mutex_lock(&sla.lock);
 		sla.stop = 1;
@@ -7111,6 +7203,15 @@
 
 	ast_mutex_destroy(&sla.lock);
 	ast_cond_destroy(&sla.cond);
+
+	ao2_callback(sla_trunks, 0, sla_trunk_release_refs, NULL);
+	ao2_callback(sla_stations, 0, sla_station_release_refs, NULL);
+
+	ao2_ref(sla_trunks, -1);
+	sla_trunks = NULL;
+
+	ao2_ref(sla_stations, -1);
+	sla_stations = NULL;
 }
 
 static int sla_check_device(const char *device)
@@ -7126,11 +7227,27 @@
 	return 0;
 }
 
+static void sla_trunk_destructor(void *obj)
+{
+	struct sla_trunk *trunk = obj;
+
+	ast_debug(1, "sla_trunk destructor for '%s'\n", trunk->name);
+
+	if (!ast_strlen_zero(trunk->autocontext)) {
+		ast_context_remove_extension(trunk->autocontext, "s", 1, sla_registrar);
+	}
+
+	sla_trunk_release_refs(trunk, NULL, 0);
+
+	ast_string_field_free_memory(trunk);
+}
+
 static int sla_build_trunk(struct ast_config *cfg, const char *cat)
 {
-	struct sla_trunk *trunk;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
 	struct ast_variable *var;
 	const char *dev;
+	int existing_trunk = 0;
 
 	if (!(dev = ast_variable_retrieve(cfg, cat, "device"))) {
 		ast_log(LOG_ERROR, "SLA Trunk '%s' defined with no device!\n", cat);
@@ -7138,16 +7255,25 @@
 	}
 
 	if (sla_check_device(dev)) {
-		ast_log(LOG_ERROR, "SLA Trunk '%s' define with invalid device '%s'!\n",
+		ast_log(LOG_ERROR, "SLA Trunk '%s' defined with invalid device '%s'!\n",
 			cat, dev);
 		return -1;
 	}
 
-	if (!(trunk = ast_calloc_with_stringfields(1, struct sla_trunk, 32))) {
+	if ((trunk = sla_find_trunk(cat))) {
+		trunk->mark = 0;
+		existing_trunk = 1;
+	} else if ((trunk = ao2_alloc(sizeof(*trunk), sla_trunk_destructor))) {
+		if (ast_string_field_init(trunk, 32)) {
+			return -1;
+		}
+		ast_string_field_set(trunk, name, cat);
+	} else {
 		return -1;
 	}
 
-	ast_string_field_set(trunk, name, cat);
+	ao2_lock(trunk);
+
 	ast_string_field_set(trunk, device, dev);
 
 	for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
@@ -7176,54 +7302,65 @@
 		}
 	}
 
+	ao2_unlock(trunk);
+
 	if (!ast_strlen_zero(trunk->autocontext)) {
 		struct ast_context *context;
 		context = ast_context_find_or_create(NULL, NULL, trunk->autocontext, sla_registrar);
 		if (!context) {
 			ast_log(LOG_ERROR, "Failed to automatically find or create "
 				"context '%s' for SLA!\n", trunk->autocontext);
-			destroy_trunk(trunk);
 			return -1;
 		}
 		if (ast_add_extension2(context, 0 /* don't replace */, "s", 1,
 			NULL, NULL, slatrunk_app, ast_strdup(trunk->name), ast_free_ptr, sla_registrar)) {
 			ast_log(LOG_ERROR, "Failed to automatically create extension "
 				"for trunk '%s'!\n", trunk->name);
-			destroy_trunk(trunk);
 			return -1;
 		}
 	}
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	AST_RWLIST_INSERT_TAIL(&sla_trunks, trunk, entry);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	if (!existing_trunk) {
+		ao2_link(sla_trunks, trunk);
+	}
 
 	return 0;
 }
 
+/*!
+ * \internal
+ * \pre station is not locked
+ */
 static void sla_add_trunk_to_station(struct sla_station *station, struct ast_variable *var)
 {
-	struct sla_trunk *trunk;
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
+	struct sla_trunk_ref *trunk_ref = NULL;
 	struct sla_station_ref *station_ref;
 	char *trunk_name, *options, *cur;
+	int existing_trunk_ref = 0;
+	int existing_station_ref = 0;
 
 	options = ast_strdupa(var->value);
 	trunk_name = strsep(&options, ",");
-	
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (!strcasecmp(trunk->name, trunk_name))
-			break;
-	}
 
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	trunk = sla_find_trunk(trunk_name);
 	if (!trunk) {
 		ast_log(LOG_ERROR, "Trunk '%s' not found!\n", var->value);
 		return;
 	}
-	if (!(trunk_ref = create_trunk_ref(trunk)))
+
+	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
+		if (trunk_ref->trunk == trunk) {
+			trunk_ref->mark = 0;
+			existing_trunk_ref = 1;
+			break;
+		}
+	}
+
+	if (!trunk_ref && !(trunk_ref = create_trunk_ref(trunk))) {
 		return;
+	}
+
 	trunk_ref->state = SLA_TRUNK_STATE_IDLE;
 
 	while ((cur = strsep(&options, ","))) {
@@ -7247,41 +7384,73 @@
 		}
 	}
 
-	if (!(station_ref = sla_create_station_ref(station))) {
-		ast_free(trunk_ref);
+	AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
+		if (station_ref->station == station) {
+			station_ref->mark = 0;
+			existing_station_ref = 1;
+			break;
+		}
+	}
+
+	if (!station_ref && !(station_ref = sla_create_station_ref(station))) {
+		if (!existing_trunk_ref) {
+			ao2_ref(trunk_ref, -1);
+		} else {
+			trunk_ref->mark = 1;
+		}
 		return;
 	}
-	ast_atomic_fetchadd_int((int *) &trunk->num_stations, 1);
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	AST_LIST_INSERT_TAIL(&trunk->stations, station_ref, entry);
-	AST_RWLIST_UNLOCK(&sla_trunks);
-	AST_LIST_INSERT_TAIL(&station->trunks, trunk_ref, entry);
+
+	if (!existing_station_ref) {
+		ao2_lock(trunk);
+		AST_LIST_INSERT_TAIL(&trunk->stations, station_ref, entry);
+		ast_atomic_fetchadd_int((int *) &trunk->num_stations, 1);
+		ao2_unlock(trunk);
+	}
+
+	if (!existing_trunk_ref) {
+		ao2_lock(station);
+		AST_LIST_INSERT_TAIL(&station->trunks, trunk_ref, entry);
+		ao2_unlock(station);
+	}
 }
 
 static int sla_build_station(struct ast_config *cfg, const char *cat)
 {
-	struct sla_station *station;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
 	struct ast_variable *var;
 	const char *dev;
+	int existing_station = 0;
 
 	if (!(dev = ast_variable_retrieve(cfg, cat, "device"))) {
 		ast_log(LOG_ERROR, "SLA Station '%s' defined with no device!\n", cat);
 		return -1;
 	}
 
-	if (!(station = ast_calloc_with_stringfields(1, struct sla_station, 32))) {
+	if ((station = sla_find_station(cat))) {
+		station->mark = 0;
+		existing_station = 1;
+	} else if ((station = ao2_alloc(sizeof(*station), sla_station_destructor))) {
+		if (ast_string_field_init(station, 32)) {
+			return -1;
+		}
+		ast_string_field_set(station, name, cat);
+	} else {
 		return -1;
 	}
 
-	ast_string_field_set(station, name, cat);
+	ao2_lock(station);
+
 	ast_string_field_set(station, device, dev);
 
 	for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
-		if (!strcasecmp(var->name, "trunk"))
+		if (!strcasecmp(var->name, "trunk")) {
+			ao2_unlock(station);
 			sla_add_trunk_to_station(station, var);
-		else if (!strcasecmp(var->name, "autocontext"))
+			ao2_lock(station);
+		} else if (!strcasecmp(var->name, "autocontext")) {
 			ast_string_field_set(station, autocontext, var->value);
-		else if (!strcasecmp(var->name, "ringtimeout")) {
+		} else if (!strcasecmp(var->name, "ringtimeout")) {
 			if (sscanf(var->value, "%30u", &station->ring_timeout) != 1) {
 				ast_log(LOG_WARNING, "Invalid ringtimeout '%s' specified for station '%s'\n",
 					var->value, station->name);
@@ -7309,6 +7478,8 @@
 		}
 	}
 
+	ao2_unlock(station);
+
 	if (!ast_strlen_zero(station->autocontext)) {
 		struct ast_context *context;
 		struct sla_trunk_ref *trunk_ref;
@@ -7316,7 +7487,6 @@
 		if (!context) {
 			ast_log(LOG_ERROR, "Failed to automatically find or create "
 				"context '%s' for SLA!\n", station->autocontext);
-			destroy_station(station);
 			return -1;
 		}
 		/* The extension for when the handset goes off-hook.
@@ -7325,10 +7495,8 @@
 			NULL, NULL, slastation_app, ast_strdup(station->name), ast_free_ptr, sla_registrar)) {
 			ast_log(LOG_ERROR, "Failed to automatically create extension "
 				"for trunk '%s'!\n", station->name);
-			destroy_station(station);
 			return -1;
 		}
-		AST_RWLIST_RDLOCK(&sla_trunks);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			char exten[AST_MAX_EXTENSION];
 			char hint[AST_MAX_APP];
@@ -7340,7 +7508,6 @@
 				NULL, NULL, slastation_app, ast_strdup(exten), ast_free_ptr, sla_registrar)) {
 				ast_log(LOG_ERROR, "Failed to automatically create extension "
 					"for trunk '%s'!\n", station->name);
-				destroy_station(station);
 				return -1;
 			}
 			/* Hint for this line button 
@@ -7349,20 +7516,115 @@
 				NULL, NULL, hint, NULL, NULL, sla_registrar)) {
 				ast_log(LOG_ERROR, "Failed to automatically create hint "
 					"for trunk '%s'!\n", station->name);
-				destroy_station(station);
 				return -1;
 			}
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 	}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
-	AST_RWLIST_INSERT_TAIL(&sla_stations, station, entry);
-	AST_RWLIST_UNLOCK(&sla_stations);
+	if (!existing_station) {
+		ao2_link(sla_stations, station);
+	}
 
 	return 0;
 }
 
+static int sla_trunk_mark(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj;
+	struct sla_station_ref *station_ref;
+
+	ao2_lock(trunk);
+
+	trunk->mark = 1;
+
+	AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
+		station_ref->mark = 1;
+	}
+
+	ao2_unlock(trunk);
+
+	return 0;
+}
+
+static int sla_station_mark(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj;
+	struct sla_trunk_ref *trunk_ref;
+
+	ao2_lock(station);
+
+	station->mark = 1;
+
+	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
+		trunk_ref->mark = 1;
+	}
+
+	ao2_unlock(station);
+
+	return 0;
+}
+
+static int sla_trunk_is_marked(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj;
+
+	ao2_lock(trunk);
+
+	if (trunk->mark) {
+		/* Only remove all of the station references if the trunk itself is going away */
+		sla_trunk_release_refs(trunk, NULL, 0);
+	} else {
+		struct sla_station_ref *station_ref;
+
+		/* Otherwise only remove references to stations no longer in the config */
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&trunk->stations, station_ref, entry) {
+			if (!station_ref->mark) {
+				continue;
+			}
+			AST_LIST_REMOVE_CURRENT(entry);
+			ao2_ref(station_ref, -1);
+		}
+		AST_LIST_TRAVERSE_SAFE_END
+	}
+
+	ao2_unlock(trunk);
+
+	return trunk->mark ? CMP_MATCH : 0;
+}
+
+static int sla_station_is_marked(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj;
+
+	ao2_lock(station);
+
+	if (station->mark) {
+		/* Only remove all of the trunk references if the station itself is going away */
+		sla_station_release_refs(station, NULL, 0);
+	} else {
+		struct sla_trunk_ref *trunk_ref;
+
+		/* Otherwise only remove references to trunks no longer in the config */
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&station->trunks, trunk_ref, entry) {
+			if (!trunk_ref->mark) {
+				continue;
+			}
+			AST_LIST_REMOVE_CURRENT(entry);
+			ao2_ref(trunk_ref, -1);
+		}
+		AST_LIST_TRAVERSE_SAFE_END
+	}
+
+	ao2_unlock(station);
+
+	return station->mark ? CMP_MATCH : 0;
+}
+
+static int sla_in_use(void)
+{
+	return ao2_container_count(sla_trunks) || ao2_container_count(sla_stations);
+}
+
 static int sla_load_config(int reload)
 {
 	struct ast_config *cfg;
@@ -7374,6 +7636,8 @@
 	if (!reload) {
 		ast_mutex_init(&sla.lock);
 		ast_cond_init(&sla.cond, NULL);
+		sla_trunks = ao2_container_alloc(1, sla_trunk_hash, sla_trunk_cmp);
+		sla_stations = ao2_container_alloc(1, sla_station_hash, sla_station_cmp);
 	}
 
 	if (!(cfg = ast_config_load(SLA_CONFIG_FILE, config_flags))) {
@@ -7386,21 +7650,8 @@
 	}
 
 	if (reload) {
-		struct sla_station *station;
-		struct sla_trunk *trunk;
-
-		/* We need to actually delete the previous versions of trunks and stations now */
-		AST_RWLIST_TRAVERSE_SAFE_BEGIN(&sla_stations, station, entry) {
-			AST_RWLIST_REMOVE_CURRENT(entry);
-			ast_free(station);
-		}
-		AST_RWLIST_TRAVERSE_SAFE_END;
-
-		AST_RWLIST_TRAVERSE_SAFE_BEGIN(&sla_trunks, trunk, entry) {
-			AST_RWLIST_REMOVE_CURRENT(entry);
-			ast_free(trunk);
-		}
-		AST_RWLIST_TRAVERSE_SAFE_END;
+		ao2_callback(sla_trunks, 0, sla_trunk_mark, NULL);
+		ao2_callback(sla_stations, 0, sla_station_mark, NULL);
 	}
 
 	if ((val = ast_variable_retrieve(cfg, "general", "attemptcallerid")))
@@ -7427,9 +7678,13 @@
 
 	ast_config_destroy(cfg);
 
-	/* Even if we don't have any stations, we may after a reload and we need to
-	 * be able to process the SLA_EVENT_RELOAD event in that case */
-	if (sla.thread == AST_PTHREADT_NULL && (!AST_LIST_EMPTY(&sla_stations) || !AST_LIST_EMPTY(&sla_trunks))) {
+	if (reload) {
+		ao2_callback(sla_trunks, OBJ_NODATA | OBJ_UNLINK | OBJ_MULTIPLE, sla_trunk_is_marked, NULL);
+		ao2_callback(sla_stations, OBJ_NODATA | OBJ_UNLINK | OBJ_MULTIPLE, sla_station_is_marked, NULL);
+	}
+
+	/* Start SLA event processing thread once SLA has been configured. */
+	if (sla.thread == AST_PTHREADT_NULL && sla_in_use()) {
 		ast_pthread_create(&sla.thread, NULL, sla_thread, NULL);
 	}
 
@@ -7514,15 +7769,7 @@
 static int load_config(int reload)
 {
 	load_config_meetme();
-
-	if (reload && sla.thread != AST_PTHREADT_NULL) {
-		sla_queue_event(SLA_EVENT_RELOAD);
-		ast_log(LOG_NOTICE, "A reload of the SLA configuration has been requested "
-			"and will be completed when the system is idle.\n");
-		return 0;
-	}
-	
-	return sla_load_config(0);
+	return sla_load_config(reload);
 }
 
 #define MEETME_DATA_EXPORT(MEMBER)					\
@@ -7735,8 +7982,6 @@
 	return res;
 }
 
-
-
 static int load_module(void)
 {
 	int res = 0;
--- apps/app_mixmonitor.c
+++ apps/app_mixmonitor.c
@@ -39,7 +39,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 383631 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 393630 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_MONITOR_DIR */
 #include "asterisk/stringfields.h"
@@ -740,6 +740,8 @@
 	}
 
 	mixmonitor_free(mixmonitor);
+
+	ast_module_unref(ast_module_info->self);
 	return NULL;
 }
 
@@ -779,7 +781,7 @@
 	return 0;
 }
 
-static void launch_monitor_thread(struct ast_channel *chan, const char *filename,
+static int launch_monitor_thread(struct ast_channel *chan, const char *filename,
 				  unsigned int flags, int readvol, int writevol,
 				  const char *post_process, const char *filename_write,
 				  char *filename_read, const char *uid_channel_var,
@@ -806,33 +808,33 @@
 
 	/* Pre-allocate mixmonitor structure and spy */
 	if (!(mixmonitor = ast_calloc(1, sizeof(*mixmonitor)))) {
-		return;
+		return -1;
 	}
 
 	/* Now that the struct has been calloced, go ahead and initialize the string fields. */
 	if (ast_string_field_init(mixmonitor, 512)) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* Setup the actual spy before creating our thread */
 	if (ast_audiohook_init(&mixmonitor->audiohook, AST_AUDIOHOOK_TYPE_SPY, mixmonitor_spy_type, 0)) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* Copy over flags and channel name */
 	mixmonitor->flags = flags;
 	if (!(mixmonitor->autochan = ast_autochan_setup(chan))) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	if (setup_mixmonitor_ds(mixmonitor, chan, &datastore_id)) {
 		ast_autochan_destroy(mixmonitor->autochan);
 		mixmonitor_free(mixmonitor);
 		ast_free(datastore_id);
-		return;
+		return -1;
 	}
 
 	if (!ast_strlen_zero(uid_channel_var)) {
@@ -901,13 +903,13 @@
 			mixmonitor_spy_type, ast_channel_name(chan));
 		ast_audiohook_destroy(&mixmonitor->audiohook);
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* reference be released at mixmonitor destruction */
 	mixmonitor->callid = ast_read_threadstorage_callid();
 
-	ast_pthread_create_detached_background(&thread, NULL, mixmonitor_thread, mixmonitor);
+	return ast_pthread_create_detached_background(&thread, NULL, mixmonitor_thread, mixmonitor);
 }
 
 /* a note on filename_parse: creates directory structure and assigns absolute path from relative paths for filenames */
@@ -1028,7 +1030,10 @@
 	}
 
 	pbx_builtin_setvar_helper(chan, "MIXMONITOR_FILENAME", args.filename);
-	launch_monitor_thread(chan,
+
+	/* If launch_monitor_thread works, the module reference must not be released until it is finished. */
+	ast_module_ref(ast_module_info->self);
+	if (launch_monitor_thread(chan,
 			args.filename,
 			flags.flags,
 			readvol,
@@ -1037,7 +1042,9 @@
 			filename_write,
 			filename_read,
 			uid_channel_var,
-			recipients);
+			recipients)) {
+		ast_module_unref(ast_module_info->self);
+	}
 
 	return 0;
 }
@@ -1324,6 +1331,7 @@
 	res = stop_mixmonitor_full(c, mixmonitor_id);
 
 	if (res) {
+		ast_channel_unref(c);
 		astman_send_error(s, m, "Could not stop monitoring channel");
 		return AMI_SUCCESS;
 	}
--- apps/app_queue.c
+++ apps/app_queue.c
@@ -63,7 +63,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391241 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394345 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -402,7 +402,7 @@
 	</application>
 	<application name="UnpauseQueueMember" language="en_US">
 		<synopsis>
-			Unpauses a queue member.		
+			Unpauses a queue member.
 		</synopsis>
 		<syntax>
 			<parameter name="queuename" />
@@ -1083,8 +1083,8 @@
  *  q_next links ALL defined callattempt structures into a linked list. call_next is
  *  a link which allows for a subset of the callattempts to be traversed. This subset
  *  is used in wait_for_answer so that irrelevant callattempts are not traversed. This
- *  also is helpful so that queue logs are always accurate in the case where a call to 
- *  a member times out, especially if using the ringall strategy. 
+ *  also is helpful so that queue logs are always accurate in the case where a call to
+ *  a member times out, especially if using the ringall strategy.
 */
 
 struct callattempt {
@@ -1292,7 +1292,7 @@
 	int rrpos;                          /*!< Round Robin - position */
 	int memberdelay;                    /*!< Seconds to delay connecting member to caller */
 	int autofill;                       /*!< Ignore the head call status and ring an available agent */
-	
+
 	struct ao2_container *members;             /*!< Head of the list of members */
 	struct queue_ent *head;             /*!< Head of the list of callers */
 	AST_LIST_ENTRY(call_queue) list;    /*!< Next call queue */
@@ -1504,8 +1504,8 @@
 			q->name, q->maxlen, int2strat(q->strategy), q->count, q->holdtime, q->talktime, q->callscompleted, q->callsabandoned,  q->servicelevel, sl);
 
 		ao2_unlock(q);
-	
-		pbx_builtin_setvar_multiple(chan, interfacevar); 
+
+		pbx_builtin_setvar_multiple(chan, interfacevar);
 	} else {
 		ao2_unlock(q);
 	}
@@ -1959,7 +1959,7 @@
 		return 0;
 	} else if (c > 96) {
 		return c - 64;
-	} 
+	}
 	return c - 32;
 }
 
@@ -2123,7 +2123,7 @@
 	}
 
 	contentdup = ast_strdupa(content);
-	
+
 	if (!(maxstr = strchr(contentdup, ','))) {
 		ast_log(LOG_WARNING, "Improperly formatted penaltychange rule at line %d. Ignoring.\n", linenum);
 		ast_free(rule);
@@ -2144,7 +2144,7 @@
 	if ((minstr = strchr(maxstr,','))) {
 		*minstr++ = '\0';
 	}
-	
+
 	/* The last check will evaluate true if either no penalty change is indicated for a given rule
 	 * OR if a min penalty change is indicated but no max penalty change is */
 	if (*maxstr == '+' || *maxstr == '-' || *maxstr == '\0') {
@@ -2176,7 +2176,7 @@
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
-	
+
 		if (!inserted) {
 			AST_LIST_INSERT_TAIL(&rl_iter->rules, rule, list);
 			inserted = 1;
@@ -2229,7 +2229,7 @@
 }
 
 /*! \brief Configure a queue parameter.
- * 
+ *
  * The failunknown flag is set for config files (and static realtime) to show
  * errors for unknown parameters. It is cleared for dynamic realtime to allow
  *  extra fields in the tables.
@@ -2238,7 +2238,7 @@
 */
 static void queue_set_param(struct call_queue *q, const char *param, const char *val, int linenum, int failunknown)
 {
-	if (!strcasecmp(param, "musicclass") || 
+	if (!strcasecmp(param, "musicclass") ||
 		!strcasecmp(param, "music") || !strcasecmp(param, "musiconhold")) {
 		ast_string_field_set(q, moh, val);
 	} else if (!strcasecmp(param, "announce")) {
@@ -2645,7 +2645,7 @@
 				ao2_unlock(q);
 				queue_t_unref(q, "Queue is dead; can't return it");
 				return NULL;
-			} 
+			}
 			ast_log(LOG_WARNING, "Static queue '%s' already exists. Not loading from realtime\n", q->name);
 			ao2_unlock(q);
 			return q;
@@ -3246,7 +3246,7 @@
 }
 
 /*! \brief Caller leaving queue.
- * 
+ *
  * Search the queue to find the leaving client, if found remove from queue
  * create manager event, move others up the queue.
 */
@@ -3596,11 +3596,11 @@
 	return 1;
 }
 
-/*! 
+/*!
  * \brief Part 2 of ring_one
  *
- * Does error checking before attempting to request a channel and call a member. 
- * This function is only called from ring_one(). 
+ * Does error checking before attempting to request a channel and call a member.
+ * This function is only called from ring_one().
  * Failure can occur if:
  * - Agent on call
  * - Agent is paused
@@ -3675,7 +3675,7 @@
 		} else if (!ast_strlen_zero(ast_channel_dialed(qe->chan)->number.str)) {
 			ast_set_callerid(tmp->chan, ast_channel_dialed(qe->chan)->number.str, NULL, NULL);
 		} else if (!ast_strlen_zero(S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)))) {
-			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL); 
+			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL);
 		}
 		tmp->dial_callerid_absent = 1;
 	}
@@ -3807,7 +3807,7 @@
 	return best;
 }
 
-/*! 
+/*!
  * \brief Place a call to a queue member.
  *
  * Once metrics have been calculated for each member, this function is used
@@ -3841,7 +3841,7 @@
 			ast_debug(1, "Trying '%s' with metric %d\n", best->interface, best->metric);
 			ret = ring_entry(qe, best, busies);
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			ast_debug(1, "Queue timed out while ringing members.\n");
@@ -3923,14 +3923,14 @@
 	}
 
 	ast_verb(3, "Playing periodic announcement\n");
-	
+
 	if (qe->parent->randomperiodicannounce && qe->parent->numperiodicannounce) {
 		qe->last_periodic_announce_sound = ((unsigned long) ast_random()) % qe->parent->numperiodicannounce;
-	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce || 
+	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce ||
 		ast_str_strlen(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]) == 0) {
 		qe->last_periodic_announce_sound = 0;
 	}
-	
+
 	/* play the announcement */
 	res = play_file(qe->chan, ast_str_buffer(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]));
 
@@ -3958,7 +3958,7 @@
 	if (!qe->parent->randomperiodicannounce) {
 		qe->last_periodic_announce_sound++;
 	}
-	
+
 	return res;
 }
 
@@ -4601,7 +4601,7 @@
  	if (qe->parent->periodicannouncefrequency && qe->parent->announce_to_first_user) {
  		say_periodic_announcement(qe, ringing);
  	}
- 
+
 	if (!*to) {
 		for (o = start; o; o = o->call_next) {
 			rna(orig, qe, o->interface, o->member->membername, 1);
@@ -4619,7 +4619,7 @@
 	return peer;
 }
 
-/*! 
+/*!
  * \brief Check if we should start attempting to call queue members.
  *
  * A simple process, really. Count the number of members who are available
@@ -4649,11 +4649,11 @@
 		if (!ch->pending) {
 			idx++;
 		}
-		ch = ch->next;			
+		ch = ch->next;
 	}
 
 	ao2_unlock(qe->parent);
-	/* If the queue entry is within avl [the number of available members] calls from the top ... 
+	/* If the queue entry is within avl [the number of available members] calls from the top ...
 	 * Autofill and position check added to support autofill=no (as only calls
 	 * from the front of the queue are valid when autofill is disabled)
 	 */
@@ -4678,7 +4678,7 @@
 {
 	int max_penalty = qe->pr->max_relative ? qe->max_penalty + qe->pr->max_value : qe->pr->max_value;
 	int min_penalty = qe->pr->min_relative ? qe->min_penalty + qe->pr->min_value : qe->pr->min_value;
-	char max_penalty_str[20], min_penalty_str[20]; 
+	char max_penalty_str[20], min_penalty_str[20];
 	/* a relative change to the penalty could put it below 0 */
 	if (max_penalty < 0) {
 		max_penalty = 0;
@@ -4753,7 +4753,7 @@
 		if (qe->parent->periodicannouncefrequency &&
 			(res = say_periodic_announcement(qe,ringing)))
 			break;
-		
+
 		/* see if we need to move to the next penalty level for this queue */
 		while (qe->pr && ((time(NULL) - qe->start) >= qe->pr->time)) {
 			update_qe_rule(qe);
@@ -4764,7 +4764,7 @@
 			*reason = QUEUE_TIMEOUT;
 			break;
 		}
-		
+
 		/* Wait a second before checking again */
 		if ((res = ast_waitfordigit(qe->chan, RECHECK * 1000))) {
 			if (res > 0 && !valid_exit(qe, res)) {
@@ -4773,7 +4773,7 @@
 				break;
 			}
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			*reason = QUEUE_TIMEOUT;
@@ -4816,7 +4816,7 @@
 		member->calls++;
 		member->lastqueue = q;
 		ao2_unlock(q);
-	}	
+	}
 	ao2_lock(q);
 	q->callscompleted++;
 	if (callcompletedinsl) {
@@ -5024,7 +5024,7 @@
 				(long) (time(NULL) - callstart), qe->opos);
 
 	update_queue(qe->parent, member, callcompletedinsl, (time(NULL) - callstart));
-	
+
 	/* No need to lock the channels because they are already locked in ast_do_masquerade */
 	if ((datastore = ast_channel_datastore_find(old_chan, &queue_transfer_info, NULL))) {
 		ast_channel_datastore_remove(old_chan, datastore);
@@ -5123,7 +5123,7 @@
  * \param[in] qe the queue_ent structure which corresponds to the caller attempting to reach members
  * \param[in] opts the options passed as the third parameter to the Queue() application
  * \param[in] opt_args the options passed as the third parameter to the Queue() application
- * \param[in] announceoverride filename to play to user when waiting 
+ * \param[in] announceoverride filename to play to user when waiting
  * \param[in] url the url passed as the fourth parameter to the Queue() application
  * \param[in,out] tries the number of times we have tried calling queue members
  * \param[out] noption set if the call to Queue() has the 'n' option set.
@@ -5223,7 +5223,7 @@
 		ast_set_flag(&(bridge_config.features_caller), AST_FEATURE_PARKCALL);
 	}
 	if (ast_test_flag(&opts, OPT_NO_RETRY)) {
-		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR 
+		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR
 			|| qe->parent->strategy == QUEUE_STRATEGY_RRORDERED) {
 			(*tries)++;
 		} else {
@@ -5304,7 +5304,7 @@
 		AST_LIST_LOCK(dialed_interfaces);
 		AST_LIST_TRAVERSE(dialed_interfaces, di, list) {
 			if (!strcasecmp(cur->interface, di->interface)) {
-				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n", 
+				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n",
 					di->interface);
 				break;
 			}
@@ -5359,7 +5359,7 @@
 			   XXX If we're forcibly removed, these outgoing calls won't get
 			   hung up XXX */
 			tmp->q_next = outgoing;
-			outgoing = tmp;		
+			outgoing = tmp;
 			/* If this line is up, don't try anybody else */
 			if (outgoing->chan && (ast_channel_state(outgoing->chan) == AST_STATE_UP))
 				break;
@@ -5583,7 +5583,7 @@
 		 	pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-		
+
 		/* if setqueueentryvar is defined, make queue entry (i.e. the caller) variables available to the channel */
 		/* use  pbx_builtin_setvar to set a load of variables with one call */
 		if (qe->parent->setqueueentryvar) {
@@ -5592,7 +5592,7 @@
 			pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-	
+
 		ao2_unlock(qe->parent);
 
 		/* try to set queue variables if configured to do so*/
@@ -5636,7 +5636,7 @@
 				}
 			} else {
 				mixmonapp = pbx_findapp("MixMonitor");
-				
+
 				if (mixmonapp) {
 					ast_debug(1, "Starting MixMonitor as requested.\n");
 					if (!monitorfilename) {
@@ -5703,7 +5703,7 @@
 
 						pbx_substitute_variables_helper(qe->chan, meid2, meid, sizeof(meid) - 1);
 					}
-	
+
 					snprintf(tmpid2, sizeof(tmpid2), "%s.%s", tmpid, qe->parent->monfmt);
 
 					if (!ast_strlen_zero(monitor_exec)) {
@@ -5711,7 +5711,7 @@
 					} else {
 						snprintf(mixmonargs, sizeof(mixmonargs), "%s,b%s", tmpid2, monitor_options);
 					}
-					
+
 					ast_debug(1, "Arguments being passed to MixMonitor: %s\n", mixmonargs);
 					/* We purposely lock the CDR so that pbx_exec does not update the application data */
 					if (ast_channel_cdr(qe->chan)) {
@@ -5727,12 +5727,12 @@
 			}
 		}
 		/* Drop out of the queue at this point, to prepare for next caller */
-		leave_queue(qe);			
+		leave_queue(qe);
 		if (!ast_strlen_zero(url) && ast_channel_supports_html(peer)) {
 			ast_debug(1, "app_queue: sendurl=%s.\n", url);
 			ast_channel_sendurl(peer, url);
 		}
-		
+
 		/* run a macro for this connection if defined. The macro simply returns, no action is taken on the result */
 		/* use macro from dialplan if passed as a option, otherwise use the default queue macro */
 		if (!ast_strlen_zero(macro)) {
@@ -5869,7 +5869,7 @@
 					qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		ast_copy_string(oldcontext, ast_channel_context(qe->chan), sizeof(oldcontext));
 		ast_copy_string(oldexten, ast_channel_exten(qe->chan), sizeof(oldexten));
-	
+
 		if ((queue_end_bridge = ao2_alloc(sizeof(*queue_end_bridge), NULL))) {
 			queue_end_bridge->q = qe->parent;
 			queue_end_bridge->chan = qe->chan;
@@ -5910,7 +5910,7 @@
 					(long) (callstart - qe->start), (long) (time(NULL) - callstart), qe->opos);
 				send_agent_complete(qe, queuename, peer, member, callstart, vars, sizeof(vars), AGENT);
 			}
-			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {	
+			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {
 				ast_channel_datastore_remove(qe->chan, tds);
 			}
 			ast_channel_unlock(qe->chan);
@@ -6038,7 +6038,7 @@
 	ast_free(value);
 }
 
-/*! \brief Remove member from queue 
+/*! \brief Remove member from queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY removed member from queue
@@ -6107,7 +6107,7 @@
 	return res;
 }
 
-/*! \brief Add member to queue 
+/*! \brief Add member to queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY added member from queue
@@ -6587,7 +6587,7 @@
 				ast_log(LOG_WARNING, "Error converting penalty: %s: Out of range.\n", penalty_tok);
 				break;
 			}
-			
+
 			if (!paused_tok) {
 				ast_log(LOG_WARNING, "Error parsing persistent member string for '%s' (paused)\n", queue_name);
 				break;
@@ -6599,7 +6599,7 @@
 			}
 
 			ast_debug(1, "Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d\n", queue_name, interface, membername, penalty, paused);
-			
+
 			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface) == RES_OUTOFMEMORY) {
 				ast_log(LOG_ERROR, "Out of Memory when reloading persistent queue member\n");
 				break;
@@ -6854,7 +6854,7 @@
 		return -1;
 	}
 
-	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event, 
+	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event,
 		"%s", args.params ? args.params : "");
 
 	return 0;
@@ -6892,14 +6892,14 @@
 
 /*!\brief The starting point for all queue calls
  *
- * The process involved here is to 
+ * The process involved here is to
  * 1. Parse the options specified in the call to Queue()
  * 2. Join the queue
  * 3. Wait in a loop until it is our turn to try calling a queue member
  * 4. Attempt to call a queue member
  * 5. If 4. did not result in a bridged call, then check for between
  *    call options such as periodic announcements etc.
- * 6. Try 4 again unless some condition (such as an expiration time) causes us to 
+ * 6. Try 4 again unless some condition (such as an expiration time) causes us to
  *    exit the queue.
  */
 static int queue_exec(struct ast_channel *chan, const char *data)
@@ -7084,7 +7084,7 @@
 			record_abandoned(&qe);
 			reason = QUEUE_TIMEOUT;
 			res = 0;
-			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld", 
+			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld",
 				qe.pos, qe.opos, (long) time(NULL) - qe.start);
 			break;
 		}
@@ -7103,7 +7103,7 @@
 				goto stop;
 			}
 		}
-	
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7145,7 +7145,7 @@
 			break;
 		}
 
-		
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7194,12 +7194,12 @@
 
 	/* Don't allow return code > 0 */
 	if (res >= 0) {
-		res = 0;	
+		res = 0;
 		if (ringing) {
 			ast_indicate(chan, -1);
 		} else {
 			ast_moh_stop(chan);
-		}			
+		}
 		ast_stopstream(chan);
 	}
 
@@ -7374,6 +7374,9 @@
 			   ((m = interface_exists(q, args.interface)))) {
 			count = m->ringinuse;
 			ao2_ref(m, -1);
+		} else if (!ast_strlen_zero(args.interface)) {
+			ast_log(LOG_ERROR, "Queue member interface %s not in queue %s\n",
+				args.interface, args.queuename);
 		} else {
 			ast_log(LOG_ERROR, "Unknown option %s provided to %s, valid values are: "
 				"logged, free, ready, count, penalty, paused, ringinuse\n", args.option, cmd);
@@ -7488,7 +7491,7 @@
 		ast_log(LOG_ERROR, "%s requires an argument: queuename\n", cmd);
 		return -1;
 	}
-	
+
 	if ((q = find_load_queue_rt_friendly(data))) {
 		ao2_lock(q);
 		mem_iter = ao2_iterator_init(q->members, 0);
@@ -7622,7 +7625,7 @@
 	}
 
 	penalty = get_member_penalty (args.queuename, args.interface);
-	
+
 	if (penalty >= 0) { /* remember that buf is already '\0' */
 		snprintf (buf, len, "%d", penalty);
 	}
@@ -7718,7 +7721,7 @@
 	char *rulecat = NULL;
 	struct ast_variable *rulevar = NULL;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
-	
+
 	if (!(cfg = ast_config_load("queuerules.conf", config_flags))) {
 		ast_log(LOG_NOTICE, "No queuerules.conf file found, queues will not follow penalty rules\n");
 		return AST_MODULE_LOAD_SUCCESS;
@@ -7919,7 +7922,7 @@
  *
  * Once we have isolated a queue within reload_queues, we call this. This will either
  * reload information for the queue or if we're just reloading member information, we'll just
- * reload that without touching other settings within the queue 
+ * reload that without touching other settings within the queue
  *
  * \param cfg The configuration which we are reading
  * \param mask Tells us what information we need to reload
@@ -7955,7 +7958,7 @@
 	} else {
 		new = 0;
 	}
-	
+
 	if (!new) {
 		ao2_lock(q);
 		prev_weight = q->weight ? 1 : 0;
@@ -8074,7 +8077,7 @@
  * \param mask Gives flags telling us what information to actually reload
  * \param queuename If set to a non-zero string, then only reload information from
  * that particular queue. Otherwise inspect all queues
- * \retval -1 Failure occurred 
+ * \retval -1 Failure occurred
  * \retval 0 All clear!
  */
 static int reload_queues(int reload, struct ast_flags *mask, const char *queuename)
@@ -8198,9 +8201,9 @@
 	}
 }
 
-/*! 
- * \brief Show queue(s) status and statistics 
- * 
+/*!
+ * \brief Show queue(s) status and statistics
+ *
  * List the queues strategy, calls processed, members logged in,
  * other queue statistics such as avg hold time.
 */
@@ -8348,7 +8351,7 @@
 	return CLI_SUCCESS;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param list Space delimited list of words
@@ -8405,11 +8408,11 @@
 		/* terminating conditions satisfied, word at beginning or separated by ' ' */
 		return 1;
 	}
-	
+
 	return 0;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param line The line as typed not including the current word being completed
@@ -8475,7 +8478,7 @@
 			"       Provides summary information on a specified queue.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return complete_queue_show(a->line, a->word, a->pos, a->n);	
+		return complete_queue_show(a->line, a->word, a->pos, a->n);
 	}
 
 	return __queues_show(NULL, a->fd, a->argc, a->argv);
@@ -8585,7 +8588,7 @@
 				"Queue: %s\r\n"
 				"LoggedIn: %d\r\n"
 				"Available: %d\r\n"
-				"Callers: %d\r\n" 
+				"Callers: %d\r\n"
 				"HoldTime: %d\r\n"
 				"TalkTime: %d\r\n"
 				"LongestHoldTime: %d\r\n"
@@ -8895,7 +8898,7 @@
 {
 	const char *queuename = NULL;
 	struct ast_flags mask = {QUEUE_RESET_STATS,};
-	
+
 	queuename = astman_get_header(m, "Queue");
 
 	if (!reload_handler(1, &mask, queuename)) {
@@ -8985,7 +8988,7 @@
 		astman_send_error(s, m, "Need 'Interface' and 'Penalty' parameters.");
 		return 0;
 	}
- 
+
 	penalty = atoi(penalty_s);
 
 	if (set_member_value((char *)queuename, (char *)interface, MEMBER_PENALTY, penalty)) {
@@ -9207,7 +9210,7 @@
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue {pause|unpause} member";
-		e->usage = 
+		e->usage =
 			"Usage: queue {pause|unpause} member <member> [queue <queue> [reason <reason>]]\n"
 			"	Pause or unpause a queue member. Not specifying a particular queue\n"
 			"	will pause or unpause a member across all queues to which the member\n"
@@ -9342,7 +9345,7 @@
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue set penalty";
-		e->usage = 
+		e->usage =
 		"Usage: queue set penalty <penalty> on <interface> [in <queue>]\n"
 		"	Set a member's penalty in the queue specified. If no queue is specified\n"
 		"	then that interface's penalty is set in all queues to which that interface is a member\n";
@@ -9375,7 +9378,7 @@
 	}
 }
 
-static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state) 
+static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state)
 {
 	int which = 0;
 	struct rule_list *rl_iter;
@@ -9429,7 +9432,7 @@
 		}
 	}
 	AST_LIST_UNLOCK(&rule_lists);
-	return CLI_SUCCESS; 
+	return CLI_SUCCESS;
 }
 
 static char *handle_queue_reset(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
@@ -9535,7 +9538,7 @@
 	return CLI_SUCCESS;
 }
 
-static const char qpm_cmd_usage[] = 
+static const char qpm_cmd_usage[] =
 "Usage: queue pause member <channel> in <queue> reason <reason>\n";
 
 static const char qum_cmd_usage[] =
--- channels/chan_dahdi.c
+++ channels/chan_dahdi.c
@@ -49,7 +49,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387298 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394173 $")
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <pthread.h>
@@ -566,14 +566,6 @@
 #endif	/* defined(HAVE_SS7) */
 
 #ifdef HAVE_OPENR2
-struct dahdi_mfcr2 {
-	pthread_t r2master;		       /*!< Thread of master */
-	openr2_context_t *protocol_context;    /*!< OpenR2 context handle */
-	struct dahdi_pvt *pvts[SIG_MFCR2_MAX_CHANNELS];     /*!< Member channel pvt structs */
-	int numchans;                          /*!< Number of channels in this R2 block */
-	int monitored_count;                   /*!< Number of channels being monitored */
-};
-
 struct dahdi_mfcr2_conf {
 	openr2_variant_t variant;
 	int mfback_timeout;
@@ -608,6 +600,15 @@
 	openr2_calling_party_category_t category;
 };
 
+/* MFC-R2 pseudo-link structure */
+struct dahdi_mfcr2 {
+	pthread_t r2master;		       /*!< Thread of master */
+	openr2_context_t *protocol_context;    /*!< OpenR2 context handle */
+	struct dahdi_pvt *pvts[SIG_MFCR2_MAX_CHANNELS];     /*!< Member channel pvt structs */
+	int numchans;                          /*!< Number of channels in this R2 block */
+	struct dahdi_mfcr2_conf conf;         /*!< Configuration used to setup this pseudo-link */
+};
+
 /* malloc'd array of malloc'd r2links */
 static struct dahdi_mfcr2 **r2links;
 /* how many r2links have been malloc'd */
@@ -12428,14 +12429,20 @@
 	r2links_count = 0;
 }
 
-#define R2_LINK_CAPACITY 10
-static struct dahdi_mfcr2 *dahdi_r2_get_link(void)
+/* This is an artificial convenient capacity, to keep at most a full E1 of channels in a single thread */
+#define R2_LINK_CAPACITY 30
+static struct dahdi_mfcr2 *dahdi_r2_get_link(const struct dahdi_chan_conf *conf)
 {
 	struct dahdi_mfcr2 *new_r2link = NULL;
 	struct dahdi_mfcr2 **new_r2links = NULL;
-	/* this function is called just when starting up and no monitor threads have been launched,
-	   no need to lock monitored_count member */
-	if (!r2links_count || (r2links[r2links_count - 1]->monitored_count == R2_LINK_CAPACITY)) {
+
+	/* Only create a new R2 link if 
+	   1. This is the first link requested
+	   2. Configuration changed 
+	   3. We got more channels than supported per link */
+	if (!r2links_count ||
+	    memcmp(&conf->mfcr2, &r2links[r2links_count - 1]->conf, sizeof(conf->mfcr2)) ||
+	   (r2links[r2links_count - 1]->numchans == R2_LINK_CAPACITY)) {
 		new_r2link = ast_calloc(1, sizeof(**r2links));
 		if (!new_r2link) {
 			ast_log(LOG_ERROR, "Cannot allocate R2 link!\n");
@@ -12507,7 +12514,8 @@
 			ast_log(LOG_ERROR, "Failed to configure r2context from advanced configuration file %s\n", conf->mfcr2.r2proto_file);
 		}
 	}
-	r2_link->monitored_count = 0;
+	/* Save the configuration used to setup this link */
+	memcpy(&r2_link->conf, conf, sizeof(r2_link->conf));
 	return 0;
 }
 #endif
@@ -12738,7 +12746,7 @@
 #ifdef HAVE_OPENR2
 			if (chan_sig == SIG_MFCR2) {
 				struct dahdi_mfcr2 *r2_link;
-				r2_link = dahdi_r2_get_link();
+				r2_link = dahdi_r2_get_link(conf);
 				if (!r2_link) {
 					ast_log(LOG_WARNING, "Cannot get another R2 DAHDI context!\n");
 					destroy_dahdi_pvt(tmp);
@@ -12780,7 +12788,6 @@
 				tmp->mfcr2call = 0;
 				tmp->mfcr2_dnis_index = 0;
 				tmp->mfcr2_ani_index = 0;
-				r2_link->monitored_count++;
 			}
 #endif
 #ifdef HAVE_PRI
@@ -15452,6 +15459,7 @@
 	dahdi_softhangup_all();
 	ast_verb(4, "Final softhangup of all DAHDI channels complete.\n");
 	destroy_all_channels();
+	memset(round_robin, 0, sizeof(round_robin));
 	ast_debug(1, "Channels destroyed. Now re-reading config. %d active channels remaining.\n", ast_active_channels());
 
 	ast_mutex_unlock(&monlock);
--- channels/chan_motif.c
+++ channels/chan_motif.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377462 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include <sys/socket.h>
 #include <fcntl.h>
@@ -2555,9 +2555,9 @@
 	aco_option_register_custom(&cfg_info, "connection", ACO_EXACT, endpoint_options, NULL, custom_connection_handler, 0);
 	aco_option_register_custom(&cfg_info, "transport", ACO_EXACT, endpoint_options, NULL, custom_transport_handler, 0);
 	aco_option_register(&cfg_info, "maxicecandidates", ACO_EXACT, endpoint_options, DEFAULT_MAX_ICE_CANDIDATES, OPT_UINT_T, PARSE_DEFAULT,
-			    FLDSET(struct jingle_endpoint, maxicecandidates));
+			    FLDSET(struct jingle_endpoint, maxicecandidates), DEFAULT_MAX_ICE_CANDIDATES);
 	aco_option_register(&cfg_info, "maxpayloads", ACO_EXACT, endpoint_options, DEFAULT_MAX_PAYLOADS, OPT_UINT_T, PARSE_DEFAULT,
-			    FLDSET(struct jingle_endpoint, maxpayloads));
+			    FLDSET(struct jingle_endpoint, maxpayloads), DEFAULT_MAX_PAYLOADS);
 
 	ast_format_cap_add_all_by_type(jingle_tech.capabilities, AST_FORMAT_TYPE_AUDIO);
 
@@ -2608,6 +2608,8 @@
 static int unload_module(void)
 {
 	ast_channel_unregister(&jingle_tech);
+	ast_format_cap_destroy(jingle_tech.capabilities);
+	jingle_tech.capabilities = NULL;
 	ast_rtp_glue_unregister(&jingle_rtp_glue);
 	ast_sched_context_destroy(sched);
 	aco_info_destroy(&cfg_info);
--- channels/chan_unistim.c
+++ channels/chan_unistim.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 389661 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 393395 $")
 
 #include <sys/stat.h>
 #include <signal.h>
@@ -3318,12 +3318,11 @@
 		}
 		break;
 	case KEY_FUNC2:
+		if (ast_channel_state(sub->owner) == AST_STATE_RING) {
+			transfer_cancel_step2(pte);
+		}
 		if (ast_channel_state(sub->owner) == AST_STATE_UP) {
-			if (get_sub(pte->device, SUB_THREEWAY)) {
-				transfer_cancel_step2(pte);
-			} else {
-				transfer_call_step1(pte);
-			}
+			transfer_call_step1(pte);
 		}
 		break;
 	case KEY_HANGUP:
@@ -4777,7 +4776,7 @@
 	struct unistim_line *l;
 	struct unistim_device *d;
 	struct unistimsession *s;
-	int i;
+	int i,end_call = 1;
 
 	s = channel_to_session(ast);
 	sub = ast_channel_tech_pvt(ast);
@@ -4822,10 +4821,8 @@
 		unistim_unalloc_sub(d, sub);
 		return 0;
 	}
-
 	if (sub->subtype == SUB_REAL) {
 		sub_stop_silence(s, sub);
-		send_end_call(s); /* Send end call packet only if ending active call, in other way sound should be loosed */
 	} else if (sub->subtype == SUB_RING) {
 		send_no_ring(s);
 		for (i = 0; i < FAVNUM; i++) {
@@ -4836,9 +4833,16 @@
 			if (is_key_line(d, i) && !strcmp(l->name, d->sline[i]->name)) {
 				send_favorite_short(i, FAV_LINE_ICON, s);
 				d->ssub[i] = NULL;
+				continue;
+			}
+			if (d->ssub[i] != NULL) { /* Found other subchannel active other then hangup'ed one */
+				end_call = 0;
 			}
 		}
 	}
+	if (end_call) {
+		send_end_call(s); /* Send end call packet only if ending active call, in other way sound should be loosed */
+	}
 	sub->moh = 0;
 	if (sub->softkey >= 0) {
 		send_favorite_short(sub->softkey, FAV_LINE_ICON, s);
@@ -6132,7 +6136,7 @@
 			return 0;
 		}
 		if (d->softkeyicon[p] != 0) {
-			ast_log(LOG_WARNING, "Invalid position %d for bookmark : already used\n:", p);
+			ast_log(LOG_WARNING, "Invalid position %d for bookmark : already used:\n", p);
 			return 0;
 		}
 		memmove(line, line + 2, sizeof(line) - 2);
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -244,7 +244,10 @@
 };
 
 /*! \brief load confbridge.conf file */
-int conf_load_config(int reload);
+int conf_load_config(void);
+
+/*! \brief reload confbridge.conf file */
+int conf_reload_config(void);
 
 /*! \brief destroy the information loaded from the confbridge.conf file*/
 void conf_destroy_config(void);
--- apps/confbridge/conf_config_parser.c
+++ apps/confbridge/conf_config_parser.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 382066 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
 #include "asterisk/logger.h"
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -1320,12 +1320,10 @@
 	return 0;
 }
 
-int conf_load_config(int reload)
+int conf_load_config(void)
 {
-	if (!reload) {
-		if (aco_info_init(&cfg_info)) {
-			return -1;
-		}
+	if (aco_info_init(&cfg_info)) {
+		return -1;
 	}
 
 	/* User options */
@@ -1373,23 +1371,29 @@
 	/* Menu options */
 	aco_option_register_custom(&cfg_info, "^[0-9A-D*#]+$", ACO_REGEX, menu_types, NULL, menu_option_handler, 0);
 
-	if (aco_process_config(&cfg_info, reload) == ACO_PROCESS_ERROR) {
+	if (aco_process_config(&cfg_info, 0) == ACO_PROCESS_ERROR) {
 		goto error;
 	}
 
-	if (!reload && ast_cli_register_multiple(cli_confbridge_parser, ARRAY_LEN(cli_confbridge_parser))) {
+	if (ast_cli_register_multiple(cli_confbridge_parser, ARRAY_LEN(cli_confbridge_parser))) {
 		goto error;
 	}
 
 	return 0;
 error:
-	/* On a reload, just keep the config we already have in place. */
-	if (!reload) {
-		conf_destroy_config();
-	}
+	conf_destroy_config();
 	return -1;
 }
 
+int conf_reload_config(void)
+{
+	if (aco_process_config(&cfg_info, 1) == ACO_PROCESS_ERROR) {
+		/* On a reload, just keep the config we already have in place. */
+		return -1;
+	}
+	return 0;
+}
+
 static void conf_user_profile_copy(struct user_profile *dst, struct user_profile *src)
 {
 	*dst = *src;
--- main/config_options.c
+++ main/config_options.c
@@ -27,7 +27,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 374196 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include <regex.h>
 
@@ -153,14 +153,15 @@
 			return -1;
 		}
 		if (!ao2_link(type->internal->opts, opt)) {
-			while (--idx) {
+			do {
 				ao2_unlink(types[idx]->internal->opts, opt);
-			}
+			} while (--idx);
 			return -1;
 		}
-		/* The container should hold the only ref to opt */
-		ao2_ref(opt, -1);
 	}
+	/* The container(s) should hold the only ref to opt */
+	ao2_ref(opt, -1);
+
 	return 0;
 }
 
--- main/format.c
+++ main/format.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377244 $");
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $");
 
 #include "asterisk/_private.h"
 #include "asterisk/format.h"
@@ -916,7 +916,7 @@
 
 static int format_list_add_custom(struct ast_format_list *new)
 {
-	struct ast_format_list *entry;
+	RAII_VAR(struct ast_format_list *, entry, NULL, ao2_cleanup);
 	if (!(entry = ao2_alloc(sizeof(*entry), NULL))) {
 		return -1;
 	}
--- funcs/func_strings.c
+++ funcs/func_strings.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394303 $")
 
 #include <regex.h>
 #include <ctype.h>
@@ -165,6 +165,10 @@
 			<para>Literally returns the given <replaceable>string</replaceable>.  The intent is to permit
 			other dialplan functions which take a variable name as an argument to be able to take a literal
 			string, instead.</para>
+			<note><para>The functions which take a variable name need to be passed var and not
+			${var}.  Similarly, use PASSTHRU() and not ${PASSTHRU()}.</para></note>
+			<para>Example: ${CHANNEL} contains SIP/321-1</para>
+			<para>         ${CUT(PASSTHRU(${CUT(CHANNEL,-,1)}),/,2)}) will return 321</para>
 		</description>
 	</function>
 	<function name="REGEX" language="en_US">
--- main/http.c
+++ main/http.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 384119 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include <time.h>
 #include <sys/time.h>
@@ -1024,7 +1024,7 @@
 	struct http_uri_redirect *redirect;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
 	uint32_t bindport = DEFAULT_PORT;
-	struct ast_sockaddr *addrs = NULL;
+	RAII_VAR(struct ast_sockaddr *, addrs, NULL, ast_free);
 	int num_addrs = 0;
 	int http_tls_was_enabled = 0;
 
--- main/loader.c
+++ main/loader.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 378094 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_MODULE_DIR */
@@ -1035,6 +1035,8 @@
 			break;
 		case AST_MODULE_LOAD_PRIORITY:
 			AST_LIST_REMOVE_CURRENT(entry);
+			ast_free(order->resource);
+			ast_free(order);
 			break;
 		}
 	}
--- main/named_acl.c
+++ main/named_acl.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377340 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -555,10 +555,18 @@
 	AST_CLI_DEFINE(handle_show_named_acl_cmd, "Show a named ACL or list all named ACLs"),
 };
 
+static void named_acl_cleanup(void)
+{
+	aco_info_destroy(&cfg_info);
+	ao2_global_obj_release(globals);
+}
+
 int ast_named_acl_init()
 {
 	ast_cli_register_multiple(cli_named_acl, ARRAY_LEN(cli_named_acl));
 
+	ast_register_atexit(named_acl_cleanup);
+
 	if (aco_info_init(&cfg_info)) {
 		return 0;
 	}
--- res/res_agi.c
+++ res/res_agi.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 381893 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394641 $")
 
 #include <math.h>
 #include <signal.h>
@@ -2007,8 +2007,8 @@
 	}
 
 	if (!(fs = ast_openstream(chan, argv[2], ast_channel_language(chan)))) {
-		ast_agi_send(agi->fd, chan, "200 result=%d endpos=%ld\n", 0, sample_offset);
-		return RESULT_SUCCESS;
+		ast_agi_send(agi->fd, chan, "200 result=-1 endpos=%ld\n", sample_offset);
+		return RESULT_FAILURE;
 	}
 
 	if ((vfs = ast_openvstream(chan, argv[2], ast_channel_language(chan)))) {
@@ -2065,9 +2065,9 @@
 	}
 
 	if (!(fs = ast_openstream(chan, argv[2], ast_channel_language(chan)))) {
-		ast_agi_send(agi->fd, chan, "200 result=%d endpos=%ld\n", 0, sample_offset);
+		ast_agi_send(agi->fd, chan, "200 result=-1 endpos=%ld\n", sample_offset);
 		ast_log(LOG_WARNING, "Unable to open %s\n", argv[2]);
-		return RESULT_SUCCESS;
+		return RESULT_FAILURE;
 	}
 
 	if ((vfs = ast_openvstream(chan, argv[2], ast_channel_language(chan))))
--- res/res_calendar.c
+++ res/res_calendar.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 378321 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/calendar.h"
@@ -1810,6 +1810,8 @@
 
 	/* Remove all calendars */
 	ao2_callback(calendars, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
+	ao2_cleanup(calendars);
+	calendars = NULL;
 
 	ast_mutex_lock(&refreshlock);
 	module_unloading = 1;
--- res/res_http_websocket.c
+++ res/res_http_websocket.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 376561 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391560 $")
 
 #include "asterisk/module.h"
 #include "asterisk/http.h"
@@ -544,9 +544,18 @@
 		/* Version 7 defined in specification http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07 */
 		/* Version 8 defined in specification http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10 */
 		/* Version 13 defined in specification http://tools.ietf.org/html/rfc6455 */
-		char combined[strlen(key) + strlen(WEBSOCKET_GUID) + 1], base64[64];
+		char *combined, base64[64];
+		unsigned combined_length;
 		uint8_t sha[20];
 
+		combined_length = (key ? strlen(key) : 0) + strlen(WEBSOCKET_GUID) + 1;
+		if (!key || combined_length > 8192) { /* no stack overflows please */
+			fputs("HTTP/1.1 400 Bad Request\r\n"
+			      "Sec-WebSocket-Version: 7, 8, 13\r\n\r\n", ser->f);
+			ao2_ref(protocol_handler, -1);
+			return 0;
+		}
+
 		if (!(session = ao2_alloc(sizeof(*session), session_destroy_fn))) {
 			ast_log(LOG_WARNING, "WebSocket connection from '%s' could not be accepted\n",
 				ast_sockaddr_stringify(&ser->remote_address));
@@ -556,7 +565,8 @@
 			return 0;
 		}
 
-		snprintf(combined, sizeof(combined), "%s%s", key, WEBSOCKET_GUID);
+		combined = ast_alloca(combined_length);
+		snprintf(combined, combined_length, "%s%s", key, WEBSOCKET_GUID);
 		ast_sha1_hash_uint(sha, combined);
 		ast_base64encode(base64, (const unsigned char*)sha, 20, sizeof(base64));
 
--- configs/sla.conf.sample
+++ configs/sla.conf.sample
@@ -15,6 +15,17 @@
 ; -------------------------------------
 
 
+; ********************************
+; **** Configuration Ordering ****
+; ********************************
+
+; Note that SLA configuration processing assumes that *all* trunk declarations are
+; listed in the configuration file before any stations.
+
+; ********************************
+; ********************************
+
+
 ; ---- Trunk Declarations -------------
 ;
 ;[line1]                    ; Provide a name for this trunk.
