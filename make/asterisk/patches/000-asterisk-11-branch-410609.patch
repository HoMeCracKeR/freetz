--- addons/chan_ooh323.c
+++ addons/chan_ooh323.c
@@ -1402,7 +1402,8 @@
 
 		}
 		break;
-      case AST_CONTROL_PROCEEDING:
+	case AST_CONTROL_PROCEEDING:
+	case AST_CONTROL_PVT_CAUSE_CODE:
 	case -1:
 		break;
 	default:
--- addons/ooh323c/src/ooCalls.h
+++ addons/ooh323c/src/ooCalls.h
@@ -228,7 +228,7 @@
    char			lastDTMF;
    ASN1UINT		nextDTMFstamp;
    int			rtdrInterval, rtdrCount;	/* roundTripDelay interval and unreplied count */
-   ASN1UINT		rtdrSend, rtdrRecv;		/* last sended/replied RTD request */
+   ASN1UINT8		rtdrSend, rtdrRecv;		/* last sended/replied RTD request */
    void                 *usrData; /*!<User can set this to user specific data*/
    struct OOH323CallData* next;
    struct OOH323CallData* prev;
--- addons/ooh323c/src/ooCapability.c
+++ addons/ooh323c/src/ooCapability.c
@@ -2940,6 +2940,22 @@
       break;
 
 
+   case T_H245Capability_receiveAndTransmitUserInputCapability:
+      if((cap->u.receiveAndTransmitUserInputCapability->t == 
+                                 T_H245UserInputCapability_basicString) &&
+         (call->dtmfmode & OO_CAP_DTMF_H245_alphanumeric))
+      {
+         call->jointDtmfMode |= OO_CAP_DTMF_H245_alphanumeric;
+         return OO_OK;
+      }
+      else if((cap->u.receiveAndTransmitUserInputCapability->t ==
+               T_H245UserInputCapability_dtmf) &&
+               (call->dtmfmode & OO_CAP_DTMF_H245_signal))
+      {
+         call->jointDtmfMode |= OO_CAP_DTMF_H245_signal;
+         return OO_OK;
+      }
+
    case T_H245Capability_receiveUserInputCapability:
       if((cap->u.receiveUserInputCapability->t == 
                                  T_H245UserInputCapability_basicString) &&
--- addons/ooh323c/src/ooh245.c
+++ addons/ooh323c/src/ooh245.c
@@ -713,8 +713,8 @@
          memset(entry, 0, sizeof(H245CapabilityTableEntry));
          entry->m.capabilityPresent = 1;
 
-         entry->capability.t = T_H245Capability_receiveUserInputCapability;
-         entry->capability.u.receiveUserInputCapability = userInputCap;
+         entry->capability.t = T_H245Capability_receiveAndTransmitUserInputCapability;
+         entry->capability.u.receiveAndTransmitUserInputCapability = userInputCap;
       
          entry->capabilityTableEntryNumber = i+1;
          dListAppend(pctxt , &(termCap->capabilityTable), entry);
@@ -749,8 +749,8 @@
          memset(entry, 0, sizeof(H245CapabilityTableEntry));
          entry->m.capabilityPresent = 1;
 
-         entry->capability.t = T_H245Capability_receiveUserInputCapability;
-         entry->capability.u.receiveUserInputCapability = userInputCap;
+         entry->capability.t = T_H245Capability_receiveAndTransmitUserInputCapability;
+         entry->capability.u.receiveAndTransmitUserInputCapability = userInputCap;
       
          entry->capabilityTableEntryNumber = i+1;
          dListAppend(pctxt , &(termCap->capabilityTable), entry);
--- addons/ooh323c/src/ooh323.c
+++ addons/ooh323c/src/ooh323.c
@@ -535,11 +535,13 @@
       }
    }
 
+/* Allow sourceCallSignallAddress different with socket IP for gk routed calls */
    if (strncmp(remoteIP, call->remoteIP, strlen(remoteIP))) {
-     OOTRACEERR5("ERROR: Security denial remote sig IP isn't a socket ip, %s not %s "
-		     "(%s, %s)\n", remoteIP, call->remoteIP, call->callType, 
-		     call->callToken);
-     return OO_FAILED;
+	if(!gH323ep.gkClient || OO_TESTFLAG(call->flags, OO_M_DISABLEGK) || (gH323ep.gkClient->state != GkClientRegistered)) {
+     		OOTRACEERR5("ERROR: Security denial remote sig IP isn't a socket ip, %s not %s "
+		     	"(%s, %s)\n", remoteIP, call->remoteIP, call->callType, call->callToken);
+     		return OO_FAILED;
+	}
    }
    
    /* check for fast start */
--- apps/app_chanspy.c
+++ apps/app_chanspy.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 408537 $")
 
 #include <ctype.h>
 #include <errno.h>
@@ -158,7 +158,9 @@
 					</option>
 					<option name="x">
 						<argument name="digit" required="true">
-							<para>Specify a DTMF digit that can be used to exit the application.</para>
+							<para>Specify a DTMF digit that can be used to exit the application while actively
+							spying on a channel. If there is no channel being spied on, the DTMF digit will be
+							ignored.</para>
 						</argument>
 					</option>
 					<option name="X">
@@ -295,7 +297,9 @@
 					</option>
 					<option name="x">
 						<argument name="digit" required="true">
-							<para>Specify a DTMF digit that can be used to exit the application.</para>
+							<para>Specify a DTMF digit that can be used to exit the application while actively
+							spying on a channel. If there is no channel being spied on, the DTMF digit will be
+							ignored.</para>
 						</argument>
 					</option>
 					<option name="X">
--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405215 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407857 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -182,7 +182,9 @@
 		<syntax>
 			<xi:include xpointer="xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])" />
 			<parameter name="Conference" required="true" />
-			<parameter name="Channel" required="true" />
+			<parameter name="Channel" required="true">
+				<para>If this parameter is not a complete channel name, the first channel with this prefix will be used.</para>
+			</parameter>
 		</syntax>
 		<description>
 		</description>
@@ -194,7 +196,9 @@
 		<syntax>
 			<xi:include xpointer="xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])" />
 			<parameter name="Conference" required="true" />
-			<parameter name="Channel" required="true" />
+			<parameter name="Channel" required="true">
+				<para>If this parameter is not a complete channel name, the first channel with this prefix will be used.</para>
+			</parameter>
 		</syntax>
 		<description>
 		</description>
@@ -264,7 +268,9 @@
 		<syntax>
 			<xi:include xpointer="xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])" />
 			<parameter name="Conference" required="true" />
-			<parameter name="Channel" required="true" />
+			<parameter name="Channel" required="true">
+				<para>If this parameter is not a complete channel name, the first channel with this prefix will be used.</para>
+			</parameter>
 		</syntax>
 		<description>
 		</description>
@@ -365,6 +371,8 @@
 		return S_OR(custom_sounds->participantsmuted, "conf-now-muted");
 	case CONF_SOUND_PARTICIPANTS_UNMUTED:
 		return S_OR(custom_sounds->participantsunmuted, "conf-now-unmuted");
+	case CONF_SOUND_BEGIN:
+		return S_OR(custom_sounds->begin, "confbridge-conf-begin");
 	}
 
 	return "";
@@ -1074,14 +1082,6 @@
 	ao2_unlock(user->conference_bridge);
 }
 
-int conf_handle_first_marked_common(struct conference_bridge_user *cbu)
-{
-	if (!ast_test_flag(&cbu->u_profile, USER_OPT_QUIET) && play_prompt_to_user(cbu, conf_get_sound(CONF_SOUND_PLACE_IN_CONF, cbu->b_profile.sounds))) {
-		return -1;
-	}
-	return 0;
-}
-
 int conf_handle_inactive_waitmarked(struct conference_bridge_user *cbu)
 {
 	/* If we have not been quieted play back that they are waiting for the leader */
@@ -2421,7 +2421,10 @@
 		e->command = "confbridge mute";
 		e->usage =
 			"Usage: confbridge mute <conference> <channel>\n"
-			"       Mute a channel in a conference.\n";
+			"       Mute a channel in a conference.\n"
+			"       If the specified channel is a prefix,\n"
+			"       the action will be taken on the first\n"
+			"       matching channel.\n";
 		return NULL;
 	case CLI_GENERATE:
 		if (a->pos == 2) {
@@ -2448,7 +2451,10 @@
 		e->command = "confbridge unmute";
 		e->usage =
 			"Usage: confbridge unmute <conference> <channel>\n"
-			"       Unmute a channel in a conference.\n";
+			"       Unmute a channel in a conference.\n"
+			"       If the specified channel is a prefix,\n"
+			"       the action will be taken on the first\n"
+			"       matching channel.\n";
 		return NULL;
 	case CLI_GENERATE:
 		if (a->pos == 2) {
--- apps/app_dial.c
+++ apps/app_dial.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 381880 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407074 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -2880,8 +2880,9 @@
 					/* perform a transfer to a new extension */
 					if (strchr(macro_transfer_dest, '^')) { /* context^exten^priority*/
 						ast_replace_subargument_delimiter(macro_transfer_dest);
-						if (!ast_parseable_goto(chan, macro_transfer_dest))
-							ast_set_flag64(peerflags, OPT_GO_ON);
+					}
+					if (!ast_parseable_goto(chan, macro_transfer_dest)) {
+						ast_set_flag64(peerflags, OPT_GO_ON);
 					}
 				}
 			} else {
@@ -2961,8 +2962,9 @@
 					/* perform a transfer to a new extension */
 					if (strchr(gosub_transfer_dest, '^')) { /* context^exten^priority*/
 						ast_replace_subargument_delimiter(gosub_transfer_dest);
-						if (!ast_parseable_goto(chan, gosub_transfer_dest))
-							ast_set_flag64(peerflags, OPT_GO_ON);
+					}
+					if (!ast_parseable_goto(chan, gosub_transfer_dest)) {
+						ast_set_flag64(peerflags, OPT_GO_ON);
 					}
 				}
 			} else {
--- apps/app_forkcdr.c
+++ apps/app_forkcdr.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 362085 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 408748 $")
 
 #include "asterisk/file.h"
 #include "asterisk/channel.h"
@@ -239,13 +239,14 @@
 {
 	int res = 0;
 	char *argcopy = NULL;
+	struct ast_cdr *cdr;
 	struct ast_flags flags = {0};
 	char *opts[OPT_ARG_ARRAY_SIZE];
 	AST_DECLARE_APP_ARGS(arglist,
 		AST_APP_ARG(options);
 	);
 
-	if (!ast_channel_cdr(chan)) {
+	if (!(cdr = ast_channel_cdr(chan))) {
 		ast_log(LOG_WARNING, "Channel does not have a CDR\n");
 		return 0;
 	}
@@ -261,9 +262,12 @@
 
 	if (!ast_strlen_zero(data)) {
 		int keepvars = ast_test_flag(&flags, OPT_KEEPVARS) ? 1 : 0;
-		ast_set2_flag(ast_channel_cdr(chan), keepvars, AST_CDR_FLAG_KEEP_VARS);
+		while (cdr->next) {
+			cdr = cdr->next;
+		}
+		ast_set2_flag(cdr, keepvars, AST_CDR_FLAG_KEEP_VARS);
 	}
-	
+
 	ast_cdr_fork(chan, flags, opts[OPT_ARG_VARSET]);
 
 	return res;
--- apps/app_queue.c
+++ apps/app_queue.c
@@ -63,7 +63,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402646 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409208 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -227,10 +227,10 @@
 				connected to a queue member.</para>
 			</parameter>
 			<parameter name="macro">
-				<para>Will run a macro on the calling party's channel once they are connected to a queue member.</para>
+				<para>Will run a macro on the called party's channel (the queue member) once the parties are connected.</para>
 			</parameter>
 			<parameter name="gosub">
-				<para>Will run a gosub on the calling party's channel once they are connected to a queue member.</para>
+				<para>Will run a gosub on the called party's channel (the queue member) once the parties are connected.</para>
 			</parameter>
 			<parameter name="rule">
 				<para>Will cause the queue's defaultrule to be overridden by the rule specified.</para>
@@ -6276,22 +6276,25 @@
 
 				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));
 
-				/*** DOCUMENTATION
-				<managerEventInstance>
-					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>
-					<syntax>
-						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
-						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />
-						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />
-						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />
-					</syntax>
-					<see-also>
-						<ref type="application">PauseQueueMember</ref>
-						<ref type="application">UnPauseQueueMember</ref>
-					</see-also>
-				</managerEventInstance>
-				***/
 				if (!ast_strlen_zero(reason)) {
+					/*** DOCUMENTATION
+					<managerEventInstance>
+						<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>
+						<syntax>
+							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
+							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />
+							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />
+							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />
+							<parameter name="Reason">
+								<para>The reason given for pausing or unpausing a queue member.</para>
+							</parameter>
+						</syntax>
+						<see-also>
+							<ref type="application">PauseQueueMember</ref>
+							<ref type="application">UnPauseQueueMember</ref>
+						</see-also>
+					</managerEventInstance>
+					***/
 					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",
 						"Queue: %s\r\n"
 						"Location: %s\r\n"
--- apps/app_stack.c
+++ apps/app_stack.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
  
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407103 $")
 
 #include "asterisk/pbx.h"
 #include "asterisk/module.h"
@@ -763,6 +763,12 @@
 	}
 
 	AST_STANDARD_RAW_ARGS(args, data);
+
+	if (ast_strlen_zero(args.n) || ast_strlen_zero(args.name)) {
+		ast_log(LOG_ERROR, "LOCAL_PEEK requires parameters n and varname\n");
+		return -1;
+	}
+
 	n = atoi(args.n);
 	*buf = '\0';
 
@@ -802,6 +808,11 @@
 	data = ast_strdupa(data);
 	AST_STANDARD_APP_ARGS(args, data);
 
+	if (ast_strlen_zero(args.n) || ast_strlen_zero(args.which)) {
+		ast_log(LOG_ERROR, "STACK_PEEK requires parameters n and which\n");
+		return -1;
+	}
+
 	n = atoi(args.n);
 	if (n <= 0) {
 		ast_log(LOG_ERROR, "STACK_PEEK must be called with a positive peek value\n");
--- apps/app_transfer.c
+++ apps/app_transfer.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 361042 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405792 $")
 
 #include "asterisk/pbx.h"
 #include "asterisk/module.h"
@@ -54,7 +54,7 @@
 		<description>
 			<para>Requests the remote caller be transferred
 			to a given destination. If TECH (SIP, IAX2, LOCAL etc) is used, only
-			an incoming call with the same channel technology will be transfered.
+			an incoming call with the same channel technology will be transferred.
 			Note that for SIP, if you transfer before call is setup, a 302 redirect
 			SIP message will be returned to the caller.</para>
 			<para>The result of the application will be reported in the <variable>TRANSFERSTATUS</variable>
--- apps/confbridge/conf_config_parser.c
+++ apps/confbridge/conf_config_parser.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400741 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407857 $")
 #include "asterisk/logger.h"
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -286,6 +286,12 @@
 	} else if (!strcasecmp(sound_name, "sound_other_in_party")) {
 		ast_string_field_set(sounds, otherinparty, sound_file);
 	} else if (!strcasecmp(sound_name, "sound_place_into_conference")) {
+		static int deprecation_warning = 1;
+		if (deprecation_warning) {
+			ast_log(LOG_WARNING, "sound_place_into_conference is deprecated"
+				" and unused. Use sound_begin for similar functionality.");
+			deprecation_warning = 0;
+		}
 		ast_string_field_set(sounds, placeintoconf, sound_file);
 	} else if (!strcasecmp(sound_name, "sound_wait_for_leader")) {
 		ast_string_field_set(sounds, waitforleader, sound_file);
@@ -311,6 +317,8 @@
 		ast_string_field_set(sounds, participantsmuted, sound_file);
 	} else if (!strcasecmp(sound_name, "sound_participants_unmuted")) {
 		ast_string_field_set(sounds, participantsunmuted, sound_file);
+	} else if (!strcasecmp(sound_name, "sound_begin")) {
+		ast_string_field_set(sounds, begin, sound_file);
 	} else {
 		return -1;
 	}
@@ -924,6 +932,7 @@
 	ast_cli(a->fd,"sound_leave:          %s\n", conf_get_sound(CONF_SOUND_LEAVE, b_profile.sounds));
 	ast_cli(a->fd,"sound_participants_muted:     %s\n", conf_get_sound(CONF_SOUND_PARTICIPANTS_MUTED, b_profile.sounds));
 	ast_cli(a->fd,"sound_participants_unmuted:     %s\n", conf_get_sound(CONF_SOUND_PARTICIPANTS_UNMUTED, b_profile.sounds));
+	ast_cli(a->fd,"sound_begin:          %s\n", conf_get_sound(CONF_SOUND_BEGIN, b_profile.sounds));
 	ast_cli(a->fd,"\n");
 
 	conf_bridge_profile_destroy(&b_profile);
@@ -1266,6 +1275,7 @@
 	ast_string_field_set(sounds, leave, b_profile->sounds->leave);
 	ast_string_field_set(sounds, participantsmuted, b_profile->sounds->participantsmuted);
 	ast_string_field_set(sounds, participantsunmuted, b_profile->sounds->participantsunmuted);
+	ast_string_field_set(sounds, begin, b_profile->sounds->begin);
 
 	ao2_ref(b_profile->sounds, -1); /* sounds struct copied over to it from the template by reference only. */
 	ao2_ref(oldsounds, -1);    /* original sounds struct we don't need anymore */
--- apps/confbridge/conf_state.c
+++ apps/confbridge/conf_state.c
@@ -74,6 +74,9 @@
 void conf_default_leave_waitmarked(struct conference_bridge_user *cbu)
 {
 	conf_remove_user_waiting(cbu->conference_bridge, cbu);
+	if (cbu->playing_moh) {
+		conf_moh_stop(cbu);
+	}
 }
 
 void conf_change_state(struct conference_bridge_user *cbu, struct conference_state *newstate)
--- apps/confbridge/conf_state_empty.c
+++ apps/confbridge/conf_state_empty.c
@@ -73,7 +73,6 @@
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
 	conf_handle_first_join(cbu->conference_bridge);
-	conf_add_post_join_action(cbu, conf_handle_first_marked_common);
 
 	conf_change_state(cbu, CONF_STATE_SINGLE_MARKED);
 }
--- apps/confbridge/conf_state_inactive.c
+++ apps/confbridge/conf_state_inactive.c
@@ -68,7 +68,7 @@
 
 static void leave_waitmarked(struct conference_bridge_user *cbu)
 {
-	conf_remove_user_waiting(cbu->conference_bridge, cbu);
+	conf_default_leave_waitmarked(cbu);
 	if (cbu->conference_bridge->waitingusers == 0) {
 		conf_change_state(cbu, CONF_STATE_EMPTY);
 	}
--- apps/confbridge/conf_state_multi_marked.c
+++ apps/confbridge/conf_state_multi_marked.c
@@ -169,14 +169,21 @@
 	}
 }
 
+static int post_join_play_begin(struct conference_bridge_user *cbu)
+{
+	int res;
+
+	ast_autoservice_start(cbu->chan);
+	res = play_sound_file(cbu->conference_bridge,
+		conf_get_sound(CONF_SOUND_BEGIN, cbu->b_profile.sounds));
+	ast_autoservice_stop(cbu->chan);
+	return res;
+}
+
 static void transition_to_marked(struct conference_bridge_user *cbu)
 {
 	struct conference_bridge_user *cbu_iter;
-
-	/* Play the audio file stating they are going to be placed into the conference */
-	if (cbu->conference_bridge->markedusers == 1 && ast_test_flag(&cbu->u_profile, USER_OPT_MARKEDUSER)) {
-		conf_handle_first_marked_common(cbu);
-	}
+	int waitmarked_moved = 0;
 
 	/* Move all waiting users to active, stopping MOH and unmuting if necessary */
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&cbu->conference_bridge->waiting_list, cbu_iter, list) {
@@ -188,6 +195,15 @@
 			conf_moh_stop(cbu_iter);
 		}
 		conf_update_user_mute(cbu_iter);
+		waitmarked_moved++;
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
+
+	/* Play the audio file stating that the conference is beginning */
+	if (cbu->conference_bridge->markedusers == 1
+		&& ast_test_flag(&cbu->u_profile, USER_OPT_MARKEDUSER)
+		&& !ast_test_flag(&cbu->u_profile, USER_OPT_QUIET)
+		&& waitmarked_moved) {
+		conf_add_post_join_action(cbu, post_join_play_begin);
+	}
 }
--- apps/confbridge/conf_state_single.c
+++ apps/confbridge/conf_state_single.c
@@ -72,6 +72,9 @@
 static void leave_unmarked(struct conference_bridge_user *cbu)
 {
 	conf_remove_user_active(cbu->conference_bridge, cbu);
+	if (cbu->playing_moh) {
+		conf_moh_stop(cbu);
+	}
 
 	if (cbu->conference_bridge->waitingusers) {
 		conf_change_state(cbu, CONF_STATE_INACTIVE);
--- apps/confbridge/conf_state_single_marked.c
+++ apps/confbridge/conf_state_single_marked.c
@@ -71,6 +71,9 @@
 static void leave_marked(struct conference_bridge_user *cbu)
 {
 	conf_remove_user_marked(cbu->conference_bridge, cbu);
+	if (cbu->playing_moh) {
+		conf_moh_stop(cbu);
+	}
 
 	conf_change_state(cbu, CONF_STATE_EMPTY);
 }
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -160,6 +160,7 @@
 	CONF_SOUND_LEAVE,
 	CONF_SOUND_PARTICIPANTS_MUTED,
 	CONF_SOUND_PARTICIPANTS_UNMUTED,
+	CONF_SOUND_BEGIN,
 };
 
 struct bridge_profile_sounds {
@@ -186,6 +187,7 @@
 		AST_STRING_FIELD(join);
 		AST_STRING_FIELD(participantsmuted);
 		AST_STRING_FIELD(participantsunmuted);
+		AST_STRING_FIELD(begin);
 	);
 };
 
@@ -396,13 +398,6 @@
  */
 void conf_mute_only_active(struct conference_bridge *conference_bridge);
 
-/*! \brief Callback to execute any time we transition from zero to one marked users
- * \param cbu The first marked user joining the conference
- * \retval 0 success
- * \retval -1 failure
- */
-int conf_handle_first_marked_common(struct conference_bridge_user *cbu);
-
 /*! \brief Callback to execute any time we transition from zero to one active users
  * \param conference_bridge The conference bridge with a single active user joined
  * \retval 0 success
--- cdr/cdr_radius.c
+++ cdr/cdr_radius.c
@@ -34,9 +34,13 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 328259 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 406802 $")
 
+#ifdef FREERADIUS_CLIENT
+#include <freeradius-client.h>
+#else
 #include <radiusclient-ng.h>
+#endif
 
 #include "asterisk/channel.h"
 #include "asterisk/cdr.h"
@@ -82,7 +86,11 @@
 static const char name[] = "radius";
 static const char cdr_config[] = "cdr.conf";
 
+#ifdef FREERADIUS_CLIENT
+static char radiuscfg[PATH_MAX] = "/etc/radiusclient/radiusclient.conf";
+#else
 static char radiuscfg[PATH_MAX] = "/etc/radiusclient-ng/radiusclient.conf";
+#endif
 
 static struct ast_flags global_flags = { RADIUS_FLAG_USEGMTIME | RADIUS_FLAG_LOGUNIQUEID | RADIUS_FLAG_LOGUSERFIELD };
 
--- cel/cel_manager.c
+++ cel/cel_manager.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 353648 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405582 $")
 
 #include "asterisk/channel.h"
 #include "asterisk/cel.h"
@@ -153,7 +153,12 @@
 		return 0;
 	}
 
-	if (!cfg) {
+	if (cfg == CONFIG_STATUS_FILEINVALID) {
+		ast_log(LOG_WARNING, "Configuration file '%s' is invalid. CEL manager Module not activated.\n",
+			CONF_FILE);
+		enablecel = 0;
+		return -1;
+	} else if (!cfg) {
 		ast_log(LOG_WARNING, "Failed to load configuration file. CEL manager Module not activated.\n");
 		enablecel = 0;
 		return -1;
--- cel/cel_radius.c
+++ cel/cel_radius.c
@@ -33,9 +33,13 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Rev: 328259 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Rev: 406802 $")
 
+#ifdef FREERADIUS_CLIENT
+#include <freeradius-client.h>
+#else
 #include <radiusclient-ng.h>
+#endif
 
 #include "asterisk/channel.h"
 #include "asterisk/cel.h"
@@ -79,7 +83,11 @@
 
 static char *cel_config = "cel.conf";
 
+#ifdef FREERADIUS_CLIENT
+static char radiuscfg[PATH_MAX] = "/etc/radiusclient/radiusclient.conf";
+#else
 static char radiuscfg[PATH_MAX] = "/etc/radiusclient-ng/radiusclient.conf";
+#endif
 
 static struct ast_flags global_flags = { RADIUS_FLAG_USEGMTIME | RADIUS_FLAG_LOGUNIQUEID | RADIUS_FLAG_LOGUSERFIELD };
 
--- channels/chan_dahdi.c
+++ channels/chan_dahdi.c
@@ -49,7 +49,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404785 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407818 $")
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <pthread.h>
@@ -3215,6 +3215,8 @@
 #endif	/* defined(HAVE_PRI) */
 
 #if defined(HAVE_PRI)
+static int pri_destroy_dchan(struct sig_pri_span *pri);
+
 static void my_handle_dchan_exception(struct sig_pri_span *pri, int index)
 {
 	int x;
@@ -3242,6 +3244,9 @@
 	case DAHDI_EVENT_NOALARM:
 		pri_event_noalarm(pri, index, 0);
 		break;
+	case DAHDI_EVENT_REMOVED:
+		pri_destroy_dchan(pri);
+		break;
 	default:
 		break;
 	}
@@ -14899,6 +14904,97 @@
 #endif	/* defined(HAVE_PRI) */
 
 #if defined(HAVE_PRI)
+#define container_of(ptr, type, member) \
+	((type *)((char *)(ptr) - offsetof(type, member)))
+/*!
+ * \internal
+ * \brief Destroy a D-Channel of a PRI span
+ * \since 12
+ *
+ * \param pri the pri span
+ *
+ * \return TRUE if the span was valid and we attempted destroying.
+ *
+ * Shuts down a span and destroys its D-Channel. Further destruction
+ * of the B-channels using dahdi_destroy_channel() would probably be required
+ * for the B-Channels.
+ */
+static int pri_destroy_dchan(struct sig_pri_span *pri)
+{
+	int i;
+	struct dahdi_pri* dahdi_pri;
+
+	if (!pri->master || (pri->master == AST_PTHREADT_NULL)) {
+		return 0;
+	}
+	pthread_cancel(pri->master);
+	pthread_join(pri->master, NULL);
+
+	/* The 'struct dahdi_pri' that contains our 'struct sig_pri_span' */
+	dahdi_pri = container_of(pri, struct dahdi_pri, pri);
+	for (i = 0; i < SIG_PRI_NUM_DCHANS; i++) {
+		ast_debug(4, "closing pri_fd %d\n", i);
+		dahdi_close_pri_fd(dahdi_pri, i);
+	}
+	pri->pri = NULL;
+	ast_debug(1, "PRI span %d destroyed\n", pri->span);
+	return 1;
+}
+
+static char *handle_pri_destroy_span(struct ast_cli_entry *e, int cmd,
+		struct ast_cli_args *a)
+{
+	int span;
+	int i;
+	int res;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "pri destroy span";
+		e->usage =
+			"Usage: pri destroy span <span>\n"
+			"       Destorys D-channel of span and its B-channels.\n"
+			"	DON'T USE THIS UNLESS YOU KNOW WHAT YOU ARE DOING.\n";
+		return NULL;
+	case CLI_GENERATE:
+		return complete_span_4(a->line, a->word, a->pos, a->n);
+	}
+
+	if (a->argc < 4) {
+		return CLI_SHOWUSAGE;
+	}
+	res = sscanf(a->argv[3], "%30d", &span);
+	if ((res != 1) || span < 1 || span > NUM_SPANS) {
+		ast_cli(a->fd,
+			"Invalid span '%s'.  Should be a number from %d to %d\n",
+			a->argv[3], 1, NUM_SPANS);
+		return CLI_SUCCESS;
+	}
+	if (!pris[span - 1].pri.pri) {
+		ast_cli(a->fd, "No PRI running on span %d\n", span);
+		return CLI_SUCCESS;
+	}
+
+	for (i = 0; i < pris[span - 1].pri.numchans; i++) {
+		int channel;
+		struct sig_pri_chan *pvt = pris[span - 1].pri.pvts[i];
+
+		if (!pvt) {
+			continue;
+		}
+		channel = pvt->channel;
+		ast_debug(2, "About to destroy B-channel %d.\n", channel);
+		dahdi_destroy_channel_bynum(channel);
+	}
+	ast_debug(2, "About to destroy D-channel of span %d.\n", span);
+	pri_destroy_dchan(&pris[span - 1].pri);
+
+	return CLI_SUCCESS;
+}
+
+#endif	/* defined(HAVE_PRI) */
+
+#if defined(HAVE_PRI)
 static char *handle_pri_show_span(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
 	int span;
@@ -15004,6 +15100,7 @@
 	AST_CLI_DEFINE(handle_pri_show_channels, "Displays PRI channel information"),
 	AST_CLI_DEFINE(handle_pri_show_spans, "Displays PRI span information"),
 	AST_CLI_DEFINE(handle_pri_show_span, "Displays PRI span information"),
+	AST_CLI_DEFINE(handle_pri_destroy_span, "Destroy a PRI span"),
 	AST_CLI_DEFINE(handle_pri_show_debug, "Displays current PRI debug settings"),
 	AST_CLI_DEFINE(handle_pri_set_debug_file, "Sends PRI debug output to the specified file"),
 	AST_CLI_DEFINE(handle_pri_version, "Displays libpri version"),
--- channels/chan_iax2.c
+++ channels/chan_iax2.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407765 $")
 
 #include <sys/mman.h>
 #include <dirent.h>
@@ -1303,6 +1303,92 @@
 	}
 }
 
+/*!
+ * \internal
+ * \brief Check if a control subtype is allowed on the wire.
+ *
+ * \param subtype Control frame subtype to check if allowed to/from the wire.
+ *
+ * \retval non-zero if allowed.
+ */
+static int iax2_is_control_frame_allowed(int subtype)
+{
+	enum ast_control_frame_type control = subtype;
+	int is_allowed;
+
+	/*
+	 * Note: If we compare the enumeration type, which does not have any
+	 * negative constants, the compiler may optimize this code away.
+	 * Therefore, we must perform an integer comparison here.
+	 */
+	if (subtype == -1) {
+		return -1;
+	}
+
+	/* Default to not allowing control frames to pass. */
+	is_allowed = 0;
+
+	/*
+	 * The switch default is not present in order to take advantage
+	 * of the compiler complaining of a missing enum case.
+	 */
+	switch (control) {
+	/*
+	 * These control frames make sense to send/receive across the link.
+	 */
+	case AST_CONTROL_HANGUP:
+	case AST_CONTROL_RING:
+	case AST_CONTROL_RINGING:
+	case AST_CONTROL_ANSWER:
+	case AST_CONTROL_BUSY:
+	case AST_CONTROL_TAKEOFFHOOK:
+	case AST_CONTROL_OFFHOOK:
+	case AST_CONTROL_CONGESTION:
+	case AST_CONTROL_FLASH:
+	case AST_CONTROL_WINK:
+	case AST_CONTROL_OPTION:
+	case AST_CONTROL_RADIO_KEY:
+	case AST_CONTROL_RADIO_UNKEY:
+	case AST_CONTROL_PROGRESS:
+	case AST_CONTROL_PROCEEDING:
+	case AST_CONTROL_HOLD:
+	case AST_CONTROL_UNHOLD:
+	case AST_CONTROL_VIDUPDATE:
+	case AST_CONTROL_CONNECTED_LINE:
+	case AST_CONTROL_REDIRECTING:
+	case AST_CONTROL_T38_PARAMETERS:
+	case AST_CONTROL_AOC:
+	case AST_CONTROL_INCOMPLETE:
+	case AST_CONTROL_MCID:
+		is_allowed = -1;
+		break;
+
+	/*
+	 * These control frames do not make sense to send/receive across the link.
+	 */
+	case _XXX_AST_CONTROL_T38:
+		/* The control value is deprecated in favor of AST_CONTROL_T38_PARAMETERS. */
+	case AST_CONTROL_SRCUPDATE:
+		/* Across an IAX link the source is still the same. */
+	case AST_CONTROL_TRANSFER:
+		/* A success/fail status report from calling ast_transfer() on this machine. */
+	case AST_CONTROL_CC:
+		/* The payload contains pointers that are valid for the sending machine only. */
+	case AST_CONTROL_SRCCHANGE:
+		/* Across an IAX link the source is still the same. */
+	case AST_CONTROL_READ_ACTION:
+		/* The action can only be done by the sending machine. */
+	case AST_CONTROL_END_OF_Q:
+		/* This frame would cause the call to unexpectedly hangup. */
+	case AST_CONTROL_UPDATE_RTP_PEER:
+		/* Only meaningful across a bridge on this machine for direct-media exchange. */
+	case AST_CONTROL_PVT_CAUSE_CODE:
+		/* Intended only for the sending machine's local channel structure. */
+		break;
+	}
+	return is_allowed;
+}
+
 static void mwi_event_cb(const struct ast_event *event, void *userdata)
 {
 	/* The MWI subscriptions exist just so the core knows we care about those
@@ -5602,7 +5688,7 @@
 			unlock_both(callno0, callno1);
 			return AST_BRIDGE_FAILED_NOWARN;
 		}
-		/* check if transfered and if we really want native bridging */
+		/* check if transferred and if we really want native bridging */
 		if (!transferstarted && !ast_test_flag64(iaxs[callno0], IAX_NOTRANSFER) && !ast_test_flag64(iaxs[callno1], IAX_NOTRANSFER)) {
 			/* Try the transfer */
 			if (iax2_start_transfer(callno0, callno1, (flags & (AST_BRIDGE_DTMF_CHANNEL_0 | AST_BRIDGE_DTMF_CHANNEL_1)) ||
@@ -5752,8 +5838,13 @@
 		}
 		break;
 	case AST_CONTROL_CONNECTED_LINE:
-		if (!ast_test_flag64(pvt, IAX_SENDCONNECTEDLINE))
+	case AST_CONTROL_REDIRECTING:
+		if (!ast_test_flag64(pvt, IAX_SENDCONNECTEDLINE)) {
+			/* We are not configured to allow sending these updates. */
+			ast_debug(2, "Callno %u: Config blocked sending control frame %d.\n",
+				callno, condition);
 			goto done;
+		}
 		break;
 	case AST_CONTROL_PVT_CAUSE_CODE:
 		res = -1;
@@ -7599,6 +7690,12 @@
 
 static int send_command(struct chan_iax2_pvt *i, char type, int command, unsigned int ts, const unsigned char *data, int datalen, int seqno)
 {
+	if (type == AST_FRAME_CONTROL && !iax2_is_control_frame_allowed(command)) {
+		/* Control frame should not go out on the wire. */
+		ast_debug(2, "Callno %u: Blocked sending control frame %d.\n",
+			i->callno, command);
+		return 0;
+	}
 	return __send_command(i, type, command, ts, data, datalen, seqno, 0, 0, 0);
 }
 
@@ -10566,13 +10663,6 @@
 				iaxs[fr->callno]->videoformat = ast_format_to_old_bitfield(&f.subclass.format);
 			}
 		}
-		if (f.frametype == AST_FRAME_CONTROL && iaxs[fr->callno]->owner) {
-			if (f.subclass.integer == AST_CONTROL_BUSY) {
-				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);
-			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {
-				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);
-			}
-		}
 		if (f.frametype == AST_FRAME_IAX) {
 			AST_SCHED_DEL(sched, iaxs[fr->callno]->initid);
 			/* Handle the IAX pseudo frame itself */
@@ -11777,23 +11867,58 @@
 		fr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | ntohs(mh->ts);
 		/* FIXME? Surely right here would be the right place to undo timestamp wraparound? */
 	}
+
 	/* Don't pass any packets until we're started */
-	if (!ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {
+	if (!iaxs[fr->callno]
+		|| !ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {
 		ast_variables_destroy(ies.vars);
 		ast_mutex_unlock(&iaxsl[fr->callno]);
 		return 1;
 	}
-	/* Don't allow connected line updates unless we are configured to */
-	if (f.frametype == AST_FRAME_CONTROL && f.subclass.integer == AST_CONTROL_CONNECTED_LINE) {
-		struct ast_party_connected_line connected;
 
-		if (!ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)) {
+	if (f.frametype == AST_FRAME_CONTROL) {
+		if (!iax2_is_control_frame_allowed(f.subclass.integer)) {
+			/* Control frame not allowed to come from the wire. */
+			ast_debug(2, "Callno %u: Blocked receiving control frame %d.\n",
+				fr->callno, f.subclass.integer);
 			ast_variables_destroy(ies.vars);
 			ast_mutex_unlock(&iaxsl[fr->callno]);
 			return 1;
 		}
+		if (f.subclass.integer == AST_CONTROL_CONNECTED_LINE
+			|| f.subclass.integer == AST_CONTROL_REDIRECTING) {
+			if (iaxs[fr->callno]
+				&& !ast_test_flag64(iaxs[fr->callno], IAX_RECVCONNECTEDLINE)) {
+				/* We are not configured to allow receiving these updates. */
+				ast_debug(2, "Callno %u: Config blocked receiving control frame %d.\n",
+					fr->callno, f.subclass.integer);
+				ast_variables_destroy(ies.vars);
+				ast_mutex_unlock(&iaxsl[fr->callno]);
+				return 1;
+			}
+		}
 
-		/* Initialize defaults */
+		iax2_lock_owner(fr->callno);
+		if (iaxs[fr->callno] && iaxs[fr->callno]->owner) {
+			if (f.subclass.integer == AST_CONTROL_BUSY) {
+				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_BUSY);
+			} else if (f.subclass.integer == AST_CONTROL_CONGESTION) {
+				ast_channel_hangupcause_set(iaxs[fr->callno]->owner, AST_CAUSE_CONGESTION);
+			}
+			ast_channel_unlock(iaxs[fr->callno]->owner);
+		}
+	}
+
+	if (f.frametype == AST_FRAME_CONTROL
+		&& f.subclass.integer == AST_CONTROL_CONNECTED_LINE
+		&& iaxs[fr->callno]) {
+		struct ast_party_connected_line connected;
+
+		/*
+		 * Process a received connected line update.
+		 *
+		 * Initialize defaults.
+		 */
 		ast_party_connected_line_init(&connected);
 		connected.id.number.presentation = iaxs[fr->callno]->calling_pres;
 		connected.id.name.presentation = iaxs[fr->callno]->calling_pres;
@@ -11816,6 +11941,7 @@
 		}
 		ast_party_connected_line_free(&connected);
 	}
+
 	/* Common things */
 	f.src = "IAX2";
 	f.mallocd = 0;
@@ -11841,9 +11967,11 @@
 		fr->outoforder = -1;
 	}
 	fr->cacheable = ((f.frametype == AST_FRAME_VOICE) || (f.frametype == AST_FRAME_VIDEO));
-	duped_fr = iaxfrdup2(fr);
-	if (duped_fr) {
-		schedule_delivery(duped_fr, updatehistory, 0, &fr->ts);
+	if (iaxs[fr->callno]) {
+		duped_fr = iaxfrdup2(fr);
+		if (duped_fr) {
+			schedule_delivery(duped_fr, updatehistory, 0, &fr->ts);
+		}
 	}
 	if (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts) {
 		iaxs[fr->callno]->last = fr->ts;
--- channels/chan_local.c
+++ channels/chan_local.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 378321 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407457 $")
 
 #include <fcntl.h>
 #include <sys/signal.h>
@@ -1006,7 +1006,7 @@
 		      "LocalOptimization: %s\r\n",
 			ast_channel_name(p->owner), ast_channel_name(p->chan), ast_channel_uniqueid(p->owner), ast_channel_uniqueid(p->chan),
 			p->context, p->exten,
-			ast_test_flag(p, LOCAL_NO_OPTIMIZATION) ? "Yes" : "No");
+			ast_test_flag(p, LOCAL_NO_OPTIMIZATION) ? "No" : "Yes");
 
 
 	/* Start switch on sub channel */
--- channels/chan_mgcp.c
+++ channels/chan_mgcp.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401538 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 406038 $")
 
 #include <sys/socket.h>
 #include <sys/ioctl.h>
@@ -200,7 +200,8 @@
 
 static int adsi = 0;
 
-static unsigned int oseq;
+static unsigned int oseq_global = 0;
+AST_MUTEX_DEFINE_STATIC(oseq_lock);
 
 /*! Wait up to 16 seconds for first digit (FXO logic) */
 static int firstdigittimeout = 16000;
@@ -2111,7 +2112,7 @@
 	return 0;
 }
 
-static int init_req(struct mgcp_endpoint *p, struct mgcp_request *req, char *verb)
+static int init_req(struct mgcp_endpoint *p, struct mgcp_request *req, char *verb, unsigned int oseq)
 {
 	/* Initialize a response */
 	if (req->headers || req->len) {
@@ -2144,13 +2145,17 @@
 
 static int reqprep(struct mgcp_request *req, struct mgcp_endpoint *p, char *verb)
 {
+	unsigned int oseq;
 	memset(req, 0, sizeof(struct mgcp_request));
-	oseq++;
-	if (oseq > 999999999) {
-		oseq = 1;
+	ast_mutex_lock(&oseq_lock);
+	oseq_global++;
+	if (oseq_global > 999999999) {
+		oseq_global = 1;
 	}
-	init_req(p, req, verb);
-	return 0;
+	oseq = oseq_global;
+	ast_mutex_unlock(&oseq_lock);
+	init_req(p, req, verb, oseq);
+	return oseq;
 }
 
 static int transmit_response(struct mgcp_subchannel *sub, char *msg, struct mgcp_request *req, char *msgrest)
@@ -2288,6 +2293,7 @@
 	struct mgcp_endpoint *p = sub->parent;
 	struct ast_format tmpfmt;
 	struct ast_sockaddr sub_tmpdest_tmp;
+	unsigned int oseq;
 
 	if (ast_strlen_zero(sub->cxident) && rtp) {
 		/* We don't have a CXident yet, store the destination and
@@ -2324,7 +2330,7 @@
 	}
 
 
-	reqprep(&resp, p, "MDCX");
+	oseq = reqprep(&resp, p, "MDCX");
 	add_header(&resp, "C", sub->callid);
 	add_header(&resp, "L", local);
 	add_header(&resp, "M", mgcp_cxmodes[sub->cxmode]);
@@ -2346,6 +2352,7 @@
 	char tmp[80];
 	struct ast_format tmpfmt;
 	struct mgcp_endpoint *p = sub->parent;
+	unsigned int oseq;
 
 	ast_debug(3, "Creating connection for %s@%s-%d in cxmode: %s callid: %s\n",
 		 p->name, p->parent->name, sub->id, mgcp_cxmodes[sub->cxmode], sub->callid);
@@ -2372,7 +2379,7 @@
 		}
 	}
 	sub->sdpsent = 1;
-	reqprep(&resp, p, "CRCX");
+	oseq = reqprep(&resp, p, "CRCX");
 	add_header(&resp, "C", sub->callid);
 	add_header(&resp, "L", local);
 	add_header(&resp, "M", mgcp_cxmodes[sub->cxmode]);
@@ -2443,6 +2450,7 @@
 	char tmp[80];
 	struct ast_format tmpfmt;
 	struct mgcp_endpoint *p = sub->parent;
+	unsigned int oseq;
 
 	ast_copy_string(local, "p:20, s:off, e:on", sizeof(local));
 
@@ -2458,7 +2466,7 @@
 	ast_debug(3, "Creating connection for %s@%s-%d in cxmode: %s callid: %s\n",
 		    p->name, p->parent->name, sub->id, mgcp_cxmodes[sub->cxmode], sub->callid);
 	sub->sdpsent = 0;
-	reqprep(&resp, p, "CRCX");
+	oseq = reqprep(&resp, p, "CRCX");
 	add_header(&resp, "C", sub->callid);
 	add_header(&resp, "L", local);
 	add_header(&resp, "M", "inactive");
@@ -2475,11 +2483,12 @@
 {
 	struct mgcp_request resp;
 	struct mgcp_endpoint *p = sub->parent;
+	unsigned int oseq;
 
 	ast_debug(3, "MGCP Asked to indicate tone: %s on  %s@%s-%d in cxmode: %s\n",
 		tone, p->name, p->parent->name, sub->id, mgcp_cxmodes[sub->cxmode]);
 	ast_copy_string(p->curtone, tone, sizeof(p->curtone));
-	reqprep(&resp, p, "RQNT");
+	oseq = reqprep(&resp, p, "RQNT");
 	add_header(&resp, "X", p->rqnt_ident);
 	switch (p->hookstate) {
 	case MGCP_ONHOOK:
@@ -2506,6 +2515,7 @@
 	struct timeval t = ast_tvnow();
 	struct ast_tm tm;
 	struct mgcp_endpoint *p = sub->parent;
+	unsigned int oseq;
 
 	ast_localtime(&t, &tm, NULL);
 	n = callername;
@@ -2521,7 +2531,7 @@
 	snprintf(tone2, sizeof(tone2), "%s,L/ci(%02d/%02d/%02d/%02d,%s,%s)", tone,
 		tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, l, n);
 	ast_copy_string(p->curtone, tone, sizeof(p->curtone));
-	reqprep(&resp, p, "RQNT");
+	oseq = reqprep(&resp, p, "RQNT");
 	add_header(&resp, "X", p->rqnt_ident);
 	switch (p->hookstate) {
 	case MGCP_ONHOOK:
@@ -2550,6 +2560,7 @@
 	int fc = 1;
 	char local[256];
 	char tmp[80];
+	unsigned int oseq;
 
 	if (ast_strlen_zero(sub->cxident)) {
 		/* We don't have a CXident yet, store the destination and
@@ -2585,7 +2596,7 @@
 		}
 	}
 
-	reqprep(&resp, p, "MDCX");
+	oseq = reqprep(&resp, p, "MDCX");
 	add_header(&resp, "C", sub->callid);
 	if (!sub->sdpsent) {
 		add_header(&resp, "L", local);
@@ -2644,7 +2655,8 @@
 static int transmit_audit_endpoint(struct mgcp_endpoint *p)
 {
 	struct mgcp_request resp;
-	reqprep(&resp, p, "AUEP");
+	unsigned int oseq;
+	oseq = reqprep(&resp, p, "AUEP");
 	/* removed unknown param VS */
 	/*add_header(&resp, "F", "A,R,D,S,X,N,I,T,O,ES,E,MD,M");*/
 	add_header(&resp, "F", "A");
@@ -2658,10 +2670,11 @@
 {
 	struct mgcp_endpoint *p = sub->parent;
 	struct mgcp_request resp;
+	unsigned int oseq;
 
 	ast_debug(3, "Delete connection %s %s@%s-%d with new mode: %s on callid: %s\n",
 		sub->cxident, p->name, p->parent->name, sub->id, mgcp_cxmodes[sub->cxmode], sub->callid);
-	reqprep(&resp, p, "DLCX");
+	oseq = reqprep(&resp, p, "DLCX");
 	/* check if call id is avail */
 	if (sub->callid[0])
 		add_header(&resp, "C", sub->callid);
@@ -2679,10 +2692,11 @@
 static int transmit_connection_del_w_params(struct mgcp_endpoint *p, char *callid, char *cxident)
 {
 	struct mgcp_request resp;
+	unsigned int oseq;
 
 	ast_debug(3, "Delete connection %s %s@%s on callid: %s\n",
 		cxident ? cxident : "", p->name, p->parent->name, callid ? callid : "");
-	reqprep(&resp, p, "DLCX");
+	oseq = reqprep(&resp, p, "DLCX");
 	/* check if call id is avail */
 	if (callid && *callid)
 		add_header(&resp, "C", callid);
--- channels/chan_sip.c
+++ channels/chan_sip.c
@@ -210,7 +210,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 410431 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 410311 $")
 
 #include <signal.h>
 #include <sys/signal.h>
@@ -6292,7 +6292,7 @@
 		} else if (!strcasecmp(ast_var_name(current), "SIPFROMDOMAIN")) {
 			ast_string_field_set(p, fromdomain, ast_var_value(current));
 		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER")) {
-			/* This is a transfered call */
+			/* This is a transferred call */
 			p->options->transfer = 1;
 		} else if (!strcasecmp(ast_var_name(current), "SIPTRANSFER_REFERER")) {
 			/* This is the referrer */
@@ -6349,7 +6349,7 @@
 
 		if (referer) {
 			if (sipdebug)
-				ast_debug(3, "Call for %s transfered by %s\n", p->username, referer);
+				ast_debug(3, "Call for %s transferred by %s\n", p->username, referer);
 			snprintf(buf, sizeof(buf)-1, "-> %s (via %s)", p->cid_name, referer);
 		} else
 			snprintf(buf, sizeof(buf)-1, "-> %s", p->cid_name);
@@ -7051,10 +7051,12 @@
 		ast_debug(4, "SIP Transfer: Not hanging up right now... Rescheduling hangup for %s.\n", p->callid);
 		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
 		ast_clear_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Really hang up next time */
-		ast_channel_tech_pvt_set(p->owner, dialog_unref(ast_channel_tech_pvt(p->owner), "unref p->owner->tech_pvt"));
-		sip_pvt_lock(p);
-		p->owner = NULL;  /* Owner will be gone after we return, so take it away */
-		sip_pvt_unlock(p);
+		if (p->owner) {
+			ast_channel_tech_pvt_set(p->owner, dialog_unref(ast_channel_tech_pvt(p->owner), "unref p->owner->tech_pvt"));
+			sip_pvt_lock(p);
+			p->owner = NULL;  /* Owner will be gone after we return, so take it away */
+			sip_pvt_unlock(p);
+		}
 		ast_module_unref(ast_module_info->self);
 		return 0;
 	}
@@ -7083,7 +7085,7 @@
 
 	stop_media_flows(p); /* Immediately stop RTP, VRTP and UDPTL as applicable */
 
-	append_history(p, needcancel ? "Cancel" : "Hangup", "Cause %s", p->owner ? ast_cause2str(p->hangupcause) : "Unknown");
+	append_history(p, needcancel ? "Cancel" : "Hangup", "Cause %s", ast_cause2str(p->hangupcause));
 
 	/* Disconnect */
 	disable_dsp_detect(p);
@@ -7585,7 +7587,9 @@
 			AST_SCHED_DEL_UNREF(sched, p->t38id, dialog_unref(p, "when you delete the t38id sched, you should dec the refcount for the stored dialog ptr"));
 			parameters.max_ifp = ast_udptl_get_far_max_ifp(p->udptl);
 			parameters.request_response = AST_T38_REQUEST_NEGOTIATE;
-			ast_queue_control_data(p->owner, AST_CONTROL_T38_PARAMETERS, &parameters, sizeof(parameters));
+			if (p->owner) {
+				ast_queue_control_data(p->owner, AST_CONTROL_T38_PARAMETERS, &parameters, sizeof(parameters));
+			}
 			/* we need to return a positive value here, so that applications that
 			 * send this request can determine conclusively whether it was accepted or not...
 			 * older versions of chan_sip would just silently accept it and return zero.
@@ -10382,6 +10386,18 @@
 					 * respond with the EC they want to use */
 					ast_udptl_set_error_correction_scheme(p->udptl, UDPTL_ERROR_CORRECTION_NONE);
 				}
+			} else if (sscanf(m, "image %30u %17s t38%n", &x, protocol, &len) == 2 && len > 0) {
+				ast_log(LOG_WARNING, "Declining image stream due to unsupported transport: %s\n", m);
+				/* produce zero-port m-line since this is guaranteed to be declined
+				 * length is "m=image 0 strlen(protocol) t38" + "\r\n\0" */
+				if (!(offer->decline_m_line = ast_malloc(10 + strlen(protocol) + 7))) {
+					ast_log(LOG_WARNING, "Failed to allocate memory for SDP offer declination\n");
+					res = -1;
+					goto process_sdp_cleanup;
+				}
+				/* guaranteed to be exactly the right length */
+				sprintf(offer->decline_m_line, "m=image 0 %s t38\r\n", protocol);
+				continue;
 			} else {
 				ast_log(LOG_WARNING, "Rejecting image media offer due to invalid or unsupported syntax: %s\n", m);
 				res = -1;
@@ -12494,9 +12510,9 @@
 {
 	struct ast_str *tmp = ast_str_alloca(256);
 	char tmp2[256];
-	char *lid_num = NULL;
-	char *lid_name = NULL;
-	int lid_pres = AST_PRES_NUMBER_NOT_AVAILABLE;
+	char *lid_num;
+	char *lid_name;
+	int lid_pres;
 	const char *fromdomain;
 	const char *privacy = NULL;
 	const char *screen = NULL;
@@ -12507,22 +12523,20 @@
 		return 0;
 	}
 
-	if (p->owner) {
-		connected_id = ast_channel_connected_effective_id(p->owner);
-
-		if (connected_id.number.valid) {
-			lid_num = connected_id.number.str;
-		}
-		if (connected_id.name.valid) {
-			lid_name = connected_id.name.str;
-		}
-		lid_pres = ast_party_id_presentation(&connected_id);
+	if (!p->owner) {
+		return 0;
 	}
-
-	if (ast_strlen_zero(lid_num))
+	connected_id = ast_channel_connected_effective_id(p->owner);
+	lid_num = S_COR(connected_id.number.valid, connected_id.number.str, NULL);
+	if (!lid_num) {
 		return 0;
-	if (ast_strlen_zero(lid_name))
+	}
+	lid_name = S_COR(connected_id.name.valid, connected_id.name.str, NULL);
+	if (!lid_name) {
 		lid_name = lid_num;
+	}
+	lid_pres = ast_party_id_presentation(&connected_id);
+
 	fromdomain = S_OR(p->fromdomain, ast_sockaddr_stringify_host_remote(&p->ourip));
 
 	lid_num = ast_uri_encode(lid_num, tmp2, sizeof(tmp2), ast_uri_sip_user);
@@ -17885,13 +17899,15 @@
 	}
 
 	/* Determine transfer context */
-	if (transferer->owner)	/* Mimic behaviour in res_features.c */
+	if (transferer->owner) {
+		/* By default, use the context in the channel sending the REFER */
 		transfer_context = pbx_builtin_getvar_helper(transferer->owner, "TRANSFER_CONTEXT");
-
-	/* By default, use the context in the channel sending the REFER */
+		if (ast_strlen_zero(transfer_context)) {
+			transfer_context = ast_channel_macrocontext(transferer->owner);
+		}
+	}
 	if (ast_strlen_zero(transfer_context)) {
-		transfer_context = S_OR(ast_channel_macrocontext(transferer->owner),
-					S_OR(transferer->context, sip_cfg.default_context));
+		transfer_context = S_OR(transferer->context, sip_cfg.default_context);
 	}
 
 	ast_string_field_set(refer, refer_to_context, transfer_context);
@@ -17945,14 +17961,18 @@
 	if (sip_debug_test_pvt(p))
 		ast_verbose("Looking for %s in %s\n", c, p->context);
 
-	if (p->owner)	/* Mimic behaviour in res_features.c */
+	/* Determine transfer context */
+	if (p->owner) {
+		/* By default, use the context in the channel sending the REFER */
 		transfer_context = pbx_builtin_getvar_helper(p->owner, "TRANSFER_CONTEXT");
-
-	/* By default, use the context in the channel sending the REFER */
+		if (ast_strlen_zero(transfer_context)) {
+			transfer_context = ast_channel_macrocontext(p->owner);
+		}
+	}
 	if (ast_strlen_zero(transfer_context)) {
-		transfer_context = S_OR(ast_channel_macrocontext(p->owner),
-					S_OR(p->context, sip_cfg.default_context));
+		transfer_context = S_OR(p->context, sip_cfg.default_context);
 	}
+
 	if (ast_exists_extension(NULL, transfer_context, c, 1, NULL)) {
 		/* This is a blind transfer */
 		ast_debug(1, "SIP Bye-also transfer to Extension %s@%s \n", c, transfer_context);
@@ -20079,7 +20099,7 @@
 		print_codec_to_cli(fd, &peer->prefs);
 		ast_cli(fd, ")\n");
 
-		ast_cli(fd, "  Auto-Framing :  %s \n", AST_CLI_YESNO(peer->autoframing));
+		ast_cli(fd, "  Auto-Framing : %s\n", AST_CLI_YESNO(peer->autoframing));
 		ast_cli(fd, "  Status       : ");
 		peer_status(peer, status, sizeof(status));
 		ast_cli(fd, "%s\n", status);
@@ -24436,7 +24456,9 @@
 
 	if (peera && peerb && peerc && (peerb != peerc)) {
 		ast_quiet_chan(peera);		/* Stop generators */
-		ast_quiet_chan(peerb);
+		/* no need to quiet peerb since it should be hungup after the
+		   transfer and the masquerade needs to be able to see if MOH is
+		   playing on it */
 		ast_quiet_chan(peerc);
 		if (peerd)
 			ast_quiet_chan(peerd);
@@ -24568,7 +24590,7 @@
 
 		/* EventID for each transfer... EventID is basically the REFER cseq
 
-		 We are getting notifications on a call that we transfered
+		 We are getting notifications on a call that we transferred
 		 We should hangup when we are getting a 200 OK in a sipfrag
 		 Check if we have an owner of this event */
 
@@ -25570,12 +25592,6 @@
 			ast_debug(2, "No SDP in Invite, third party call control\n");
 		}
 
-		/* Queue NULL frame to prod ast_rtp_bridge if appropriate */
-		/* This seems redundant ... see !p-owner above */
-		if (p->owner)
-			ast_queue_frame(p->owner, &ast_null_frame);
-
-
 		/* Initialize the context if it hasn't been already */
 		if (ast_strlen_zero(p->context))
 			ast_string_field_set(p, context, sip_cfg.default_context);
@@ -26110,7 +26126,6 @@
 
 		ast_do_masquerade(target.chan1);
 
-		ast_indicate(target.chan1, AST_CONTROL_UNHOLD);
 		if (target.chan2) {
 			ast_indicate(target.chan2, AST_CONTROL_UNHOLD);
 		}
@@ -29957,7 +29972,7 @@
 	if (sip_cfg.callevents)
 		manager_event(EVENT_FLAG_SYSTEM, "ChannelUpdate",
 			"Channel: %s\r\nChanneltype: %s\r\nSIPcallid: %s\r\nSIPfullcontact: %s\r\nPeername: %s\r\n",
-			p->owner? ast_channel_name(p->owner) : "", "SIP", p->callid, p->fullcontact, p->peername);
+			p->owner ? ast_channel_name(p->owner) : "", "SIP", p->callid, p->fullcontact, p->peername);
 	sip_pvt_unlock(p);
 	if (!tmpc) {
 		dialog_unlink_all(p);
@@ -31195,21 +31210,26 @@
 		peer->socket.port = htons(((peer->socket.type & SIP_TRANSPORT_TLS) ? STANDARD_TLS_PORT : STANDARD_SIP_PORT));
 	}
 
-	if (!sip_cfg.ignore_regexpire && peer->host_dynamic && realtime) {
-		time_t nowtime = time(NULL);
+	if (realtime) {
+		int enablepoke = 1;
 
-		if ((nowtime - regseconds) > 0) {
-			destroy_association(peer);
-			memset(&peer->addr, 0, sizeof(peer->addr));
-			peer->lastms = -1;
-			ast_debug(1, "Bah, we're expired (%d/%d/%d)!\n", (int)(nowtime - regseconds), (int)regseconds, (int)nowtime);
+		if (!sip_cfg.ignore_regexpire && peer->host_dynamic) {
+			time_t nowtime = time(NULL);
+
+			if ((nowtime - regseconds) > 0) {
+				destroy_association(peer);
+				memset(&peer->addr, 0, sizeof(peer->addr));
+				peer->lastms = -1;
+				enablepoke = 0;
+				ast_debug(1, "Bah, we're expired (%d/%d/%d)!\n", (int)(nowtime - regseconds), (int)regseconds, (int)nowtime);
+			}
 		}
-	}
 
-	/* Startup regular pokes */
-	if (!devstate_only && realtime && peer->lastms > 0) {
-		sip_ref_peer(peer, "schedule qualify");
-		sip_poke_peer(peer, 0);
+		/* Startup regular pokes */
+		if (!devstate_only && enablepoke) {
+			sip_ref_peer(peer, "schedule qualify");
+			sip_poke_peer(peer, 0);
+		}
 	}
 
 	if (ast_test_flag(&peer->flags[1], SIP_PAGE2_ALLOWSUBSCRIBE)) {
@@ -34767,12 +34787,16 @@
 
 	ast_mutex_lock(&monlock);
 	if (monitor_thread && (monitor_thread != AST_PTHREADT_STOP) && (monitor_thread != AST_PTHREADT_NULL)) {
-		pthread_cancel(monitor_thread);
-		pthread_kill(monitor_thread, SIGURG);
-		pthread_join(monitor_thread, NULL);
+		pthread_t th = monitor_thread;
+		monitor_thread = AST_PTHREADT_STOP;
+		pthread_cancel(th);
+		pthread_kill(th, SIGURG);
+		ast_mutex_unlock(&monlock);
+		pthread_join(th, NULL);
+	} else {
+		monitor_thread = AST_PTHREADT_STOP;
+		ast_mutex_unlock(&monlock);
 	}
-	monitor_thread = AST_PTHREADT_STOP;
-	ast_mutex_unlock(&monlock);
 
 	/* Destroy all the dialogs and free their memory */
 	i = ao2_iterator_init(dialogs, 0);
--- channels/chan_unistim.c
+++ channels/chan_unistim.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396377 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409761 $")
 
 #include <sys/stat.h>
 #include <signal.h>
@@ -3192,6 +3192,11 @@
 		ast_verb(0, "Handle Call Incoming for %s@%s\n", sub->parent->name,
 					s->device->name);
 	}
+	start_rtp(sub);
+	if (!sub->rtp) {
+		ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", sub->parent->name, s->device->name);
+		return;
+	}
 	if (sub->owner) {
 		ast_queue_control(sub->owner, AST_CONTROL_ANSWER);
 	}
@@ -4421,7 +4426,7 @@
 	}
 	if (memcmp(buf + SIZE_HEADER, packet_recv_pick_up, sizeof(packet_recv_pick_up)) == 0) {
 		if (unistimdebug) {
-			ast_verb(0, "Handset off hook\n");
+			ast_verb(0, "Handset off hook, current state: %s\n", ptestate_tostr(pte->state));
 		}
 		if (!pte->device) {	       /* We are not yet registered (asking for a TN in AUTOPROVISIONING_TN) */
 			return;
@@ -4447,7 +4452,7 @@
 	}
 	if (memcmp(buf + SIZE_HEADER, packet_recv_hangup, sizeof(packet_recv_hangup)) == 0) {
 		if (unistimdebug) {
-			ast_verb(0, "Handset on hook\n");
+			ast_verb(0, "Handset on hook, current state: %s\n", ptestate_tostr(pte->state));
 		}
 		if (!pte->device) {
 			return;
@@ -4824,7 +4829,7 @@
 		unistim_unalloc_sub(d, sub);
 		return 0;
 	}
-	if (sub_real && (sub_real->owner) && (sub->subtype == SUB_THREEWAY)) { /* 3way call cancelled by softkey pressed */
+	if (sub_real && (sub_real->owner) && (sub->subtype == SUB_THREEWAY) && (s->state == STATE_CALL)) { /* 3way call cancelled by softkey pressed */
 		if (unistimdebug) {
 			ast_verb(0, "Real call disconnected, stay in call\n");
 		}
@@ -4912,9 +4917,6 @@
 	l = sub->parent;
 	d = l->parent;
 
-	if ((!sub->rtp) && (!get_sub(d, SUB_THREEWAY))) {
-		start_rtp(sub);
-	}
 	if (unistimdebug) {
 		ast_verb(0, "unistim_answer(%s) on %s@%s-%d\n", ast_channel_name(ast), l->name,
 					l->parent->name, sub->softkey);
@@ -5240,9 +5242,12 @@
 		if (sub->subtype == SUB_REAL) {
 			send_callerid_screen(s, sub);
 		}
+	case AST_CONTROL_UPDATE_RTP_PEER:
 		break;
 	case AST_CONTROL_SRCCHANGE:
-		ast_rtp_instance_change_source(sub->rtp);
+		if (sub->rtp) {
+			ast_rtp_instance_change_source(sub->rtp);
+		}
 		break;
 	default:
 		ast_log(LOG_WARNING, "Don't know how to indicate condition %d\n", ind);
@@ -5849,14 +5854,7 @@
 	if (unistimdebug) {
 		ast_verb(0, "unistim_request owner = %p\n", sub->owner);
 	}
-	start_rtp(sub);
-	if (!sub->rtp) {
-		ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", sub->parent->name, d->name);
-                                    return NULL;
-	}
-
 	restart_monitor();
-
 	/* and finish */
 	return tmpc;
 }
@@ -6291,6 +6289,13 @@
 		}
 		ast_mutex_init(&d->lock);
 		ast_copy_string(d->name, cat, sizeof(d->name));
+		d->contrast = -1;
+		d->output = OUTPUT_HANDSET;
+		d->previous_output = OUTPUT_HANDSET;
+		d->volume = VOLUME_LOW;
+		d->mute = MUTE_OFF;
+		d->height = DEFAULTHEIGHT;
+		d->selected = -1;
 	} else {
 		/* Delete existing line information */
 		AST_LIST_LOCK(&d->lines);
@@ -6310,14 +6315,7 @@
 		memset(d->sline, 0, sizeof(d->sline));
 		memset(d->sp, 0, sizeof(d->sp));
 	}
-
 	ast_copy_string(d->context, DEFAULTCONTEXT, sizeof(d->context));
-	d->contrast = -1;
-	d->output = OUTPUT_HANDSET;
-	d->previous_output = OUTPUT_HANDSET;
-	d->volume = VOLUME_LOW;
-	d->mute = MUTE_OFF;
-	d->height = DEFAULTHEIGHT;
 	d->selected = -1;
 	d->interdigit_timer = DEFAULT_INTERDIGIT_TIMER;
 	linelabel[0] = '\0';
@@ -6849,15 +6847,51 @@
 {
 	struct unistim_subchannel *sub = ast_channel_tech_pvt(chan);
 
+	if (!sub) {
+		return AST_RTP_GLUE_RESULT_FORBID;
+	}
+	if (!sub->rtp) {
+		return AST_RTP_GLUE_RESULT_FORBID;
+	}
+
 	ao2_ref(sub->rtp, +1);
 	*instance = sub->rtp;
 
 	return AST_RTP_GLUE_RESULT_LOCAL;
 }
 
+static int unistim_set_rtp_peer(struct ast_channel *chan, struct ast_rtp_instance *rtp, struct ast_rtp_instance *vrtp, struct ast_rtp_instance *trtp, const struct ast_format_cap *codecs, int nat_active)
+{
+	struct unistim_subchannel *sub;
+	struct sockaddr_in them = { 0, };
+	struct sockaddr_in us = { 0, };
+
+	if (!rtp) {
+		return 0;
+	}
+	
+	sub = ast_channel_tech_pvt(chan);
+	if (!sub) {
+		ast_log(LOG_ERROR, "No Private Structure, this is bad\n");
+		return -1;
+	}
+	{
+		struct ast_sockaddr tmp;
+		ast_rtp_instance_get_remote_address(rtp, &tmp);
+		ast_sockaddr_to_sin(&tmp, &them);
+		ast_rtp_instance_get_local_address(rtp, &tmp);
+		ast_sockaddr_to_sin(&tmp, &us);
+	}
+	
+	/* TODO: Set rtp on phone in case of direct rtp (not implemented) */
+	
+	return 0;
+}
+
 static struct ast_rtp_glue unistim_rtp_glue = {
 	.type = channel_type,
 	.get_rtp_info = unistim_get_rtp_peer,
+	.update_peer = unistim_set_rtp_peer,
 };
 
 /*--- load_module: PBX load module - initialization ---*/
--- channels/sig_pri.c
+++ channels/sig_pri.c
@@ -665,12 +665,7 @@
  */
 static void sig_pri_set_subaddress(struct ast_party_subaddress *ast_subaddress, const struct pri_party_subaddress *pri_subaddress)
 {
-	char *cnum, *ptr;
-	int x, len;
-
-	if (ast_subaddress->str) {
-		ast_free(ast_subaddress->str);
-	}
+	ast_free(ast_subaddress->str);
 	if (pri_subaddress->length <= 0) {
 		ast_party_subaddress_init(ast_subaddress);
 		return;
@@ -680,8 +675,14 @@
 		/* NSAP */
 		ast_subaddress->str = ast_strdup((char *) pri_subaddress->data);
 	} else {
+		char *cnum;
+		char *ptr;
+		int x;
+		int len;
+
 		/* User Specified */
-		if (!(cnum = ast_malloc(2 * pri_subaddress->length + 1))) {
+		cnum = ast_malloc(2 * pri_subaddress->length + 1);
+		if (!cnum) {
 			ast_party_subaddress_init(ast_subaddress);
 			return;
 		}
@@ -4213,14 +4214,11 @@
 
 				pri->pvts[chanpos]->cid_subaddr[0] = '\0';
 #if defined(HAVE_PRI_SUBADDR)
-				if (ast_connected.id.subaddress.valid) {
-					ast_party_subaddress_set(&ast_channel_caller(owner)->id.subaddress,
-						&ast_connected.id.subaddress);
-					if (ast_connected.id.subaddress.str) {
-						ast_copy_string(pri->pvts[chanpos]->cid_subaddr,
-							ast_connected.id.subaddress.str,
-							sizeof(pri->pvts[chanpos]->cid_subaddr));
-					}
+				if (ast_connected.id.subaddress.str) {
+					ast_copy_string(pri->pvts[chanpos]->cid_subaddr,
+						ast_connected.id.subaddress.str,
+						sizeof(pri->pvts[chanpos]->cid_subaddr));
+					caller_id_update = 1;
 				}
 #endif	/* defined(HAVE_PRI_SUBADDR) */
 				if (caller_id_update) {
@@ -4234,12 +4232,13 @@
 					ast_caller.id = ast_connected.id;
 					ast_caller.ani = ast_connected.id;
 					ast_channel_set_caller_event(owner, &ast_caller, NULL);
-				}
 
-				/* Update the connected line information on the other channel */
-				if (event_id != PRI_EVENT_RING) {
-					/* This connected_line update was not from a SETUP message. */
-					ast_channel_queue_connected_line_update(owner, &ast_connected, NULL);
+					/* Update the connected line information on the other channel */
+					if (event_id != PRI_EVENT_RING) {
+						/* This connected_line update was not from a SETUP message. */
+						ast_channel_queue_connected_line_update(owner, &ast_connected,
+							NULL);
+					}
 				}
 
 				ast_party_connected_line_free(&ast_connected);
--- configs/agents.conf.sample
+++ configs/agents.conf.sample
@@ -54,11 +54,6 @@
 ;
 ;musiconhold => default
 ;
-; Define the default good bye sound file for agents
-; default to vm-goodbye
-;
-;goodbye => goodbye_file
-;
 ; Define updatecdr. This is whether or not to change the source
 ; channel in the CDR record for this call to agent/agent_id so
 ; that we know which agent generates the call
--- configs/confbridge.conf.sample
+++ configs/confbridge.conf.sample
@@ -227,7 +227,9 @@
                        ; The sounds are stringed together like this.
                        ; "sound_there_are" <number of participants> "sound_other_in_party"
 ;sound_place_into_conference ; The sound played when someone is placed into the conference
-                             ; after waiting for a marked user.
+                             ; after waiting for a marked user. This sound is now deprecated
+                             ; since it was only ever used improperly and correcting that bug
+                             ; made it completely unused.
 ;sound_wait_for_leader  ; The sound played when a user is placed into a conference that
                         ; can not start until a marked user enters.
 ;sound_leader_has_left  ; The sound played when the last marked user leaves the conference.
@@ -237,6 +239,7 @@
 ;sound_locked_now ; The sound played to an admin after toggling the conference to locked mode.
 ;sound_unlocked_now; The sound played to an admin after toggling the conference to unlocked mode.
 ;sound_error_menu ; The sound played when an invalid menu option is entered.
+;sound_begin ; The sound played to the conference when the first marked user enters the conference.
 
 ; --- ConfBridge Menu Options ---
 ; The ConfBridge application also has the ability to
--- configs/iax.conf.sample
+++ configs/iax.conf.sample
@@ -607,14 +607,18 @@
 ; IPs can also optionally be given but are not required.  Caller*ID can be
 ; suggested to the other side as well if it is for example a phone instead of
 ; another PBX.
-;connectedline=yes ; Set how connected line information is handled for this
-;                  ; peer. If set to "yes", both sending and receiving
-;                  ; connected line information will be enabled. If set to
-;                  ; "send", this peer will send connected line information
-;                  ; but will not process connected line updates. If set to
-;                  ; "receive", connected line updates will be processed
-;                  ; but not sent. If set to "no", connected line updates
-;                  ; will be disabled. Default is "no".
+;connectedline=yes ; Set if connected line and redirecting information updates
+;                  ; are passed between Asterisk servers for this peer.
+;                  ; yes - Sending and receiving updates are enabled.
+;                  ; send - Only send updates.
+;                  ; receive - Only process received updates.
+;                  ; no - Sending and receiving updates are disabled.
+;                  ; Default is "no".
+;                  ;
+;                  ; Note: Because of an incompatibility between Asterisk v1.4
+;                  ; and Asterisk v1.8 or later, this option must be set
+;                  ; to "no" toward the Asterisk v1.4 peer.  A symptom of the
+;                  ; incompatibility is the call gets disconnected unexpectedly.
 
 
 ;[dynamichost]
--- configs/indications.conf.sample
+++ configs/indications.conf.sample
@@ -285,6 +285,8 @@
 record = 1400/500,0/15000
 info = 950/330,0/1000
 dialout = 500
+; STUTTER not specified
+stutter = !425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,425
 
 
 [fi]
@@ -371,7 +373,7 @@
 dialrecall = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
 record = 1400/500,0/15000
 info = !950/330,!1400/330,!1800/330,0/1000
-stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
+stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,400*25
 
 [it]
 description = Italy
@@ -427,7 +429,7 @@
 dialrecall = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
 record = 1400/500,0/15000
 info = 950/330,0/30,1400/330,0/30,1800/330,0/1000
-stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
+stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,425
 
 [my]
 description = Malaysia
@@ -436,6 +438,8 @@
 busy = 425/500,0/500
 ring = 425/400,0/200,425/400,0/2000
 congestion = 425/500,0/500
+; STUTTER - not specified
+stutter = !425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,425
 
 [nl]
 description = Netherlands
@@ -500,7 +504,7 @@
 ; INFO - not specified
 info = !950/330,!1400/330,!1800/330,0
 ; STUTTER - not specified
-stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
+stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,425
 
 
 [pl]
@@ -702,6 +706,8 @@
 dialrecall = 425
 record = 1400/500,0/15000
 info = !950/330,!1440/330,!1800/330,0/1000
+; STUTTER - not specified
+stutter = !425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,425
 
 
 [za]
--- configs/manager.conf.sample
+++ configs/manager.conf.sample
@@ -94,12 +94,13 @@
 ; user.
 ;
 ;eventfilter=Event: Newchannel
-;eventfilter=!Channel: DAHDI*
-; The eventfilter option is used to whitelist or blacklist events per user to be
-; reported with regular expressions and are allowed if both the regex matches
-; and the user has read access set below. Filters are assumed to be for whitelisting
-; unless preceeded by an exclamation point, which marks it as being black.
-; Evaluation of the filters is as follows:
+;eventfilter=!Channel: DAHDI.*
+; The eventfilter option is used to whitelist or blacklist events per user.
+; A filter consists of a (basic/old-style and unanchored) regular expression
+; that is run on the entire event data. If the first character of the filter
+; is an exclamation mark (!), the filter is appended to the blacklist instead
+; of the whitelist. After first checking the read access below, the regular
+; expression filters are processed as follows:
 ; - If no filters are configured all events are reported as normal.
 ; - If there are white filters only: implied black all filter processed first,
 ; then white filters.
--- configs/queues.conf.sample
+++ configs/queues.conf.sample
@@ -5,7 +5,7 @@
 ; Persistent Members
 ;    Store each dynamic member in each queue in the astdb so that
 ;    when asterisk is restarted, each member will be automatically
-;    read into their recorded queues. Default is 'yes'.
+;    read into their recorded queues. Default is 'no'.
 ;
 persistentmembers = yes
 ;
--- configs/res_fax.conf.sample
+++ configs/res_fax.conf.sample
@@ -4,12 +4,12 @@
 ; Maximum Transmission Rate
 ; Possible values are { 2400 | 4800 | 7200 | 9600 | 12000 | 14400 }
 ; Set this value to the maximum desired transfer rate.  Default: 14400
-maxrate=14400
+;maxrate=14400
 
 ; Minimum Transmission Rate
 ; Possible values are { 2400 | 4800 | 7200 | 9600 | 12000 | 14400 }
-; Set this value to the minimum desired transfer rate.  Default: 2400
-minrate=2400
+; Set this value to the minimum desired transfer rate.  Default: 4800
+;minrate=4800
 
 ; Send Progress/Status events to manager session
 ; Manager events with 'call' class permissions will receive events indicating the
@@ -21,8 +21,8 @@
 ; modem capabilities
 ; Possible values are { v17 | v27 | v29 }
 ; Set this value to modify the default modem options.  Default: v17,v27,v29
-modems=v17,v27,v29
+;modems=v17,v27,v29
 
 ; Enable/disable T.30 ECM (error correction mode) by default.
 ; Default: Enabled
-ecm=yes
+;ecm=yes
--- configs/sip.conf.sample
+++ configs/sip.conf.sample
@@ -396,6 +396,9 @@
                                 ; certain transferred calls to use always use video when
                                 ; available. [yes|NO|always]
 
+;textsupport=no                 ; Support for ITU-T T.140 realtime text.
+                                ; The default value is "no".
+
 ;maxcallbitrate=384             ; Maximum bitrate for video calls (default 384 kb/s)
                                 ; Videosupport and maxcallbitrate is settable
                                 ; for peers and users as well
@@ -523,8 +526,10 @@
 
 ;
 ;------------------------ TLS settings ------------------------------------------------------------
-;tlscertfile=</path/to/certificate.pem> ; Certificate file (*.pem format only) to use for TLS connections
-                                        ; default is to look for "asterisk.pem" in current directory
+;tlscertfile=</path/to/certificate.pem> ; Certificate chain (*.pem format only) to use for TLS connections
+                                        ; The certificates must be sorted starting with the subject's certificate
+                                        ; and followed by intermediate CA certificates if applicable.
+                                        ; Default is to look for "asterisk.pem" in current directory
 
 ;tlsprivatekey=</path/to/private.pem> ; Private key file (*.pem format only) for TLS connections.
                                       ; If no tlsprivatekey is specified, tlscertfile is searched for
--- configs/voicemail.conf.sample
+++ configs/voicemail.conf.sample
@@ -169,7 +169,8 @@
 ; Short 24h date format for pager use
 ;pagerdateformat=%T %D
 ;
-; You can override the default program to send e-mail if you wish, too
+; Using the mailcmd option, you can specify what command is called for
+; outbound E-mail. The default is shown below.
 ;
 ;mailcmd=/usr/sbin/sendmail -t
 ;
--- configure
+++ configure
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.ac Revision: 400768 .
+# From configure.ac Revision: 406802 .
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.69 for asterisk trunk.
 #
@@ -12960,6 +12960,43 @@
 
 fi
 
+stat_nsec_found=no
+ac_fn_c_check_member "$LINENO" "struct stat" "st_mtim" "ac_cv_member_struct_stat_st_mtim" "#include <sys/stat.h>
+"
+if test "x$ac_cv_member_struct_stat_st_mtim" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_STAT_ST_MTIM 1
+_ACEOF
+
+stat_nsec_found=yes
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_mtimensec" "ac_cv_member_struct_stat_st_mtimensec" "#include <sys/stat.h>
+"
+if test "x$ac_cv_member_struct_stat_st_mtimensec" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_STAT_ST_MTIMENSEC 1
+_ACEOF
+
+stat_nsec_found=yes
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_mtimespec" "ac_cv_member_struct_stat_st_mtimespec" "#include <sys/stat.h>
+"
+if test "x$ac_cv_member_struct_stat_st_mtimespec" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_STAT_ST_MTIMESPEC 1
+_ACEOF
+
+stat_nsec_found=yes
+fi
+
+
+if test "${stat_nsec_found}" != yes; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Cannot determine nanosecond field of struct stat" >&5
+$as_echo "$as_me: WARNING: Cannot determine nanosecond field of struct stat" >&2;}
+fi
 
 # Checks for library functions.
 for ac_header in unistd.h
@@ -26648,6 +26685,117 @@
 
 
 
+# Accept either RADIUS client library, their APIs are fully compatible,
+# just different header filenames and different SONAMEs
+
+if test "x${PBX_RADIUS}" != "x1" -a "${USE_RADIUS}" != "no"; then
+   pbxlibdir=""
+   # if --with-RADIUS=DIR has been specified, use it.
+   if test "x${RADIUS_DIR}" != "x"; then
+      if test -d ${RADIUS_DIR}/lib; then
+         pbxlibdir="-L${RADIUS_DIR}/lib"
+      else
+         pbxlibdir="-L${RADIUS_DIR}"
+      fi
+   fi
+   pbxfuncname="rc_read_config"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_RADIUS_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} "
+      as_ac_Lib=`$as_echo "ac_cv_lib_freeradius-client_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lfreeradius-client" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lfreeradius-client... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lfreeradius-client ${pbxlibdir}  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_RADIUS_FOUND=yes
+else
+  AST_RADIUS_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_RADIUS_FOUND}" = "yes"; then
+      RADIUS_LIB="${pbxlibdir} -lfreeradius-client "
+      # if --with-RADIUS=DIR has been specified, use it.
+      if test "x${RADIUS_DIR}" != "x"; then
+         RADIUS_INCLUDE="-I${RADIUS_DIR}/include"
+      fi
+      RADIUS_INCLUDE="${RADIUS_INCLUDE} "
+      if test "xfreeradius-client.h" = "x" ; then	# no header, assume found
+         RADIUS_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${RADIUS_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "freeradius-client.h" "ac_cv_header_freeradius_client_h" "$ac_includes_default"
+if test "x$ac_cv_header_freeradius_client_h" = xyes; then :
+  RADIUS_HEADER_FOUND=1
+else
+  RADIUS_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${RADIUS_HEADER_FOUND}" = "x0" ; then
+         RADIUS_LIB=""
+         RADIUS_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            RADIUS_LIB=""
+         fi
+         PBX_RADIUS=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_RADIUS 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+if test "x${PBX_RADIUS}" = "x1"; then
+
+$as_echo "#define FREERADIUS_CLIENT /**/" >>confdefs.h
+
+else
 
 if test "x${PBX_RADIUS}" != "x1" -a "${USE_RADIUS}" != "no"; then
    pbxlibdir=""
@@ -26752,6 +26900,7 @@
 fi
 
 
+fi
 
 
 if test "x${PBX_COROSYNC}" != "x1" -a "${USE_COROSYNC}" != "no"; then
--- contrib/scripts/astgenkey
+++ contrib/scripts/astgenkey
@@ -32,7 +32,7 @@
 	echo "need to be moved to /var/lib/asterisk/keys if you want"
 	echo "to use them, and any private keys (.key files) will"
 	echo "need to be initialized at runtime either by running"
-	echo "Asterisk with the '-i' option, or with the 'init keys'"
+	echo "Asterisk with the '-i' option, or with the 'keys init'"
 	echo "command once Asterisk is running."
 	echo ""
 	echo "Press ENTER to continue or ^C to cancel."
--- contrib/scripts/astgenkey.8
+++ contrib/scripts/astgenkey.8
@@ -94,7 +94,7 @@
 To see the currently-installed keys from the asterisk CLI, use the command
 
 .RS
-show keys
+keys show
 .RE
 
 .SH OPTIONS
--- contrib/scripts/install_prereq
+++ contrib/scripts/install_prereq
@@ -1,6 +1,6 @@
 #! /bin/sh
 #
-# $Id: install_prereq 379643 2013-01-21 04:39:23Z lathama $
+# $Id: install_prereq 408733 2014-02-21 19:04:21Z kharwell $
 #
 
 # install_prereq: a script to install distribution-specific
@@ -10,7 +10,7 @@
 
 usage() {
   echo "$0: a script to install distribution-specific prerequirement"
-  echo 'Revision: $Id: install_prereq 379643 2013-01-21 04:39:23Z lathama $'
+  echo 'Revision: $Id: install_prereq 408733 2014-02-21 19:04:21Z kharwell $'
   echo ""
   echo "Usage: $0:                    Shows this message."
   echo "Usage: $0 test                Prints commands it is about to run."
@@ -21,7 +21,7 @@
 # Basic build system:
 PACKAGES_DEBIAN="build-essential"
 # Asterisk: basic requirements:
-PACKAGES_DEBIAN="$PACKAGES_DEBIAN libncurses-dev libz-dev libssl-dev libxml2-dev libsqlite3-dev"
+PACKAGES_DEBIAN="$PACKAGES_DEBIAN libncurses-dev libz-dev libssl-dev libxml2-dev libsqlite3-dev uuid-dev uuid"
 # Asterisk: for addons:
 PACKAGES_DEBIAN="$PACKAGES_DEBIAN libcurl-dev libspeex-dev libspeexdsp-dev libogg-dev libvorbis-dev libasound2-dev portaudio19-dev libcurl4-openssl-dev"
 PACKAGES_DEBIAN="$PACKAGES_DEBIAN libpq-dev unixodbc-dev libsqlite0-dev libmysqlclient15-dev libneon27-dev libgmime-dev libusb-dev liblua5.1-0-dev lua5.1"
--- doc/asterisk.8
+++ doc/asterisk.8
@@ -16,27 +16,27 @@
 \fBasterisk\fR \kx
 .if (\nx>(\n(.l/2)) .nr x (\n(.l/5)
 'in \n(.iu+\nxu
-[\fB-BcdfFghiImnpqRtTvVW\fR] [\fB-C \fR\fIfile\fR] [\fB-e \fR\fImemory\fR] [\fB-G \fR\fIgroup\fR] [\fB-L \fR\fIloadaverage\fR] [\fB-M \fR\fIvalue\fR] [\fB-U \fR\fIuser\fR] [\fB-s \fR\fIsocket-file\fR]
-'in \n(.iu-\nxu
+[\fB\-BcdfFghiImnpqRtTvVW\fR] [\fB\-C \fR\fIfile\fR] [\fB\-e \fR\fImemory\fR] [\fB\-G \fR\fIgroup\fR] [\fB\-L \fR\fIloadaverage\fR] [\fB\-M \fR\fIvalue\fR] [\fB\-U \fR\fIuser\fR] [\fB\-s \fR\fIsocket\-file\fR]
+'in \n(.iu\-\nxu
 .ad b
 'hy
 'nh
 .fi
 .ad l
-\fBasterisk -r\fR \kx
+\fBasterisk \-r\fR \kx
 .if (\nx>(\n(.l/2)) .nr x (\n(.l/5)
 'in \n(.iu+\nxu
-[\fB-v\fR] [\fB-d\fR] [\fB-x \fR\fIcommand\fR]
+[\fB\-v\fR] [\fB\-d\fR] [\fB\-x \fR\fIcommand\fR]
 'in \n(.iu-\nxu
 .ad b
 'hy
 'nh
 .fi
 .ad l
-\fBasterisk -R\fR \kx
+\fBasterisk \-R\fR \kx
 .if (\nx>(\n(.l/2)) .nr x (\n(.l/5)
 'in \n(.iu+\nxu
-[\fB-v\fR] [\fB-d\fR] [\fB-x \fR\fIcommand\fR]
+[\fB\-v\fR] [\fB\-d\fR] [\fB\-x \fR\fIcommand\fR]
 'in \n(.iu-\nxu
 .ad b
 'hy
@@ -52,12 +52,12 @@
 .PP
 At start, Asterisk reads the /etc/asterisk/asterisk.conf main configuration
 file and locates the rest of the configuration files from the configuration
-in that file. The -C option specifies an alternate main configuration file.
+in that file. The \-C option specifies an alternate main configuration file.
 Virtually all aspects of the operation of asterisk's configuration files
 can be found in the sample configuration files. The format for those files
 is generally beyond the scope of this man page.
 .PP
-When running with \fB-c\fR, \fB-r\fR or \fB-R\fR
+When running with \fB\-c\fR, \fB\-r\fR or \fB\-R\fR
 options, Asterisk supplies a powerful command line, including command
 completion, which may be used to monitors its status, perform a variety
 of administrative actions and even explore the applications that are
@@ -70,26 +70,26 @@
 \*(T<\fB\-R\fR\*(T> connects to an existing Asterisk instance through
 a remote console.
 .TP 
--B
+\-B
 Force the background of the terminal to be black, in order for
 terminal colors to show up properly. Equivalent to
 \*(T<\fBforceblackbackground = yes\fR\*(T> in
 \*(T<\fIasterisk.conf\fR\*(T>. See also
 \*(T<\fB\-n\fR\*(T> and \*(T<\fB\-W\fR\*(T>.
 .TP 
--C \fIfile\fR
+\-C \fIfile\fR
 Use \*(T<\fIfile\fR\*(T> as master configuration file
 instead of the default, /etc/asterisk/asterisk.conf
 .TP 
--c
+\-c
 Provide a control console on the calling terminal. The
 console is similar to the remote console provided by
 \*(T<\fB\-r\fR\*(T>. Specifying this option implies 
-\fB-f\fR and will cause asterisk to no longer 
+\fB\-f\fR and will cause asterisk to no longer 
 fork or detach from the controlling terminal. Equivalent 
 to \*(T<\fBconsole = yes\fR\*(T> in \*(T<\fIasterisk.conf\fR\*(T>.
 .TP 
--d
+\-d
 Enable extra debugging statements. This parameter may be used several
 times, and each increases the debug level. Equivalent to \*(T<\fBdebug = \fR\*(T>\fInum\fR
 in \*(T<\fIasterisk.conf\fR\*(T> to explicitly set the initian debug
@@ -104,62 +104,62 @@
 Equivalent to \*(T<\fBminmemfree = \fR\*(T>\fImemory\fR in
 \*(T<\fIasterisk.conf\fR\*(T>.
 .TP 
--f
+\-f
 Do not fork or detach from controlling terminal. Overrides any
-preceding specification of \fB-F\fR on the command line.
+preceding specification of \fB\-F\fR on the command line.
 Equivalent to \*(T<\fBnofork = yes\fR\*(T> in \*(T<\fIasterisk.conf\fR\*(T>.
 See also \*(T<\fB\-c\fR\*(T>.
 .TP 
--F
+\-F
 Always fork and detach from controlling terminal. Overrides any
-preceding specification of \fB-f\fR on the command line.
+preceding specification of \fB\-f\fR on the command line.
 May also be used to prevent \*(T<\fB\-d\fR\*(T> and \*(T<\fB\-v\fR\*(T> to imply
 no forking. Equivalent to \*(T<\fBalwaysfork = yes\fR\*(T> in \*(T<\fIasterisk.conf\fR\*(T>.
 .TP 
--g
+\-g
 Remove resource limit on core size, thus forcing Asterisk to dump
 core in the unlikely event of a segmentation fault or abort signal.
 \fBNOTE:\fR in some cases this may be incompatible
-with the \fB-U\fR or \fB-G\fR flags.
+with the \fB\-U\fR or \fB\-G\fR flags.
 .TP 
--G \fIgroup\fR
+\-G \fIgroup\fR
 Run as group \fIgroup\fR instead of the
 calling group. \fBNOTE:\fR this requires substantial work
 to be sure that Asterisk's environment has permission to write
 the files required for its operation, including logs, its comm
 socket, the asterisk database, etc.
 .TP 
--h
+\-h
 Provide brief summary of command line arguments and terminate.
 .TP 
--i
+\-i
 Prompt user to intialize any encrypted private keys for IAX2
 secure authentication during startup.
 .TP 
--I
+\-I
 Enable internal timing if DAHDI timing is available.
 The default behaviour is that outbound packets are phase locked
 to inbound packets. Enabling this switch causes them to be
 locked to the internal DAHDI timer instead.
 .TP 
--L \fIloadaverage\fR
+\-L \fIloadaverage\fR
 Limits the maximum load average before rejecting new calls. This can
 be useful to prevent a system from being brought down by terminating
 too many simultaneous calls.
 .TP 
--m
+\-m
 Temporarily mutes output to the console and logs. To return to normal,
 use \fBlogger mute\fR.
 .TP 
--M \fIvalue\fR
+\-M \fIvalue\fR
 Limits the maximum number of calls to the specified value. This can
 be useful to prevent a system from being brought down by terminating
 too many simultaneous calls.
 .TP 
--n
+\-n
 Disable ANSI colors even on terminals capable of displaying them.
 .TP 
--p
+\-p
 If supported by the operating system (and executing as root),
 attempt to run with realtime priority for increased performance and
 responsiveness within the Asterisk process, at the expense of other
@@ -170,77 +170,77 @@
 running or is killed, \fBasterisk\fR will slow down to
 normal process priority, to avoid locking up the machine.
 .TP 
--q
+\-q
 Reduce default console output when running in conjunction with
-console mode (\fB-c\fR).
+console mode (\fB\-c\fR).
 .TP 
--r
+\-r
 Instead of running a new Asterisk process, attempt to connect
 to a running Asterisk process and provide a console interface
 for controlling it.
 .TP 
--R
-Much like \fB-r\fR. Instead of running a new Asterisk process, attempt to connect
+\-R
+Much like \fB\-r\fR. Instead of running a new Asterisk process, attempt to connect
 to a running Asterisk process and provide a console interface
 for controlling it. Additionally, if connection to the Asterisk 
 process is lost, attempt to reconnect for as long as 30 seconds.
 .TP 
--s \fIsocket file name\fR
-In combination with \fB-r\fR, connect directly to a specified
+\-s \fIsocket file name\fR
+In combination with \fB\-r\fR, connect directly to a specified
 Asterisk server socket.
 .TP 
--t
+\-t
 When recording files, write them first into a temporary holding directory, 
 then move them into the final location when done.
 .TP 
--T
+\-T
 Add timestamp to all non-command related output going to the console
 when running with verbose and/or logging to the console.
 .TP 
--U \fIuser\fR
+\-U \fIuser\fR
 Run as user \fIuser\fR instead of the
 calling user. \fBNOTE:\fR this requires substantial work
 to be sure that Asterisk's environment has permission to write
 the files required for its operation, including logs, its comm
 socket, the asterisk database, etc.
 .TP 
--v
+\-v
 Increase the level of verboseness on the console. The more times
-\fB-v\fR is specified, the more verbose the output is.
-Specifying this option implies \fB-f\fR and will cause
+\fB\-v\fR is specified, the more verbose the output is.
+Specifying this option implies \fB\-f\fR and will cause
 asterisk to no longer fork or detach from the controlling terminal.
-This option may also be used in conjunction with \fB-r\fR
-and \fB-R\fR.
+This option may also be used in conjunction with \fB\-r\fR
+and \fB\-R\fR.
 
 Note: This always sets the verbose level in the asterisk process,
 even if it is running in the background. This will affect the size
 of your log files.
 .TP 
--V
+\-V
 Display version information and exit immediately.
 .TP 
--W
+\-W
 Display colored terminal text as if the background were white
 or otherwise light in color. Normally, terminal text is displayed
 as if the background were black or otherwise dark in color.
 .TP 
--x \fIcommand\fR
+\-x \fIcommand\fR
 Connect to a running Asterisk process and execute a command on
 a command line, passing any output through to standard out and
 then terminating when the command execution completes. Implies
-\fB-r\fR when \fB-R\fR is not explicitly
+\fB\-r\fR when \fB\-R\fR is not explicitly
 supplied.
 .TP 
--X
+\-X
 Enables executing of includes via \fB#exec\fR directive.
 This can be useful if You want to do \fB#exec\fR inside
 \*(T<\fIasterisk.conf\fR\*(T>
 .SH EXAMPLES
 \fBasterisk\fR - Begin Asterisk as a daemon
 .PP
-\fBasterisk -vvvgc\fR - Run on controlling terminal
+\fBasterisk \-vvvgc\fR - Run on controlling terminal
 .PP
-\fBasterisk -rx "core show channels"\fR - Display channels on running server
+\fBasterisk \-rx "core show channels"\fR - Display channels on running server
 .SH BUGS
 Bug reports and feature requests may be filed at https://issues.asterisk.org
 .SH "SEE ALSO"
--- formats/format_wav.c
+++ formats/format_wav.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 364580 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407512 $")
 
 #include "asterisk/mod_format.h"
 #include "asterisk/module.h"
@@ -91,7 +91,7 @@
 		return -1;
 	}
 	if (ltohs(format) != 1) {
-		ast_log(LOG_WARNING, "Not a wav file %d\n", ltohs(format));
+		ast_log(LOG_WARNING, "Not a supported wav file format (%d). Only PCM encoded, 16 bit, mono, 8kHz files are supported with a lowercase '.wav' extension.\n", ltohs(format));
 		return -1;
 	}
 	if (fread(&chans, 1, 2, f) != 2) {
--- funcs/func_audiohookinherit.c
+++ funcs/func_audiohookinherit.c
@@ -228,6 +228,11 @@
 		return -1;
 	}
 
+	if (!chan) {
+		ast_log(LOG_WARNING, "No channel was provided to INHERITANCE function.\n");
+		return -1;
+	}
+
 	allow = ast_true(value);
 
 	/* Step 2: retrieve or set up datastore */
--- include/asterisk/autoconfig.h.in
+++ include/asterisk/autoconfig.h.in
@@ -29,6 +29,9 @@
 /* Define to 1 if using `alloca.c'. */
 #undef C_ALLOCA
 
+/* Use the FreeRADIUS-client library */
+#undef FREERADIUS_CLIENT
+
 /* Define to 1 if you have the `acos' function. */
 #undef HAVE_ACOS
 
@@ -863,6 +866,15 @@
 /* Define to 1 if `st_blksize' is a member of `struct stat'. */
 #undef HAVE_STRUCT_STAT_ST_BLKSIZE
 
+/* Define to 1 if `st_mtim' is a member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_MTIM
+
+/* Define to 1 if `st_mtimensec' is a member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_MTIMENSEC
+
+/* Define to 1 if `st_mtimespec' is a member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_MTIMESPEC
+
 /* Define to 1 if `cr_uid' is a member of `struct ucred'. */
 #undef HAVE_STRUCT_UCRED_CR_UID
 
--- include/asterisk/channel.h
+++ include/asterisk/channel.h
@@ -901,6 +901,10 @@
 	 * to continue.
 	 */
 	AST_FLAG_BRIDGE_DUAL_REDIRECT_WAIT = (1 << 22),
+	/*!
+	 * The data on chan->timingdata is an astobj2 object.
+	 */
+	AST_FLAG_TIMINGDATA_IS_AO2_OBJ = (1 << 23),
 };
 
 /*! \brief ast_bridge_config flags */
@@ -2286,6 +2290,7 @@
  * \version 1.6.1 changed samples parameter to rate, accomodates new timing methods
  */
 int ast_settimeout(struct ast_channel *c, unsigned int rate, int (*func)(const void *data), void *data);
+int ast_settimeout_full(struct ast_channel *c, unsigned int rate, int (*func)(const void *data), void *data, unsigned int is_ao2_obj);
 
 /*!
  * \brief Transfer a channel (if supported).
--- include/asterisk/devicestate.h
+++ include/asterisk/devicestate.h
@@ -129,7 +129,6 @@
  * active channels list for the device.
  *
  * \retval an AST_DEVICE_??? state
- * \retval -1 on failure
  */
 enum ast_device_state ast_device_state(const char *device);
 
--- include/asterisk/frame.h
+++ include/asterisk/frame.h
@@ -233,6 +233,18 @@
 /*! Reject link request */
 #define AST_HTML_LINKREJECT	20
 
+/*!
+ * \brief Internal control frame subtype field values.
+ *
+ * \warning
+ * IAX2 sends these values out over the wire.  To prevent future
+ * incompatibilities, pick the next value in the enum from whatever
+ * is on the current trunk.  If you lose the merge race you need to
+ * fix the previous branches to match what is on trunk.  In addition
+ * you need to change chan_iax2 to explicitly allow the control
+ * frame over the wire if it makes sense for the frame to be passed
+ * to another Asterisk instance.
+ */
 enum ast_control_frame_type {
 	AST_CONTROL_HANGUP = 1,			/*!< Other end has hungup */
 	AST_CONTROL_RING = 2,			/*!< Local ring */
@@ -267,6 +279,20 @@
 	AST_CONTROL_MCID = 31,			/*!< Indicate that the caller is being malicious. */
 	AST_CONTROL_UPDATE_RTP_PEER = 32, /*!< Interrupt the bridge and have it update the peer */
 	AST_CONTROL_PVT_CAUSE_CODE = 33, /*!< Contains an update to the protocol-specific cause-code stored for branching dials */
+
+	/*
+	 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+	 *
+	 * IAX2 sends these values out over the wire.  To prevent future
+	 * incompatibilities, pick the next value in the enum from whatever
+	 * is on the current trunk.  If you lose the merge race you need to
+	 * fix the previous branches to match what is on trunk.  In addition
+	 * you need to change chan_iax2 to explicitly allow the control
+	 * frame over the wire if it makes sense for the frame to be passed
+	 * to another Asterisk instance.
+	 *
+	 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
+	 */
 };
 
 enum ast_frame_read_action {
--- include/asterisk/rtp_engine.h
+++ include/asterisk/rtp_engine.h
@@ -539,7 +539,9 @@
 	enum ast_rtp_glue_result (*get_trtp_info)(struct ast_channel *chan, struct ast_rtp_instance **instance);
 	/*! Callback for updating the destination that the remote side should send RTP to */
 	int (*update_peer)(struct ast_channel *chan, struct ast_rtp_instance *instance, struct ast_rtp_instance *vinstance, struct ast_rtp_instance *tinstance, const struct ast_format_cap *cap, int nat_active);
-	/*! Callback for retrieving codecs that the channel can do.  Result returned in result_cap*/
+	/*! Callback for retrieving codecs that the channel can do.  Result returned in result_cap.
+	 * \note The channel chan will be locked during this call.
+	 */
 	void (*get_codec)(struct ast_channel *chan, struct ast_format_cap *result_cap);
 	/*! Linked list information */
 	AST_RWLIST_ENTRY(ast_rtp_glue) entry;
--- main/asterisk.c
+++ main/asterisk.c
@@ -41,7 +41,7 @@
  *
  * Copyright (C) 1999 - 2013, Digium, Inc.
  * Asterisk is a <a href="http://www.digium.com/en/company/view-policy.php?id=Trademark-Policy">registered trademark</a>
- * of <a href="http://www.digium.com">Digium, Inc</a>.
+ * of <a rel="nofollow" href="http://www.digium.com">Digium, Inc</a>.
  *
  * \author Mark Spencer <markster@digium.com>
  * Also see \ref AstCREDITS
@@ -65,7 +65,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405431 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409362 $")
 
 #include "asterisk/_private.h"
 
--- main/astobj2.c
+++ main/astobj2.c
@@ -24,7 +24,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401783 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409567 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/astobj2.h"
@@ -157,6 +157,7 @@
 				"bad magic number for object %p. Object is likely destroyed.\n",
 				user_data);
 		}
+		ast_assert(0);
 		return NULL;
 	}
 
--- main/cel.c
+++ main/cel.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397034 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 406418 $")
 
 #include "asterisk/_private.h"
 
@@ -47,6 +47,9 @@
 #include "asterisk/cli.h"
 #include "asterisk/astobj2.h"
 
+/*! Config file to load for the CEL feature. */
+static const char cel_conf_file[] = "cel.conf";
+
 /*! Is the CEL subsystem enabled ? */
 static unsigned char cel_enabled;
 
@@ -77,13 +80,38 @@
 #define NUM_APP_BUCKETS		97
 
 /*!
+ * \brief Lock protecting CEL.
+ *
+ * \note It protects during reloads, shutdown, and accesses to
+ * the appset and linkedids containers.
+ */
+AST_MUTEX_DEFINE_STATIC(reload_lock);
+
+/*!
  * \brief Container of Asterisk application names
  *
  * The apps in this container are the applications that were specified
  * in the configuration as applications that CEL events should be generated
  * for when they start and end on a channel.
+ *
+ * \note Accesses to the appset container must be done while
+ * holding the reload_lock.
  */
 static struct ao2_container *appset;
+
+struct cel_linkedid {
+	/*! Number of channels with this linkedid. */
+	unsigned int count;
+	/*! Linkedid stored at end of struct. */
+	char id[0];
+};
+
+/*!
+ * \brief Container of channel references to a linkedid for CEL purposes.
+ *
+ * \note Accesses to the linkedids container must be done while
+ * holding the reload_lock.
+ */
 static struct ao2_container *linkedids;
 
 /*!
@@ -138,15 +166,6 @@
 	return cel_enabled;
 }
 
-static int print_app(void *obj, void *arg, int flags)
-{
-	struct ast_cli_args *a = arg;
-
-	ast_cli(a->fd, "CEL Tracking Application: %s\n", (const char *) obj);
-
-	return 0;
-}
-
 static void print_cel_sub(const struct ast_event *event, void *data)
 {
 	struct ast_cli_args *a = data;
@@ -196,7 +215,28 @@
 		}
 	}
 
-	ao2_callback(appset, OBJ_NODATA, print_app, a);
+	/* Accesses to the appset container must be done while holding the reload_lock. */
+	ast_mutex_lock(&reload_lock);
+	if (appset) {
+		struct ao2_iterator iter;
+		char *app;
+
+		iter = ao2_iterator_init(appset, 0);
+		for (;;) {
+			app = ao2_iterator_next(&iter);
+			if (!app) {
+				break;
+			}
+			ast_mutex_unlock(&reload_lock);
+
+			ast_cli(a->fd, "CEL Tracking Application: %s\n", app);
+
+			ao2_ref(app, -1);
+			ast_mutex_lock(&reload_lock);
+		}
+		ao2_iterator_destroy(&iter);
+	}
+	ast_mutex_unlock(&reload_lock);
 
 	if (!(sub = ast_event_subscribe_new(AST_EVENT_SUB, print_cel_sub, a))) {
 		return CLI_FAILURE;
@@ -278,10 +318,12 @@
 			continue;
 		}
 
-		if (!(app = ao2_alloc(strlen(cur_app) + 1, NULL))) {
+		/* The app object is immutable so it doesn't need a lock of its own. */
+		app = ao2_alloc_options(strlen(cur_app) + 1, NULL, AO2_ALLOC_OPT_LOCK_NOLOCK);
+		if (!app) {
 			continue;
 		}
-		strcpy(app, cur_app);
+		strcpy(app, cur_app);/* Safe */
 
 		ao2_link(appset, app);
 		ao2_ref(app, -1);
@@ -289,9 +331,15 @@
 	}
 }
 
-AST_MUTEX_DEFINE_STATIC(reload_lock);
+static void set_defaults(void)
+{
+	cel_enabled = CEL_ENABLED_DEFAULT;
+	eventset = CEL_DEFAULT_EVENTS;
+	*cel_dateformat = '\0';
+	ao2_callback(appset, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
+}
 
-static int do_reload(void)
+static int do_reload(int is_reload)
 {
 	struct ast_config *config;
 	const char *enabled_value;
@@ -302,19 +350,32 @@
 
 	ast_mutex_lock(&reload_lock);
 
-	/* Reset all settings before reloading configuration */
-	cel_enabled = CEL_ENABLED_DEFAULT;
-	eventset = CEL_DEFAULT_EVENTS;
-	*cel_dateformat = '\0';
-	ao2_callback(appset, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
-
-	config = ast_config_load2("cel.conf", "cel", config_flags);
+	if (!is_reload) {
+		/* Initialize all settings before first configuration load. */
+		set_defaults();
+	}
 
-	if (config == CONFIG_STATUS_FILEMISSING || config == CONFIG_STATUS_FILEUNCHANGED || config == CONFIG_STATUS_FILEINVALID) {
+	/*
+	 * Unfortunately we have to always load the config file because
+	 * other modules read the same file.
+	 */
+	config = ast_config_load2(cel_conf_file, "cel", config_flags);
+	if (!config || config == CONFIG_STATUS_FILEINVALID) {
+		ast_log(LOG_WARNING, "Could not load %s\n", cel_conf_file);
+		config = NULL;
+		goto return_cleanup;
+	}
+	if (config == CONFIG_STATUS_FILEUNCHANGED) {
+		/* This should never happen because we always load the config file. */
 		config = NULL;
 		goto return_cleanup;
 	}
 
+	if (is_reload) {
+		/* Reset all settings before reloading configuration */
+		set_defaults();
+	}
+
 	if ((enabled_value = ast_variable_retrieve(config, "general", "enable"))) {
 		cel_enabled = ast_true(enabled_value);
 	}
@@ -368,24 +429,46 @@
 void ast_cel_check_retire_linkedid(struct ast_channel *chan)
 {
 	const char *linkedid = ast_channel_linkedid(chan);
-	char *lid;
+	struct cel_linkedid *lid;
 
-	/* make sure we need to do all this work */
+	if (ast_strlen_zero(linkedid)) {
+		return;
+	}
 
-	if (ast_strlen_zero(linkedid) || !ast_cel_track_event(AST_CEL_LINKEDID_END)) {
+	/* Get the lock in case any CEL events are still in flight when we shutdown. */
+	ast_mutex_lock(&reload_lock);
+
+	if (!cel_enabled || !ast_cel_track_event(AST_CEL_LINKEDID_END)
+		|| !linkedids) {
+		/*
+		 * CEL is disabled or we are not tracking linkedids
+		 * or the CEL module is shutdown.
+		 */
+		ast_mutex_unlock(&reload_lock);
 		return;
 	}
 
-	if (!(lid = ao2_find(linkedids, (void *) linkedid, OBJ_POINTER))) {
+	lid = ao2_find(linkedids, (void *) linkedid, OBJ_KEY);
+	if (!lid) {
+		ast_mutex_unlock(&reload_lock);
+
+		/*
+		 * The user may have done a reload to start tracking linkedids
+		 * when a call was already in progress.  This is an unusual kind
+		 * of change to make after starting Asterisk.
+		 */
 		ast_log(LOG_ERROR, "Something weird happened, couldn't find linkedid %s\n", linkedid);
 		return;
 	}
 
-	/* We have a ref for each channel with this linkedid, the link and the above find, so if
-	 * before unreffing the channel we have a refcount of 3, we're done. Unlink and report. */
-	if (ao2_ref(lid, -1) == 3) {
+	if (!--lid->count) {
+		/* No channels use this linkedid anymore. */
 		ao2_unlink(linkedids, lid);
+		ast_mutex_unlock(&reload_lock);
+
 		ast_cel_report_event(chan, AST_CEL_LINKEDID_END, NULL, NULL, NULL);
+	} else {
+		ast_mutex_unlock(&reload_lock);
 	}
 	ao2_ref(lid, -1);
 }
@@ -517,26 +600,47 @@
 
 int ast_cel_linkedid_ref(const char *linkedid)
 {
-	char *lid;
+	struct cel_linkedid *lid;
 
 	if (ast_strlen_zero(linkedid)) {
 		ast_log(LOG_ERROR, "The linkedid should never be empty\n");
 		return -1;
 	}
 
-	if (!(lid = ao2_find(linkedids, (void *) linkedid, OBJ_POINTER))) {
-		if (!(lid = ao2_alloc(strlen(linkedid) + 1, NULL))) {
-			return -1;
-		}
-		strcpy(lid, linkedid);
-		if (!ao2_link(linkedids, lid)) {
-			ao2_ref(lid, -1);
+	/* Get the lock in case any CEL events are still in flight when we shutdown. */
+	ast_mutex_lock(&reload_lock);
+
+	if (!cel_enabled || !ast_cel_track_event(AST_CEL_LINKEDID_END)) {
+		/* CEL is disabled or we are not tracking linkedids. */
+		ast_mutex_unlock(&reload_lock);
+		return 0;
+	}
+	if (!linkedids) {
+		/* The CEL module is shutdown.  Abort. */
+		ast_mutex_unlock(&reload_lock);
+		return -1;
+	}
+
+	lid = ao2_find(linkedids, (void *) linkedid, OBJ_KEY);
+	if (!lid) {
+		/*
+		 * Changes to the lid->count member are protected by the
+		 * reload_lock so the lid object does not need its own lock.
+		 */
+		lid = ao2_alloc_options(sizeof(*lid) + strlen(linkedid) + 1, NULL,
+			AO2_ALLOC_OPT_LOCK_NOLOCK);
+		if (!lid) {
+			ast_mutex_unlock(&reload_lock);
 			return -1;
 		}
-		/* Leave both the link and the alloc refs to show a count of 1 + the link */
+		strcpy(lid->id, linkedid);/* Safe */
+
+		ao2_link(linkedids, lid);
 	}
-	/* If we've found, go ahead and keep the ref to increment count of how many channels
-	 * have this linkedid. We'll clean it up in check_retire */
+	++lid->count;
+	ast_mutex_unlock(&reload_lock);
+	ao2_ref(lid, -1);
+
 	return 0;
 }
 
@@ -554,6 +658,12 @@
 	 * process otherwise. */
 	ast_mutex_lock(&reload_lock);
 
+	if (!appset) {
+		/* The CEL module is shutdown.  Abort. */
+		ast_mutex_unlock(&reload_lock);
+		return -1;
+	}
+
 	/* Record the linkedid of new channels if we are tracking LINKEDID_END even if we aren't
 	 * reporting on CHANNEL_START so we can track when to send LINKEDID_END */
 	if (cel_enabled && ast_cel_track_event(AST_CEL_LINKEDID_END) && event_type == AST_CEL_CHANNEL_START && linkedid) {
@@ -702,42 +812,83 @@
 
 static int app_cmp(void *obj, void *arg, int flags)
 {
-	const char *app1 = obj, *app2 = arg;
+	const char *app1 = obj;
+	const char *app2 = arg;
 
-	return !strcasecmp(app1, app2) ? CMP_MATCH | CMP_STOP : 0;
+	return !strcasecmp(app1, app2) ? CMP_MATCH : 0;
 }
 
-#define lid_hash app_hash
-#define lid_cmp app_cmp
-
-static void ast_cel_engine_term(void)
+static int lid_hash(const void *obj, const int flags)
 {
-	if (appset) {
-		ao2_ref(appset, -1);
-		appset = NULL;
+	const struct cel_linkedid *lid = obj;
+	const char *key = obj;
+
+	switch (flags & (OBJ_POINTER | OBJ_KEY)) {
+	case OBJ_POINTER:
+	default:
+		key = lid->id;
+		break;
+	case OBJ_KEY:
+		break;
 	}
-	if (linkedids) {
-		ao2_ref(linkedids, -1);
-		linkedids = NULL;
+
+	return ast_str_case_hash(key);
+}
+
+static int lid_cmp(void *obj, void *arg, int flags)
+{
+	struct cel_linkedid *lid1 = obj;
+	struct cel_linkedid *lid2 = arg;
+	const char *key = arg;
+
+	switch (flags & (OBJ_POINTER | OBJ_KEY)) {
+	case OBJ_POINTER:
+	default:
+		key = lid2->id;
+		break;
+	case OBJ_KEY:
+		break;
 	}
+
+	return !strcasecmp(lid1->id, key) ? CMP_MATCH : 0;
+}
+
+static void ast_cel_engine_term(void)
+{
+	/* Get the lock in case any CEL events are still in flight when we shutdown. */
+	ast_mutex_lock(&reload_lock);
+
+	ao2_cleanup(appset);
+	appset = NULL;
+	ao2_cleanup(linkedids);
+	linkedids = NULL;
+
+	ast_mutex_unlock(&reload_lock);
+
 	ast_cli_unregister(&cli_status);
 }
 
 int ast_cel_engine_init(void)
 {
-	if (!(appset = ao2_container_alloc(NUM_APP_BUCKETS, app_hash, app_cmp))) {
+	/*
+	 * Accesses to the appset and linkedids containers have to be
+	 * protected by the reload_lock so they don't need a lock of
+	 * their own.
+	 */
+	appset = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, NUM_APP_BUCKETS,
+		app_hash, app_cmp);
+	if (!appset) {
 		return -1;
 	}
-	if (!(linkedids = ao2_container_alloc(NUM_APP_BUCKETS, lid_hash, lid_cmp))) {
-		ao2_ref(appset, -1);
+	linkedids = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, NUM_APP_BUCKETS,
+		lid_hash, lid_cmp);
+	if (!linkedids) {
+		ast_cel_engine_term();
 		return -1;
 	}
 
-	if (do_reload() || ast_cli_register(&cli_status)) {
-		ao2_ref(appset, -1);
-		appset = NULL;
-		ao2_ref(linkedids, -1);
-		linkedids = NULL;
+	if (do_reload(0) || ast_cli_register(&cli_status)) {
+		ast_cel_engine_term();
 		return -1;
 	}
 
@@ -748,6 +899,6 @@
 
 int ast_cel_engine_reload(void)
 {
-	return do_reload();
+	return do_reload(1);
 }
 
--- main/channel.c
+++ main/channel.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404579 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 408643 $")
 
 #include "asterisk/_private.h"
 
@@ -3555,6 +3555,11 @@
 
 int ast_settimeout(struct ast_channel *c, unsigned int rate, int (*func)(const void *data), void *data)
 {
+	return ast_settimeout_full(c, rate, func, data, 0);
+}
+
+int ast_settimeout_full(struct ast_channel *c, unsigned int rate, int (*func)(const void *data), void *data, unsigned int is_ao2_obj)
+{
 	int res;
 	unsigned int real_rate = rate, max_rate;
 
@@ -3578,9 +3583,20 @@
 
 	res = ast_timer_set_rate(ast_channel_timer(c), real_rate);
 
+	if (ast_channel_timingdata(c) && ast_test_flag(ast_channel_flags(c), AST_FLAG_TIMINGDATA_IS_AO2_OBJ)) {
+		ao2_ref(ast_channel_timingdata(c), -1);
+	}
+
 	ast_channel_timingfunc_set(c, func);
 	ast_channel_timingdata_set(c, data);
 
+	if (data && is_ao2_obj) {
+		ao2_ref(data, 1);
+		ast_set_flag(ast_channel_flags(c), AST_FLAG_TIMINGDATA_IS_AO2_OBJ);
+	} else {
+		ast_clear_flag(ast_channel_flags(c), AST_FLAG_TIMINGDATA_IS_AO2_OBJ);
+	}
+
 	if (func == NULL && rate == 0 && ast_channel_fdno(c) == AST_TIMING_FD) {
 		/* Clearing the timing func and setting the rate to 0
 		 * means that we don't want to be reading from the timingfd
@@ -3913,9 +3929,17 @@
 				/* save a copy of func/data before unlocking the channel */
 				ast_timing_func_t func = ast_channel_timingfunc(chan);
 				void *data = ast_channel_timingdata(chan);
+				int got_ref = 0;
+				if (data && ast_test_flag(ast_channel_flags(chan), AST_FLAG_TIMINGDATA_IS_AO2_OBJ)) {
+					ao2_ref(data, 1);
+					got_ref = 1;
+				}
 				ast_channel_fdno_set(chan, -1);
 				ast_channel_unlock(chan);
 				func(data);
+				if (got_ref) {
+					ao2_ref(data, -1);
+				}
 			} else {
 				ast_timer_set_rate(ast_channel_timer(chan), 0);
 				ast_channel_fdno_set(chan, -1);
@@ -6797,6 +6821,7 @@
 	unsigned int orig_disablestatecache;
 	unsigned int clone_disablestatecache;
 	int visible_indication;
+	int moh_is_playing;
 	int clone_was_zombie = 0;/*!< TRUE if the clonechan was a zombie before the masquerade. */
 	struct ast_frame *current;
 	const struct ast_channel_tech *t;
@@ -6891,6 +6916,8 @@
 		xfer_colp = NULL;
 	}
 
+	moh_is_playing = ast_test_flag(ast_channel_flags(original), AST_FLAG_MOH);
+
 	/*
 	 * Stop any visible indication on the original channel so we can
 	 * transfer it to the clonechan taking the original's place.
@@ -7234,6 +7261,12 @@
 		ast_indicate(original, visible_indication);
 	}
 
+	/* if moh is playing on the original channel then it needs to be
+	   maintained on the channel that is replacing it. */
+	if (moh_is_playing) {
+		ast_moh_start(original, NULL, NULL);
+	}
+
 	ast_channel_lock(original);
 
 	/* Signal any blocker */
--- main/config.c
+++ main/config.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402407 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409917 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_CONFIG_DIR */
 #include "asterisk/network.h"	/* we do some sockaddr manipulation here */
@@ -88,7 +88,12 @@
 	AST_LIST_ENTRY(cache_file_mtime) list;
 	AST_LIST_HEAD_NOLOCK(includes, cache_file_include) includes;
 	unsigned int has_exec:1;
-	time_t mtime;
+	/*! stat() file size */
+	unsigned long stat_size;
+	/*! stat() file modtime nanoseconds */
+	unsigned long stat_mtime_nsec;
+	/*! stat() file modtime seconds since epoc */
+	time_t stat_mtime;
 
 	/*! String stuffed in filename[] after the filename string. */
 	const char *who_asked;
@@ -1180,6 +1185,65 @@
 	ATTRIBUTE_EXEC = 1,
 };
 
+/*!
+ * \internal
+ * \brief Clear the stat() data in the cached file modtime struct.
+ *
+ * \param cfmtime Cached file modtime.
+ *
+ * \return Nothing
+ */
+static void cfmstat_clear(struct cache_file_mtime *cfmtime)
+{
+	cfmtime->stat_size = 0;
+	cfmtime->stat_mtime_nsec = 0;
+	cfmtime->stat_mtime = 0;
+}
+
+/*!
+ * \internal
+ * \brief Save the stat() data to the cached file modtime struct.
+ *
+ * \param cfmtime Cached file modtime.
+ * \param statbuf Buffer filled in by stat().
+ *
+ * \return Nothing
+ */
+static void cfmstat_save(struct cache_file_mtime *cfmtime, struct stat *statbuf)
+{
+	cfmtime->stat_size = statbuf->st_size;
+#if defined(HAVE_STRUCT_STAT_ST_MTIM)
+	cfmtime->stat_mtime_nsec = statbuf->st_mtim.tv_nsec;
+#elif defined(HAVE_STRUCT_STAT_ST_MTIMENSEC)
+	cfmtime->stat_mtime_nsec = statbuf->st_mtimensec;
+#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC)
+	cfmtime->stat_mtime_nsec = statbuf->st_mtimespec.tv_nsec;
+#else
+	cfmtime->stat_mtime_nsec = 0;
+#endif
+	cfmtime->stat_mtime = statbuf->st_mtime;
+}
+
+/*!
+ * \internal
+ * \brief Compare the stat() data with the cached file modtime struct.
+ *
+ * \param cfmtime Cached file modtime.
+ * \param statbuf Buffer filled in by stat().
+ *
+ * \retval non-zero if different.
+ */
+static int cfmstat_cmp(struct cache_file_mtime *cfmtime, struct stat *statbuf)
+{
+	struct cache_file_mtime cfm_buf;
+
+	cfmstat_save(&cfm_buf, statbuf);
+
+	return cfmtime->stat_size != cfm_buf.stat_size
+		|| cfmtime->stat_mtime != cfm_buf.stat_mtime
+		|| cfmtime->stat_mtime_nsec != cfm_buf.stat_mtime_nsec;
+}
+
 static void config_cache_attribute(const char *configfile, enum config_cache_attribute_enum attrtype, const char *filename, const char *who_asked)
 {
 	struct cache_file_mtime *cfmtime;
@@ -1202,10 +1266,11 @@
 		AST_LIST_INSERT_SORTALPHA(&cfmtime_head, cfmtime, list, filename);
 	}
 
-	if (!stat(configfile, &statbuf))
-		cfmtime->mtime = 0;
-	else
-		cfmtime->mtime = statbuf.st_mtime;
+	if (stat(configfile, &statbuf)) {
+		cfmstat_clear(cfmtime);
+	} else {
+		cfmstat_save(cfmtime, &statbuf);
+	}
 
 	switch (attrtype) {
 	case ATTRIBUTE_INCLUDE:
@@ -1587,14 +1652,19 @@
 			}
 			if (!cfmtime) {
 				cfmtime = cfmtime_new(fn, who_asked);
-				if (!cfmtime)
+				if (!cfmtime) {
+					AST_LIST_UNLOCK(&cfmtime_head);
 					continue;
+				}
 				/* Note that the file mtime is initialized to 0, i.e. 1970 */
 				AST_LIST_INSERT_SORTALPHA(&cfmtime_head, cfmtime, list, filename);
 			}
 		}
 
-		if (cfmtime && (!cfmtime->has_exec) && (cfmtime->mtime == statbuf.st_mtime) && ast_test_flag(&flags, CONFIG_FLAG_FILEUNCHANGED)) {
+		if (cfmtime
+			&& !cfmtime->has_exec
+			&& !cfmstat_cmp(cfmtime, &statbuf)
+			&& ast_test_flag(&flags, CONFIG_FLAG_FILEUNCHANGED)) {
 			/* File is unchanged, what about the (cached) includes (if any)? */
 			int unchanged = 1;
 			AST_LIST_TRAVERSE(&cfmtime->includes, cfinclude, list) {
@@ -1651,8 +1721,9 @@
 			return NULL;
 		}
 
-		if (cfmtime)
-			cfmtime->mtime = statbuf.st_mtime;
+		if (cfmtime) {
+			cfmstat_save(cfmtime, &statbuf);
+		}
 
 		if (!(f = fopen(fn, "r"))) {
 			ast_debug(1, "No file to parse: %s\n", fn);
@@ -2287,7 +2358,6 @@
 		ast_log(LOG_ERROR, "Unable to allocate memory for new config\n");
 		return -1;
 	}
-	configtmp->max_include_level = 1;
 	config = ast_config_internal_load(extconfig_conf, configtmp, flags, "", "extconfig");
 	if (config == CONFIG_STATUS_FILEINVALID) {
 		return -1;
--- main/db.c
+++ main/db.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404344 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 410606 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_DB */
@@ -112,6 +112,7 @@
 static sqlite3 *astdb;
 static pthread_t syncthread;
 static int doexit;
+static int dosync;
 
 static void db_sync(void);
 
@@ -939,6 +940,7 @@
  */
 static void db_sync(void)
 {
+	dosync = 1;
 	ast_cond_signal(&dbcond);
 }
 
@@ -957,8 +959,14 @@
 	ast_mutex_lock(&dblock);
 	ast_db_begin_transaction();
 	for (;;) {
-		/* We're ok with spurious wakeups, so we don't worry about a predicate */
-		ast_cond_wait(&dbcond, &dblock);
+		/* If dosync is set, db_sync() was called during sleep(1), 
+		 * and the pending transaction should be committed. 
+		 * Otherwise, block until db_sync() is called.
+		 */
+		while (!dosync) {
+			ast_cond_wait(&dbcond, &dblock);
+		}
+		dosync = 0;
 		if (ast_db_commit_transaction()) {
 			ast_db_rollback_transaction();
 		}
@@ -970,15 +978,6 @@
 		ast_mutex_unlock(&dblock);
 		sleep(1);
 		ast_mutex_lock(&dblock);
-		/* Unfortunately, it is possible for signaling to happen
-		 * when we're not waiting: in the bit when we're unlocked
-		 * above. Do the do-exit check here again. (We could do
-		 * it once, but that would impose a forced delay of 1
-		 * second always.) */
-		if (doexit) {
-			ast_mutex_unlock(&dblock);
-			break;
-		}
 	}
 
 	return NULL;
@@ -995,8 +994,8 @@
 
 	/* Set doexit to 1 to kill thread. db_sync must be called with
 	 * mutex held. */
-	doexit = 1;
 	ast_mutex_lock(&dblock);
+	doexit = 1;
 	db_sync();
 	ast_mutex_unlock(&dblock);
 
--- main/devicestate.c
+++ main/devicestate.c
@@ -119,7 +119,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 385917 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407338 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/channel.h"
@@ -505,7 +505,7 @@
 		AST_LIST_UNLOCK(&state_changes);
 	}
 
-	return 1;
+	return 0;
 }
 
 int ast_device_state_changed_literal(const char *dev)
--- main/features.c
+++ main/features.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399305 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405792 $")
 
 #include "asterisk/_private.h"
 
@@ -2497,7 +2497,7 @@
 
 /*!
  * \brief Blind transfer user to another extension
- * \param chan channel to be transfered
+ * \param chan channel to be transferred
  * \param peer channel initiated blind transfer
  * \param config
  * \param code
@@ -2661,7 +2661,7 @@
 
 /*!
  * \brief Attended transfer
- * \param chan transfered user
+ * \param chan transferred user
  * \param peer person transfering call
  * \param config
  * \param code
@@ -3845,7 +3845,7 @@
  * \details
  * Request channel, set channel variables, initiate call,
  * check if they want to disconnect, go into loop, check if timeout has elapsed,
- * check if person to be transfered hung up, check for answer break loop,
+ * check if person to be transferred hung up, check for answer break loop,
  * set cdr return channel.
  *
  * \retval Channel Connected channel for transfer.
@@ -4463,7 +4463,7 @@
 				ast_set_flag(peer_cdr, AST_CDR_FLAG_BRIDGED);
 			}
 		}
-		/* the DIALED flag may be set if a dialed channel is transfered
+		/* the DIALED flag may be set if a dialed channel is transferred
 		 * and then bridged to another channel.  In order for the
 		 * bridge CDR to be written, the DIALED flag must not be
 		 * present. */
@@ -8157,7 +8157,7 @@
  *
  * Split data, check we aren't bridging with ourself, check valid channel,
  * answer call if not already, check compatible channels, setup bridge config
- * now bridge call, if transfered party hangs up return to PBX extension.
+ * now bridge call, if transferred party hangs up return to PBX extension.
  */
 static int bridge_exec(struct ast_channel *chan, const char *data)
 {
--- main/file.c
+++ main/file.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 380211 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 406567 $")
 
 #include <dirent.h>
 #include <sys/stat.h>
@@ -845,7 +845,7 @@
 
 			rate = (unsigned int) roundf(samp_rate / ((float) whennext));
 
-			ast_settimeout(s->owner, rate, ast_fsread_audio, s);
+			ast_settimeout_full(s->owner, rate, ast_fsread_audio, s, 1);
 		} else {
 			ast_channel_streamid_set(s->owner, ast_sched_add(ast_channel_sched(s->owner), whennext / (ast_format_rate(&s->fmt->format) / 1000), ast_fsread_audio, s));
 		}
--- main/format.c
+++ main/format.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $");
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 408137 $");
 
 #include "asterisk/_private.h"
 #include "asterisk/format.h"
@@ -129,7 +129,7 @@
 	}
 
 	ao2_rdlock(wrapper);
-	if (!(wrapper->interface || !wrapper->interface->format_attr_sdp_parse)) {
+	if (!wrapper->interface || !wrapper->interface->format_attr_sdp_parse) {
 		ao2_unlock(wrapper);
 		ao2_ref(wrapper, -1);
 		return 0;
@@ -152,7 +152,7 @@
 	}
 
 	ao2_rdlock(wrapper);
-	if (!(wrapper->interface || !wrapper->interface->format_attr_sdp_generate)) {
+	if (!wrapper->interface || !wrapper->interface->format_attr_sdp_generate) {
 		ao2_unlock(wrapper);
 		ao2_ref(wrapper, -1);
 		return;
--- main/http.c
+++ main/http.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 410431 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 410381 $")
 
 #include <time.h>
 #include <sys/time.h>
--- main/logger.c
+++ main/logger.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405431 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407456 $")
 
 /* When we include logger.h again it will trample on some stuff in syslog.h, but
  * nothing we care about in here. */
@@ -319,13 +319,22 @@
 		ast_copy_string(chan->filename, channel, sizeof(chan->filename));
 		openlog("asterisk", LOG_PID, chan->facility);
 	} else {
+		const char *log_dir_prefix = "";
+		const char *log_dir_separator = "";
+
+		if (channel[0] != '/') {
+			log_dir_prefix = ast_config_AST_LOG_DIR;
+			log_dir_separator = "/";
+		}
+
 		if (!ast_strlen_zero(hostname)) {
-			snprintf(chan->filename, sizeof(chan->filename), "%s/%s.%s",
-				 channel[0] != '/' ? ast_config_AST_LOG_DIR : "", channel, hostname);
+			snprintf(chan->filename, sizeof(chan->filename), "%s%s%s.%s",
+				log_dir_prefix, log_dir_separator, channel, hostname);
 		} else {
-			snprintf(chan->filename, sizeof(chan->filename), "%s/%s",
-				 channel[0] != '/' ? ast_config_AST_LOG_DIR : "", channel);
+			snprintf(chan->filename, sizeof(chan->filename), "%s%s%s",
+				log_dir_prefix, log_dir_separator, channel);
 		}
+
 		if (!(chan->fileptr = fopen(chan->filename, "a"))) {
 			/* Can't do real logging here since we're called with a lock
 			 * so log to any attached consoles */
@@ -996,7 +1005,7 @@
 	AST_CLI_DEFINE(handle_logger_show_channels, "List configured log channels"),
 	AST_CLI_DEFINE(handle_logger_reload, "Reopens the log files"),
 	AST_CLI_DEFINE(handle_logger_rotate, "Rotates and reopens the log files"),
-	AST_CLI_DEFINE(handle_logger_set_level, "Enables/Disables a specific logging level for this console")
+	AST_CLI_DEFINE(handle_logger_set_level, "Enables/Disables a specific logging level for this console"),
 };
 
 static void _handle_SIGXFSZ(int sig)
--- main/manager.c
+++ main/manager.c
@@ -47,7 +47,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405431 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 410609 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use various ast_config_AST_* */
@@ -1150,7 +1150,8 @@
 	ast_mutex_t lock;
 };
 
-static struct ao2_container *sessions = NULL;
+/*! Active manager connection sessions container. */
+static AO2_GLOBAL_OBJ_STATIC(mgr_sessions);
 
 struct manager_channel_variable {
 	AST_LIST_ENTRY(manager_channel_variable) entry;
@@ -1192,7 +1193,7 @@
 static AST_RWLIST_HEAD_STATIC(manager_hooks, manager_custom_hook);
 
 /*! \brief A container of event documentation nodes */
-AO2_GLOBAL_OBJ_STATIC(event_docs);
+static AO2_GLOBAL_OBJ_STATIC(event_docs);
 
 static void free_channelvars(void);
 
@@ -1468,7 +1469,7 @@
 	if (manager_debug) {
 		ast_debug(1, "Mansession: %p refcount now %d\n", s, refcount - 1);
 	}
-	return s;
+	return NULL;
 }
 
 static void event_filter_destructor(void *obj)
@@ -1500,42 +1501,43 @@
 	}
 
 	if (session->whitefilters) {
-		ao2_t_callback(session->whitefilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, "unlink all white filters");
-		ao2_t_ref(session->whitefilters, -1 , "decrement ref for white container, should be last one");
+		ao2_t_ref(session->whitefilters, -1, "decrement ref for white container, should be last one");
 	}
 
 	if (session->blackfilters) {
-		ao2_t_callback(session->blackfilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, "unlink all black filters");
-		ao2_t_ref(session->blackfilters, -1 , "decrement ref for black container, should be last one");
+		ao2_t_ref(session->blackfilters, -1, "decrement ref for black container, should be last one");
 	}
 }
 
 /*! \brief Allocate manager session structure and add it to the list of sessions */
 static struct mansession_session *build_mansession(const struct ast_sockaddr *addr)
 {
+	struct ao2_container *sessions;
 	struct mansession_session *newsession;
 
-	if (!(newsession = ao2_alloc(sizeof(*newsession), session_destructor))) {
+	newsession = ao2_alloc(sizeof(*newsession), session_destructor);
+	if (!newsession) {
 		return NULL;
 	}
 
-	if (!(newsession->whitefilters = ao2_container_alloc(1, NULL, NULL))) {
+	newsession->whitefilters = ao2_container_alloc(1, NULL, NULL);
+	newsession->blackfilters = ao2_container_alloc(1, NULL, NULL);
+	if (!newsession->whitefilters || !newsession->blackfilters) {
 		ao2_ref(newsession, -1);
 		return NULL;
 	}
 
-	if (!(newsession->blackfilters = ao2_container_alloc(1, NULL, NULL))) {
-		ao2_ref(newsession, -1); /* session_destructor will cleanup the other filter */
-		return NULL;
-	}
-
 	newsession->fd = -1;
 	newsession->waiting_thread = AST_PTHREADT_NULL;
 	newsession->writetimeout = 100;
 	newsession->send_events = -1;
 	ast_sockaddr_copy(&newsession->addr, addr);
 
-	ao2_link(sessions, newsession);
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (sessions) {
+		ao2_link(sessions, newsession);
+		ao2_ref(sessions, -1);
+	}
 
 	return newsession;
 }
@@ -1549,19 +1551,31 @@
 
 static void session_destroy(struct mansession_session *s)
 {
+	struct ao2_container *sessions;
+
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (sessions) {
+		ao2_unlink(sessions, s);
+		ao2_ref(sessions, -1);
+	}
 	unref_mansession(s);
-	ao2_unlink(sessions, s);
 }
 
 
 static int check_manager_session_inuse(const char *name)
 {
-	struct mansession_session *session = ao2_find(sessions, (char *) name, 0);
+	struct ao2_container *sessions;
+	struct mansession_session *session;
 	int inuse = 0;
 
-	if (session) {
-		inuse = 1;
-		unref_mansession(session);
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (sessions) {
+		session = ao2_find(sessions, (char *) name, 0);
+		ao2_ref(sessions, -1);
+		if (session) {
+			unref_mansession(session);
+			inuse = 1;
+		}
 	}
 	return inuse;
 }
@@ -1852,6 +1866,7 @@
 /*! \brief CLI command manager list connected */
 static char *handle_showmanconn(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
+	struct ao2_container *sessions;
 	struct mansession_session *session;
 	time_t now = time(NULL);
 #define HSMCONN_FORMAT1 "  %-15.15s  %-55.55s  %-10.10s  %-10.10s  %-8.8s  %-8.8s  %-5.5s  %-5.5s\n"
@@ -1873,15 +1888,26 @@
 
 	ast_cli(a->fd, HSMCONN_FORMAT1, "Username", "IP Address", "Start", "Elapsed", "FileDes", "HttpCnt", "Read", "Write");
 
-	i = ao2_iterator_init(sessions, 0);
-	while ((session = ao2_iterator_next(&i))) {
-		ao2_lock(session);
-		ast_cli(a->fd, HSMCONN_FORMAT2, session->username, ast_sockaddr_stringify_addr(&session->addr), (int)(session->sessionstart), (int)(now - session->sessionstart), session->fd, session->inuse, session->readperm, session->writeperm);
-		count++;
-		ao2_unlock(session);
-		unref_mansession(session);
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (sessions) {
+		i = ao2_iterator_init(sessions, 0);
+		ao2_ref(sessions, -1);
+		while ((session = ao2_iterator_next(&i))) {
+			ao2_lock(session);
+			ast_cli(a->fd, HSMCONN_FORMAT2, session->username,
+				ast_sockaddr_stringify_addr(&session->addr),
+				(int) (session->sessionstart),
+				(int) (now - session->sessionstart),
+				session->fd,
+				session->inuse,
+				session->readperm,
+				session->writeperm);
+			count++;
+			ao2_unlock(session);
+			unref_mansession(session);
+		}
+		ao2_iterator_destroy(&i);
 	}
-	ao2_iterator_destroy(&i);
 	ast_cli(a->fd, "%d users connected.\n", count);
 
 	return CLI_SUCCESS;
@@ -3343,7 +3369,8 @@
 
 	if (name_or_regex[0] != '/') {
 		if (!(c = ast_channel_get_by_name(name_or_regex))) {
-			ast_log(LOG_NOTICE, "!!!!!!!!!! Can't find channel to hang up!\n");
+			ast_log(LOG_NOTICE, "Request to hangup non-existent channel: %s\n",
+				name_or_regex);
 			astman_send_error(s, m, "No such channel");
 			return 0;
 		}
@@ -4372,6 +4399,7 @@
 
 	if (!cap) {
 		astman_send_error(s, m, "Internal Error. Memory allocation failure.");
+		return 0;
 	}
 	ast_format_cap_add(cap, ast_format_set(&tmp_fmt, AST_FORMAT_SLINEAR, 0));
 
@@ -4771,8 +4799,8 @@
 		is_blackfilter = 0;
 	}
 
-	if (regcomp(new_filter, filter_pattern, 0)) {
-		ao2_t_ref(new_filter, -1, "failed to make regx");
+	if (regcomp(new_filter, filter_pattern, 0)) { /* XXX: the only place we use non-REG_EXTENDED */
+		ao2_t_ref(new_filter, -1, "failed to make regex");
 		return FILTER_COMPILE_FAIL;
 	}
 
@@ -4782,6 +4810,8 @@
 		ao2_t_link(whitefilters, new_filter, "link new filter into white user container");
 	}
 
+	ao2_ref(new_filter, -1);
+
 	return FILTER_SUCCESS;
 }
 
@@ -5569,15 +5599,17 @@
 /*! \brief remove at most n_max stale session from the list. */
 static void purge_sessions(int n_max)
 {
+	struct ao2_container *sessions;
 	struct mansession_session *session;
 	time_t now = time(NULL);
 	struct ao2_iterator i;
 
+	sessions = ao2_global_obj_ref(mgr_sessions);
 	if (!sessions) {
 		return;
 	}
-
 	i = ao2_iterator_init(sessions, 0);
+	ao2_ref(sessions, -1);
 	while ((session = ao2_iterator_next(&i)) && n_max > 0) {
 		ao2_lock(session);
 		if (session->sessiontimeout && (now > session->sessiontimeout) && !session->inuse) {
@@ -5656,9 +5688,11 @@
 AST_THREADSTORAGE(manager_event_buf);
 #define MANAGER_EVENT_BUF_INITSIZE   256
 
-int __ast_manager_event_multichan(int category, const char *event, int chancount, struct
-	ast_channel **chans, const char *file, int line, const char *func, const char *fmt, ...)
+int __ast_manager_event_multichan(int category, const char *event, int chancount,
+	struct ast_channel **chans, const char *file, int line, const char *func,
+	const char *fmt, ...)
 {
+	RAII_VAR(struct ao2_container *, sessions, ao2_global_obj_ref(mgr_sessions), ao2_cleanup);
 	struct mansession_session *session;
 	struct manager_custom_hook *hook;
 	struct ast_str *auth = ast_str_alloca(80);
@@ -5969,6 +6003,7 @@
  */
 static struct mansession_session *find_session(uint32_t ident, int incinuse)
 {
+	struct ao2_container *sessions;
 	struct mansession_session *session;
 	struct ao2_iterator i;
 
@@ -5976,7 +6011,12 @@
 		return NULL;
 	}
 
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (!sessions) {
+		return NULL;
+	}
 	i = ao2_iterator_init(sessions, 0);
+	ao2_ref(sessions, -1);
 	while ((session = ao2_iterator_next(&i))) {
 		ao2_lock(session);
 		if (session->managerid == ident && !session->needdestroy) {
@@ -6003,13 +6043,19 @@
 static struct mansession_session *find_session_by_nonce(const char *username, unsigned long nonce, int *stale)
 {
 	struct mansession_session *session;
+	struct ao2_container *sessions;
 	struct ao2_iterator i;
 
 	if (nonce == 0 || username == NULL || stale == NULL) {
 		return NULL;
 	}
 
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (!sessions) {
+		return NULL;
+	}
 	i = ao2_iterator_init(sessions, 0);
+	ao2_ref(sessions, -1);
 	while ((session = ao2_iterator_next(&i))) {
 		ao2_lock(session);
 		if (!strcasecmp(session->username, username) && session->managerid == nonce) {
@@ -6023,6 +6069,7 @@
 		unref_mansession(session);
 	}
 	ao2_iterator_destroy(&i);
+
 	return session;
 }
 
@@ -6046,13 +6093,19 @@
 {
 	int result = 0;
 	struct mansession_session *session;
+	struct ao2_container *sessions;
 	struct ao2_iterator i;
 
 	if (ident == 0) {
 		return 0;
 	}
 
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (!sessions) {
+		return 0;
+	}
 	i = ao2_iterator_init(sessions, 0);
+	ao2_ref(sessions, -1);
 	while ((session = ao2_iterator_next(&i))) {
 		ao2_lock(session);
 		if ((session->managerid == ident) && (session->readperm & perm)) {
@@ -6065,6 +6118,7 @@
 		unref_mansession(session);
 	}
 	ao2_iterator_destroy(&i);
+
 	return result;
 }
 
@@ -6072,13 +6126,19 @@
 {
 	int result = 0;
 	struct mansession_session *session;
+	struct ao2_container *sessions;
 	struct ao2_iterator i;
 
 	if (ident == 0) {
 		return 0;
 	}
 
+	sessions = ao2_global_obj_ref(mgr_sessions);
+	if (!sessions) {
+		return 0;
+	}
 	i = ao2_iterator_init(sessions, 0);
+	ao2_ref(sessions, -1);
 	while ((session = ao2_iterator_next(&i))) {
 		ao2_lock(session);
 		if ((session->managerid == ident) && (session->writeperm & perm)) {
@@ -6091,6 +6151,7 @@
 		unref_mansession(session);
 	}
 	ao2_iterator_destroy(&i);
+
 	return result;
 }
 
@@ -6562,12 +6623,8 @@
 	if (method == AST_HTTP_POST && params) {
 		ast_variables_destroy(params);
 	}
-	if (http_header) {
-		ast_free(http_header);
-	}
-	if (out) {
-		ast_free(out);
-	}
+	ast_free(http_header);
+	ast_free(out);
 
 	if (session && blastaway) {
 		session_destroy(session);
@@ -7053,7 +7110,13 @@
 
 	if (!strcasecmp(args.param, "sessions")) {
 		int no_sessions = 0;
-		ao2_callback_data(sessions, 0, get_manager_sessions_cb, /*login name*/ data, &no_sessions);
+		struct ao2_container *sessions;
+
+		sessions = ao2_global_obj_ref(mgr_sessions);
+		if (sessions) {
+			ao2_callback_data(sessions, 0, get_manager_sessions_cb, /*login name*/ data, &no_sessions);
+			ao2_ref(sessions, -1);
+		}
 		snprintf(buf, len, "%d", no_sessions);
 	} else {
 		ast_log(LOG_ERROR, "Invalid arguments provided to function AMI_CLIENT: %s\n", args.param);
@@ -7072,7 +7135,6 @@
 	.read_max = 12,
 };
 
-static int registered = 0;
 static int webregged = 0;
 
 /*! \brief cleanup code called at each iteration of server_root,
@@ -7383,16 +7445,14 @@
 /*! \internal \brief Free a user record.  Should already be removed from the list */
 static void manager_free_user(struct ast_manager_user *user)
 {
-	if (user->a1_hash) {
-		ast_free(user->a1_hash);
+	ast_free(user->a1_hash);
+	ast_free(user->secret);
+	if (user->whitefilters) {
+		ao2_t_ref(user->whitefilters, -1, "decrement ref for white container, should be last one");
 	}
-	if (user->secret) {
-		ast_free(user->secret);
+	if (user->blackfilters) {
+		ao2_t_ref(user->blackfilters, -1, "decrement ref for black container, should be last one");
 	}
-	ao2_t_callback(user->whitefilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, "unlink all white filters");
-	ao2_t_callback(user->blackfilters, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL, "unlink all black filters");
-	ao2_t_ref(user->whitefilters, -1, "decrement ref for white container, should be last one");
-	ao2_t_ref(user->blackfilters, -1, "decrement ref for black container, should be last one");
 	user->acl = ast_free_acl_list(user->acl);
 	ast_variables_destroy(user->chanvars);
 	ast_free(user);
@@ -7403,45 +7463,43 @@
 {
 	struct ast_manager_user *user;
 
-	if (registered) {
-		ast_manager_unregister("Ping");
-		ast_manager_unregister("Events");
-		ast_manager_unregister("Logoff");
-		ast_manager_unregister("Login");
-		ast_manager_unregister("Challenge");
-		ast_manager_unregister("Hangup");
-		ast_manager_unregister("Status");
-		ast_manager_unregister("Setvar");
-		ast_manager_unregister("Getvar");
-		ast_manager_unregister("GetConfig");
-		ast_manager_unregister("GetConfigJSON");
-		ast_manager_unregister("UpdateConfig");
-		ast_manager_unregister("CreateConfig");
-		ast_manager_unregister("ListCategories");
-		ast_manager_unregister("Redirect");
-		ast_manager_unregister("Atxfer");
-		ast_manager_unregister("Originate");
-		ast_manager_unregister("Command");
-		ast_manager_unregister("ExtensionState");
-		ast_manager_unregister("PresenceState");
-		ast_manager_unregister("AbsoluteTimeout");
-		ast_manager_unregister("MailboxStatus");
-		ast_manager_unregister("MailboxCount");
-		ast_manager_unregister("ListCommands");
-		ast_manager_unregister("SendText");
-		ast_manager_unregister("UserEvent");
-		ast_manager_unregister("WaitEvent");
-		ast_manager_unregister("CoreSettings");
-		ast_manager_unregister("CoreStatus");
-		ast_manager_unregister("Reload");
-		ast_manager_unregister("CoreShowChannels");
-		ast_manager_unregister("ModuleLoad");
-		ast_manager_unregister("ModuleCheck");
-		ast_manager_unregister("AOCMessage");
-		ast_manager_unregister("Filter");
-		ast_custom_function_unregister(&managerclient_function);
-		ast_cli_unregister_multiple(cli_manager, ARRAY_LEN(cli_manager));
-	}
+	ast_manager_unregister("Ping");
+	ast_manager_unregister("Events");
+	ast_manager_unregister("Logoff");
+	ast_manager_unregister("Login");
+	ast_manager_unregister("Challenge");
+	ast_manager_unregister("Hangup");
+	ast_manager_unregister("Status");
+	ast_manager_unregister("Setvar");
+	ast_manager_unregister("Getvar");
+	ast_manager_unregister("GetConfig");
+	ast_manager_unregister("GetConfigJSON");
+	ast_manager_unregister("UpdateConfig");
+	ast_manager_unregister("CreateConfig");
+	ast_manager_unregister("ListCategories");
+	ast_manager_unregister("Redirect");
+	ast_manager_unregister("Atxfer");
+	ast_manager_unregister("Originate");
+	ast_manager_unregister("Command");
+	ast_manager_unregister("ExtensionState");
+	ast_manager_unregister("PresenceState");
+	ast_manager_unregister("AbsoluteTimeout");
+	ast_manager_unregister("MailboxStatus");
+	ast_manager_unregister("MailboxCount");
+	ast_manager_unregister("ListCommands");
+	ast_manager_unregister("SendText");
+	ast_manager_unregister("UserEvent");
+	ast_manager_unregister("WaitEvent");
+	ast_manager_unregister("CoreSettings");
+	ast_manager_unregister("CoreStatus");
+	ast_manager_unregister("Reload");
+	ast_manager_unregister("CoreShowChannels");
+	ast_manager_unregister("ModuleLoad");
+	ast_manager_unregister("ModuleCheck");
+	ast_manager_unregister("AOCMessage");
+	ast_manager_unregister("Filter");
+	ast_custom_function_unregister(&managerclient_function);
+	ast_cli_unregister_multiple(cli_manager, ARRAY_LEN(cli_manager));
 
 #ifdef AST_XML_DOCS
 	ao2_t_global_obj_release(event_docs, "Dispose of event_docs");
@@ -7450,35 +7508,49 @@
 	ast_tcptls_server_stop(&ami_desc);
 	ast_tcptls_server_stop(&amis_desc);
 
-	if (ami_tls_cfg.certfile) {
-		ast_free(ami_tls_cfg.certfile);
-		ami_tls_cfg.certfile = NULL;
-	}
-	if (ami_tls_cfg.pvtfile) {
-		ast_free(ami_tls_cfg.pvtfile);
-		ami_tls_cfg.pvtfile = NULL;
-	}
-	if (ami_tls_cfg.cipher) {
-		ast_free(ami_tls_cfg.cipher);
-		ami_tls_cfg.cipher = NULL;
-	}
+	ast_free(ami_tls_cfg.certfile);
+	ami_tls_cfg.certfile = NULL;
+	ast_free(ami_tls_cfg.pvtfile);
+	ami_tls_cfg.pvtfile = NULL;
+	ast_free(ami_tls_cfg.cipher);
+	ami_tls_cfg.cipher = NULL;
 
-	if (sessions) {
-		ao2_ref(sessions, -1);
-		sessions = NULL;
-	}
+	ao2_global_obj_release(mgr_sessions);
 
 	while ((user = AST_LIST_REMOVE_HEAD(&users, list))) {
 		manager_free_user(user);
 	}
 }
 
+static void manager_set_defaults(void)
+{
+	manager_enabled = 0;
+	displayconnects = 1;
+	broken_events_action = 0;
+	authtimeout = 30;
+	authlimit = 50;
+	manager_debug = 0;		/* Debug disabled by default */
+
+	/* default values */
+	ast_copy_string(global_realm, S_OR(ast_config_AST_SYSTEM_NAME, DEFAULT_REALM),
+		sizeof(global_realm));
+	ast_sockaddr_setnull(&ami_desc.local_address);
+	ast_sockaddr_setnull(&amis_desc.local_address);
+
+	ami_tls_cfg.enabled = 0;
+	ast_free(ami_tls_cfg.certfile);
+	ami_tls_cfg.certfile = ast_strdup(AST_CERTFILE);
+	ast_free(ami_tls_cfg.pvtfile);
+	ami_tls_cfg.pvtfile = ast_strdup("");
+	ast_free(ami_tls_cfg.cipher);
+	ami_tls_cfg.cipher = ast_strdup("");
+
+	free_channelvars();
+}
+
 static int __init_manager(int reload, int by_external_config)
 {
 	struct ast_config *ucfg = NULL, *cfg = NULL;
-#ifdef AST_XML_DOCS
-	struct ao2_container *temp_event_docs;
-#endif
 	const char *val;
 	char *cat = NULL;
 	int newhttptimeout = 60;
@@ -7492,9 +7564,14 @@
 	int tls_was_enabled = 0;
 	int acl_subscription_flag = 0;
 
-	manager_enabled = 0;
+	if (!reload) {
+		struct ao2_container *sessions;
+#ifdef AST_XML_DOCS
+		struct ao2_container *temp_event_docs;
+#endif
+
+		ast_register_atexit(manager_shutdown);
 
-	if (!registered) {
 		/* Register default actions */
 		ast_manager_register_xml_core("Ping", 0, action_ping);
 		ast_manager_register_xml_core("Events", 0, action_events);
@@ -7535,33 +7612,37 @@
 		ast_cli_register_multiple(cli_manager, ARRAY_LEN(cli_manager));
 		__ast_custom_function_register(&managerclient_function, NULL);
 		ast_extension_state_add(NULL, NULL, manager_state_cb, NULL);
-		registered = 1;
+
 		/* Append placeholder event so master_eventq never runs dry */
-		append_event("Event: Placeholder\r\n\r\n", 0);
-	}
+		if (append_event("Event: Placeholder\r\n\r\n", 0)) {
+			return -1;
+		}
 
 #ifdef AST_XML_DOCS
-	temp_event_docs = ast_xmldoc_build_documentation("managerEvent");
-	if (temp_event_docs) {
-		ao2_t_global_obj_replace_unref(event_docs, temp_event_docs, "Toss old event docs");
-		ao2_t_ref(temp_event_docs, -1, "Remove creation ref - container holds only ref now");
-	}
+		temp_event_docs = ast_xmldoc_build_documentation("managerEvent");
+		if (temp_event_docs) {
+			ao2_t_global_obj_replace_unref(event_docs, temp_event_docs, "Toss old event docs");
+			ao2_t_ref(temp_event_docs, -1, "Remove creation ref - container holds only ref now");
+		}
 #endif
 
-	ast_register_atexit(manager_shutdown);
+		/* If you have a NULL hash fn, you only need a single bucket */
+		sessions = ao2_container_alloc(1, NULL, mansession_cmp_fn);
+		if (!sessions) {
+			return -1;
+		}
+		ao2_global_obj_replace_unref(mgr_sessions, sessions);
+		ao2_ref(sessions, -1);
 
-	if ((cfg = ast_config_load2("manager.conf", "manager", config_flags)) == CONFIG_STATUS_FILEUNCHANGED) {
-		return 0;
+		/* Initialize all settings before first configuration load. */
+		manager_set_defaults();
 	}
 
-	displayconnects = 1;
-	broken_events_action = 0;
-	authtimeout = 30;
-	authlimit = 50;
-	manager_debug = 0;		/* Debug disabled by default */
-
-	if (!cfg || cfg == CONFIG_STATUS_FILEINVALID) {
-		ast_log(LOG_NOTICE, "Unable to open AMI configuration manager.conf, or configuration is invalid. Asterisk management interface (AMI) disabled.\n");
+	cfg = ast_config_load2("manager.conf", "manager", config_flags);
+	if (cfg == CONFIG_STATUS_FILEUNCHANGED) {
+		return 0;
+	} else if (!cfg || cfg == CONFIG_STATUS_FILEINVALID) {
+		ast_log(LOG_NOTICE, "Unable to open AMI configuration manager.conf, or configuration is invalid.\n");
 		return 0;
 	}
 
@@ -7570,32 +7651,15 @@
 		acl_change_event_unsubscribe();
 	}
 
-	/* default values */
-	ast_copy_string(global_realm, S_OR(ast_config_AST_SYSTEM_NAME, DEFAULT_REALM), sizeof(global_realm));
-	ast_sockaddr_setnull(&ami_desc.local_address);
-	ast_sockaddr_setnull(&amis_desc.local_address);
+	if (reload) {
+		/* Reset all settings before reloading configuration */
+		tls_was_enabled = ami_tls_cfg.enabled;
+		manager_set_defaults();
+	}
 
 	ast_sockaddr_parse(&ami_desc_local_address_tmp, "[::]", 0);
 	ast_sockaddr_set_port(&ami_desc_local_address_tmp, DEFAULT_MANAGER_PORT);
 
-	tls_was_enabled = (reload && ami_tls_cfg.enabled);
-
-	ami_tls_cfg.enabled = 0;
-	if (ami_tls_cfg.certfile) {
-		ast_free(ami_tls_cfg.certfile);
-	}
-	ami_tls_cfg.certfile = ast_strdup(AST_CERTFILE);
-	if (ami_tls_cfg.pvtfile) {
-		ast_free(ami_tls_cfg.pvtfile);
-	}
-	ami_tls_cfg.pvtfile = ast_strdup("");
-	if (ami_tls_cfg.cipher) {
-		ast_free(ami_tls_cfg.cipher);
-	}
-	ami_tls_cfg.cipher = ast_strdup("");
-
-	free_channelvars();
-
 	for (var = ast_variable_browse(cfg, "general"); var; var = var->next) {
 		val = var->value;
 
@@ -7754,9 +7818,7 @@
 				}
 
 				if (!ast_strlen_zero(user_secret)) {
-					if (user->secret) {
-						ast_free(user->secret);
-					}
+					ast_free(user->secret);
 					user->secret = ast_strdup(user_secret);
 				}
 
@@ -7807,6 +7869,10 @@
 			user->writetimeout = 100;
 			user->whitefilters = ao2_container_alloc(1, NULL, NULL);
 			user->blackfilters = ao2_container_alloc(1, NULL, NULL);
+			if (!user->whitefilters || !user->blackfilters) {
+				manager_free_user(user);
+				break;
+			}
 
 			/* Insert into list */
 			AST_RWLIST_INSERT_TAIL(&users, user, list);
@@ -7824,9 +7890,7 @@
 		var = ast_variable_browse(cfg, cat);
 		for (; var; var = var->next) {
 			if (!strcasecmp(var->name, "secret")) {
-				if (user->secret) {
-					ast_free(user->secret);
-				}
+				ast_free(user->secret);
 				user->secret = ast_strdup(var->value);
 			} else if (!strcasecmp(var->name, "deny") ||
 				       !strcasecmp(var->name, "permit") ||
@@ -7886,9 +7950,7 @@
 			/* Calculate A1 for Digest auth */
 			snprintf(a1, sizeof(a1), "%s:%s:%s", user->username, global_realm, user->secret);
 			ast_md5_hash(a1_hash,a1);
-			if (user->a1_hash) {
-				ast_free(user->a1_hash);
-			}
+			ast_free(user->a1_hash);
 			user->a1_hash = ast_strdup(a1_hash);
 			continue;
 		}
@@ -7901,14 +7963,8 @@
 
 	AST_RWLIST_UNLOCK(&users);
 
-	if (!reload) {
-		/* If you have a NULL hash fn, you only need a single bucket */
-		sessions = ao2_container_alloc(1, NULL, mansession_cmp_fn);
-	}
-
 	if (webmanager_enabled && manager_enabled) {
 		if (!webregged) {
-
 			ast_http_uri_link(&rawmanuri);
 			ast_http_uri_link(&manageruri);
 			ast_http_uri_link(&managerxmluri);
@@ -7935,7 +7991,11 @@
 		httptimeout = newhttptimeout;
 	}
 
-	manager_event(EVENT_FLAG_SYSTEM, "Reload", "Module: Manager\r\nStatus: %s\r\nMessage: Manager reload Requested\r\n", manager_enabled ? "Enabled" : "Disabled");
+	manager_event(EVENT_FLAG_SYSTEM, "Reload",
+		"Module: Manager\r\n"
+		"Status: %s\r\n"
+		"Message: Manager reload Requested\r\n",
+		manager_enabled ? "Enabled" : "Disabled");
 
 	ast_tcptls_server_start(&ami_desc);
 	if (tls_was_enabled && !ami_tls_cfg.enabled) {
--- main/pbx.c
+++ main/pbx.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 405431 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 408786 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_SYSTEM_NAME */
@@ -1629,10 +1629,6 @@
 	return res;
 }
 
-
-/*! Go no deeper than this through includes (not counting loops) */
-#define AST_PBX_MAX_STACK	128
-
 /*! \brief Find application handle in linked list
  */
 struct ast_app *pbx_findapp(const char *app)
@@ -3957,6 +3953,7 @@
 	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&escalation_root, cur_escalation, list) {
 		if (cur_escalation->acf == acf) {
 			AST_RWLIST_REMOVE_CURRENT(list);
+			ast_free(cur_escalation);
 			break;
 		}
 	}
@@ -8923,6 +8920,16 @@
 	begintime = ast_tvnow();
 	ast_mutex_lock(&context_merge_lock);/* Serialize ast_merge_contexts_and_delete */
 	ast_wrlock_contexts();
+
+	if (!contexts_table) {
+		/* Well, that's odd. There are no contexts. */
+		contexts_table = exttable;
+		contexts = *extcontexts;
+		ast_unlock_contexts();
+		ast_mutex_unlock(&context_merge_lock);
+		return;
+	}
+
 	iter = ast_hashtab_start_traversal(contexts_table);
 	while ((tmp = ast_hashtab_next(iter))) {
 		context_merge(extcontexts, exttable, tmp, registrar);
@@ -9281,6 +9288,8 @@
 	char *info;
 	int j, num_fields, last_sep = -1;
 
+	i->timezone = NULL;
+
 	/* Check for empty just in case */
 	if (ast_strlen_zero(info_in)) {
 		return 0;
@@ -9300,8 +9309,6 @@
 	/* save the timezone, if it is specified */
 	if (num_fields == 5) {
 		i->timezone = ast_strdup(info + last_sep + 1);
-	} else {
-		i->timezone = NULL;
 	}
 
 	/* Assume everything except time */
--- main/rtp_engine.c
+++ main/rtp_engine.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404045 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409524 $")
 
 #include <math.h>
 
@@ -731,6 +731,14 @@
 	return (type->asterisk_format && (ast_format_cmp(&type->format, format) != AST_FORMAT_CMP_NOT_EQUAL)) ? CMP_MATCH | CMP_STOP : 0;
 }
 
+static int rtp_payload_type_find_nonast_format(void *obj, void *arg, int flags)
+{
+	struct ast_rtp_payload_type *type = obj;
+	int *rtp_code = arg;
+
+	return ((!type->asterisk_format && (type->rtp_code == *rtp_code)) ? CMP_MATCH | CMP_STOP : 0);
+}
+
 int ast_rtp_codecs_payload_code(struct ast_rtp_codecs *codecs, int asterisk_format, const struct ast_format *format, int code)
 {
 	struct ast_rtp_payload_type *type;
@@ -740,7 +748,7 @@
 		res = type->payload;
 		ao2_ref(type, -1);
 		return res;
-	} else if (!asterisk_format && (type = ao2_find(codecs->payloads, &code, OBJ_NOLOCK | OBJ_KEY))) {
+	} else if (!asterisk_format && (type = ao2_callback(codecs->payloads, OBJ_NOLOCK, rtp_payload_type_find_nonast_format, (void*)&code))) {
 		res = type->payload;
 		ao2_ref(type, -1);
 		return res;
@@ -1216,10 +1224,12 @@
 		if (tinstance1) {
 			ast_rtp_instance_get_remote_address(tinstance1, &tt1);
 		}
-		if (glue1->get_codec) {
+		ast_channel_lock(c1);
+		if (glue1->get_codec && ast_channel_tech_pvt(c1)) {
 			ast_format_cap_remove_all(cap1);
 			glue1->get_codec(c1, cap1);
 		}
+		ast_channel_unlock(c1);
 
 		ast_rtp_instance_get_remote_address(instance0, &t0);
 		if (vinstance0) {
@@ -1228,10 +1238,12 @@
 		if (tinstance0) {
 			ast_rtp_instance_get_remote_address(tinstance0, &tt0);
 		}
-		if (glue0->get_codec) {
+		ast_channel_lock(c0);
+		if (glue0->get_codec && ast_channel_tech_pvt(c0)) {
 			ast_format_cap_remove_all(cap0);
 			glue0->get_codec(c0, cap0);
 		}
+		ast_channel_unlock(c0);
 
 		if ((ast_sockaddr_cmp(&t1, &ac1)) ||
 		    (vinstance1 && ast_sockaddr_cmp(&vt1, &vac1)) ||
@@ -1345,6 +1357,7 @@
 				ast_rtp_instance_get_remote_address(instance1, &t1);
 				ast_sockaddr_copy(&ac1, &t1);
 				/* Update codec information */
+				ast_channel_lock(c0);
 				if (glue0->get_codec && ast_channel_tech_pvt(c0)) {
 					ast_format_cap_remove_all(cap0);
 					ast_format_cap_remove_all(oldcap0);
@@ -1352,12 +1365,15 @@
 					ast_format_cap_append(oldcap0, cap0);
 
 				}
+				ast_channel_unlock(c0);
+				ast_channel_lock(c1);
 				if (glue1->get_codec && ast_channel_tech_pvt(c1)) {
 					ast_format_cap_remove_all(cap1);
 					ast_format_cap_remove_all(oldcap1);
 					glue1->get_codec(c1, cap1);
 					ast_format_cap_append(oldcap1, cap1);
 				}
+				ast_channel_unlock(c1);
 				/* Since UPDATE_BRIDGE_PEER is only used by the bridging code, don't forward it */
 				if (fr->subclass.integer != AST_CONTROL_UPDATE_RTP_PEER) {
 					ast_indicate_data(other, fr->subclass.integer, fr->data.ptr, fr->datalen);
@@ -1383,7 +1399,7 @@
 				*rc = who;
 				ast_debug(1, "Got a FRAME_CONTROL (%d) frame on channel %s\n", fr->subclass.integer, ast_channel_name(who));
 				res = AST_BRIDGE_COMPLETE;
-				goto remote_bridge_cleanup;
+				break;
 			}
 		} else {
 			if ((fr->frametype == AST_FRAME_DTMF_BEGIN) ||
@@ -1849,7 +1865,7 @@
 	/* Now actually fill the buffer with the good information */
 	if (field == AST_RTP_INSTANCE_STAT_FIELD_QUALITY) {
 		snprintf(buf, size, "ssrc=%i;themssrc=%u;lp=%u;rxjitter=%f;rxcount=%u;txjitter=%f;txcount=%u;rlp=%u;rtt=%f",
-			 stats.local_ssrc, stats.remote_ssrc, stats.rxploss, stats.txjitter, stats.rxcount, stats.rxjitter, stats.txcount, stats.txploss, stats.rtt);
+			 stats.local_ssrc, stats.remote_ssrc, stats.rxploss, stats.rxjitter, stats.rxcount, stats.txjitter, stats.txcount, stats.txploss, stats.rtt);
 	} else if (field == AST_RTP_INSTANCE_STAT_FIELD_QUALITY_JITTER) {
 		snprintf(buf, size, "minrxjitter=%f;maxrxjitter=%f;avgrxjitter=%f;stdevrxjitter=%f;reported_minjitter=%f;reported_maxjitter=%f;reported_avgjitter=%f;reported_stdevjitter=%f;",
 			 stats.local_minjitter, stats.local_maxjitter, stats.local_normdevjitter, sqrt(stats.local_stdevjitter), stats.remote_minjitter, stats.remote_maxjitter, stats.remote_normdevjitter, sqrt(stats.remote_stdevjitter));
@@ -1925,11 +1941,15 @@
 	}
 
 	glue->get_rtp_info(peer, &peer_instance);
-
-	if (!peer_instance || peer_instance->engine != instance->engine) {
+	if (!peer_instance) {
+		ast_log(LOG_ERROR, "Unable to get_rtp_info for peer type %s\n", glue->type);
+		ast_channel_unlock(peer);
+		return -1;
+	}
+	if (peer_instance->engine != instance->engine) {
+		ast_log(LOG_ERROR, "Peer engine mismatch for type %s\n", glue->type);
 		ast_channel_unlock(peer);
 		ao2_ref(peer_instance, -1);
-		peer_instance = NULL;
 		return -1;
 	}
 
--- main/tcptls.c
+++ main/tcptls.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403917 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407273 $")
 
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
@@ -172,6 +172,8 @@
 	 */
 	if (ast_thread_inhibit_escalations()) {
 		ast_log(LOG_ERROR, "Failed to inhibit privilege escalations; killing connection\n");
+		ast_tcptls_close_session_file(tcptls_session);
+		ao2_ref(tcptls_session, -1);
 		return NULL;
 	}
 
@@ -391,7 +393,7 @@
 
 	if (!ast_strlen_zero(cfg->certfile)) {
 		char *tmpprivate = ast_strlen_zero(cfg->pvtfile) ? cfg->certfile : cfg->pvtfile;
-		if (SSL_CTX_use_certificate_file(cfg->ssl_ctx, cfg->certfile, SSL_FILETYPE_PEM) == 0) {
+		if (SSL_CTX_use_certificate_chain_file(cfg->ssl_ctx, cfg->certfile) == 0) {
 			if (!client) {
 				/* Clients don't need a certificate, but if its setup we can use it */
 				ast_verb(0, "SSL error loading cert file. <%s>\n", cfg->certfile);
--- main/udptl.c
+++ main/udptl.c
@@ -54,7 +54,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399442 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 406934 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -1009,7 +1009,7 @@
 		if (ast_bind(udptl->fd, &udptl->us) == 0) {
 			break;
 		}
-		if (errno != EADDRINUSE) {
+		if (errno != EADDRINUSE && errno != EACCES) {
 			ast_log(LOG_WARNING, "Unexpected bind error: %s\n", strerror(errno));
 			close(udptl->fd);
 			ast_free(udptl);
--- Makefile
+++ Makefile
@@ -363,12 +363,16 @@
 $(SUBDIRS): makeopts .lastclean main/version.c include/asterisk/build.h include/asterisk/buildopts.h defaults.h makeopts.embed_rules
 
 ifeq ($(findstring $(OSARCH), mingw32 cygwin ),)
+  ifeq ($(shell grep ^MENUSELECT_EMBED=$$ menuselect.makeopts 2>/dev/null),)
     # Non-windows:
     # ensure that all module subdirectories are processed before 'main' during
     # a parallel build, since if there are modules selected to be embedded the
     # directories containing them must be completed before the main Asterisk
-    # binary can be built
+    # binary can be built.
+    # If MENUSELECT_EMBED is empty, we don't need this and allow 'main' to be
+    # be built without building all dependencies first.
 main: $(filter-out main,$(MOD_SUBDIRS))
+  endif
 else
     # Windows: we need to build main (i.e. the asterisk dll) first,
     # followed by res, followed by the other directories, because
--- Makefile.rules
+++ Makefile.rules
@@ -35,7 +35,7 @@
     CMD_PREFIX=
 endif
 
-OPTIMIZE?=-O6
+OPTIMIZE?=-O3
 ifneq ($(findstring darwin,$(OSARCH)),)
   ifeq ($(shell if test `/usr/bin/sw_vers -productVersion | cut -c4` -gt 5; then echo 6; else echo 0; fi),6)
     # Snow Leopard/Lion has an issue with this optimization flag on large files (like chan_sip)
--- res/ael/pval.c
+++ res/ael/pval.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 408786 $")
 
 #include <sys/types.h>
 #include <stdlib.h>
@@ -60,7 +60,6 @@
 extern int localized_pbx_load_module(void);
 
 static char expr_output[2096];
-#define AST_PBX_MAX_STACK  128
 #define BUF_SIZE 2000
 
 /* these functions are in ../ast_expr2.fl */
--- res/res_clialiases.c
+++ res/res_clialiases.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377843 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407210 $")
 
 #include "asterisk/module.h"
 #include "asterisk/config.h"
@@ -68,15 +68,25 @@
 	return (alias0->cli_entry.command == alias1->cli_entry.command ? CMP_MATCH | CMP_STOP : 0);
 }
 
-/*! \brief Destruction function used for aliases */
-static void alias_destroy(void *obj)
+/*! \brief Callback for unregistering an alias */
+static int alias_unregister_cb(void *obj, void *arg, int flags)
 {
 	struct cli_alias *alias = obj;
 
 	/* Unregister the CLI entry from the core */
 	ast_cli_unregister(&alias->cli_entry);
 
-	return;
+	/* We can determine if this worked or not by looking at the cli_entry itself */
+	return !alias->cli_entry.command ? CMP_MATCH : 0;
+}
+
+/*! \brief Callback for finding an alias based on name */
+static int alias_name_cb(void *obj, void *arg, int flags)
+{
+	struct cli_alias *alias = obj;
+	char *name = arg;
+
+	return !strcmp(alias->alias, name) ? CMP_MATCH | CMP_STOP : 0;
 }
 
 /*! \brief Function which passes through an aliased CLI command to the real one */
@@ -188,7 +198,7 @@
 
 	/* Destroy any existing CLI aliases */
 	if (reload) {
-		ao2_callback(cli_aliases, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
+		ao2_callback(cli_aliases, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, alias_unregister_cb, NULL);
 	}
 
 	for (v = ast_variable_browse(cfg, "general"); v; v = v->next) {
@@ -198,7 +208,16 @@
 		}
 		/* Read in those there CLI aliases */
 		for (v1 = ast_variable_browse(cfg, v->value); v1; v1 = v1->next) {
-			if (!(alias = ao2_alloc((sizeof(*alias) + strlen(v1->name) + strlen(v1->value) + 2), alias_destroy))) {
+			struct cli_alias *existing = ao2_callback(cli_aliases, 0, alias_name_cb, (char*)v1->name);
+
+			if (existing) {
+				ast_log(LOG_WARNING, "Alias '%s' could not be unregistered and has been retained\n",
+					existing->alias);
+				ao2_ref(existing, -1);
+				continue;
+			}
+
+			if (!(alias = ao2_alloc((sizeof(*alias) + strlen(v1->name) + strlen(v1->value) + 2), NULL))) {
 				continue;
 			}
 			alias->alias = ((char *) alias) + sizeof(*alias);
@@ -234,6 +253,13 @@
 /*! \brief Function called to unload the module */
 static int unload_module(void)
 {
+	ao2_callback(cli_aliases, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, alias_unregister_cb, NULL);
+
+	if (ao2_container_count(cli_aliases)) {
+		ast_log(LOG_ERROR, "Could not unregister all CLI aliases\n");
+		return -1;
+	}
+
 	ao2_ref(cli_aliases, -1);
 
 	ast_cli_unregister_multiple(cli_alias, ARRAY_LEN(cli_alias));
--- res/res_config_pgsql.c
+++ res/res_config_pgsql.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387823 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 407874 $")
 
 #include <libpq-fe.h>			/* PostgreSQL */
 
@@ -252,8 +252,8 @@
 	struct columns *column;
 	struct tables *table;
 	struct ast_str *sql = ast_str_thread_get(&findtable_buf, 330);
-        PGresult *result;
-        int exec_result;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
+	int exec_result;
 	char *fname, *ftype, *flen, *fnotnull, *fdef;
 	int i, rows;
 
@@ -339,14 +339,12 @@
 	ast_debug(1, "Query of table structure complete.  Now retrieving results.\n");
 	if (exec_result != 0) {
 		ast_log(LOG_ERROR, "Failed to query database columns for table %s\n", orig_tablename);
-		PQclear(result);
 		AST_LIST_UNLOCK(&psql_tables);
 		return NULL;
 	}
 
 	if (!(table = ast_calloc(1, sizeof(*table) + strlen(orig_tablename) + 1))) {
 		ast_log(LOG_ERROR, "Unable to allocate memory for new table structure\n");
-		PQclear(result);
 		AST_LIST_UNLOCK(&psql_tables);
 		return NULL;
 	}
@@ -365,7 +363,6 @@
 
 		if (!(column = ast_calloc(1, sizeof(*column) + strlen(fname) + strlen(ftype) + 2))) {
 			ast_log(LOG_ERROR, "Unable to allocate column element for %s, %s\n", orig_tablename, fname);
-			PQclear(result);
 			destroy_table(table);
 			AST_LIST_UNLOCK(&psql_tables);
 			return NULL;
@@ -395,7 +392,6 @@
 		}
 		AST_LIST_INSERT_TAIL(&table->columns, column, list);
 	}
-	PQclear(result);
 
 	AST_LIST_INSERT_TAIL(&psql_tables, table, list);
 	ast_rwlock_rdlock(&table->lock);
@@ -420,7 +416,7 @@
 
 static struct ast_variable *realtime_pgsql(const char *database, const char *tablename, va_list ap)
 {
-	PGresult *result = NULL;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
 	int num_rows = 0, pgresult;
 	struct ast_str *sql = ast_str_thread_get(&sql_buf, 100);
 	struct ast_str *escapebuf = ast_str_thread_get(&escapebuf_buf, 100);
@@ -485,7 +481,6 @@
 	ast_mutex_lock(&pgsql_lock);
 
         if (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {
-		PQclear(result);
 		ast_mutex_unlock(&pgsql_lock);
 		return NULL;
         }
@@ -501,7 +496,6 @@
 		ast_debug(1, "PostgreSQL RealTime: Found %d rows.\n", num_rows);
 
 		if (!(fieldnames = ast_calloc(1, numFields * sizeof(char *)))) {
-			PQclear(result);
 			ast_mutex_unlock(&pgsql_lock);
 			return NULL;
 		}
@@ -530,7 +524,6 @@
 		ast_debug(1, "Postgresql RealTime: Could not find any rows in table %s@%s.\n", tablename, database);
 	}
 
-	PQclear(result);
 	ast_mutex_unlock(&pgsql_lock);
 
 	return var;
@@ -538,7 +531,7 @@
 
 static struct ast_config *realtime_multi_pgsql(const char *database, const char *table, va_list ap)
 {
-	PGresult *result = NULL;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
 	int num_rows = 0, pgresult;
 	struct ast_str *sql = ast_str_thread_get(&sql_buf, 100);
 	struct ast_str *escapebuf = ast_str_thread_get(&escapebuf_buf, 100);
@@ -639,7 +632,6 @@
 			ast_debug(1, "PostgreSQL RealTime: Query: %s\n", ast_str_buffer(sql));
 			ast_debug(1, "PostgreSQL RealTime: Query Failed because: %s (%s)\n",
 						PQresultErrorMessage(result), PQresStatus(result_status));
-			PQclear(result);
 			ast_mutex_unlock(&pgsql_lock);
 			ast_config_destroy(cfg);
 			return NULL;
@@ -657,7 +649,6 @@
 		ast_debug(1, "PostgreSQL RealTime: Found %d rows.\n", num_rows);
 
 		if (!(fieldnames = ast_calloc(1, numFields * sizeof(char *)))) {
-			PQclear(result);
 			ast_mutex_unlock(&pgsql_lock);
 			ast_config_destroy(cfg);
 			return NULL;
@@ -689,7 +680,6 @@
 		ast_debug(1, "PostgreSQL RealTime: Could not find any rows in table %s.\n", table);
 	}
 
-	PQclear(result);
 	ast_mutex_unlock(&pgsql_lock);
 
 	return cfg;
@@ -698,7 +688,7 @@
 static int update_pgsql(const char *database, const char *tablename, const char *keyfield,
 						const char *lookup, va_list ap)
 {
-	PGresult *result = NULL;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
 	int numrows = 0, pgresult;
 	const char *newparam, *newval;
 	struct ast_str *sql = ast_str_thread_get(&sql_buf, 100);
@@ -805,7 +795,6 @@
 			ast_debug(1, "PostgreSQL RealTime: Query: %s\n", ast_str_buffer(sql));
 			ast_debug(1, "PostgreSQL RealTime: Query Failed because: %s (%s)\n",
 						PQresultErrorMessage(result), PQresStatus(result_status));
-			PQclear(result);
 			ast_mutex_unlock(&pgsql_lock);
 			return -1;
 		}
@@ -830,7 +819,7 @@
 
 static int update2_pgsql(const char *database, const char *tablename, va_list ap)
 {
-	PGresult *result = NULL;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
 	int numrows = 0, pgresult, first = 1;
 	struct ast_str *escapebuf = ast_str_thread_get(&escapebuf_buf, 16);
 	const char *newparam, *newval;
@@ -859,8 +848,8 @@
 		return -1;
 	}
 
-	ast_str_set(&sql, 0, "UPDATE %s SET ", tablename);
-	ast_str_set(&where, 0, "WHERE");
+	ast_str_set(&sql, 0, "UPDATE %s SET", tablename);
+	ast_str_set(&where, 0, " WHERE");
 
 	while ((newparam = va_arg(ap, const char *))) {
 		if (!find_column(table, newparam)) {
@@ -874,7 +863,6 @@
 		if (pgresult) {
 			ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", newval);
 			release_table(table);
-			ast_free(sql);
 			return -1;
 		}
 		ast_str_append(&where, 0, "%s %s='%s'", first ? "" : " AND", newparam, ast_str_buffer(escapebuf));
@@ -907,15 +895,15 @@
 		if (pgresult) {
 			ast_log(LOG_ERROR, "PostgreSQL RealTime: detected invalid input: '%s'\n", newval);
 			release_table(table);
-			ast_free(sql);
 			return -1;
 		}
 
 		ast_str_append(&sql, 0, "%s %s='%s'", first ? "" : ",", newparam, ast_str_buffer(escapebuf));
+		first = 0;
 	}
 	release_table(table);
 
-	ast_str_append(&sql, 0, " %s", ast_str_buffer(where));
+	ast_str_append(&sql, 0, "%s", ast_str_buffer(where));
 
 	ast_debug(1, "PostgreSQL RealTime: Update SQL: %s\n", ast_str_buffer(sql));
 
@@ -945,7 +933,7 @@
 
 static int store_pgsql(const char *database, const char *table, va_list ap)
 {
-	PGresult *result = NULL;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
 	Oid insertid;
 	struct ast_str *buf = ast_str_thread_get(&escapebuf_buf, 256);
 	struct ast_str *sql1 = ast_str_thread_get(&sql_buf, 256);
@@ -1007,7 +995,6 @@
         }
 
 	insertid = PQoidValue(result);
-	PQclear(result);
 	ast_mutex_unlock(&pgsql_lock);
 
 	ast_debug(1, "PostgreSQL RealTime: row inserted on table: %s, id: %u\n", table, insertid);
@@ -1026,7 +1013,7 @@
 
 static int destroy_pgsql(const char *database, const char *table, const char *keyfield, const char *lookup, va_list ap)
 {
-	PGresult *result = NULL;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
 	int numrows = 0;
 	int pgresult;
 	struct ast_str *sql = ast_str_thread_get(&sql_buf, 256);
@@ -1108,7 +1095,7 @@
 									   const char *file, struct ast_config *cfg,
 									   struct ast_flags flags, const char *suggested_incl, const char *who_asked)
 {
-	PGresult *result = NULL;
+	RAII_VAR(PGresult *, result, NULL, PQclear);
 	long num_rows;
 	struct ast_variable *new_v;
 	struct ast_category *cur_cat = NULL;
@@ -1155,7 +1142,6 @@
 			char *field_cat_metric = PQgetvalue(result, rowIndex, 3);
 			if (!strcmp(field_var_name, "#include")) {
 				if (!ast_config_internal_load(field_var_val, cfg, flags, "", who_asked)) {
-					PQclear(result);
 					ast_mutex_unlock(&pgsql_lock);
 					return NULL;
 				}
@@ -1178,7 +1164,6 @@
 				"PostgreSQL RealTime: Could not find config '%s' in database.\n", file);
 	}
 
-	PQclear(result);
 	ast_mutex_unlock(&pgsql_lock);
 
 	return cfg;
@@ -1298,7 +1283,7 @@
 				ast_debug(1, "About to run ALTER query on table '%s' to add column '%s'\n", tablename, elm);
 
 			        if (pgsql_exec(database, tablename, ast_str_buffer(sql), &result) != 0) {
-					ast_mutex_unlock(&pgsql_lock);
+						ast_mutex_unlock(&pgsql_lock);
 				        return -1;
 			        }
 
--- res/res_fax.c
+++ res/res_fax.c
@@ -56,7 +56,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 404351 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409053 $")
 
 #include "asterisk/io.h"
 #include "asterisk/file.h"
@@ -323,7 +323,7 @@
 };
 static AST_RWLIST_HEAD_STATIC(faxmodules, fax_module);
 
-#define RES_FAX_MINRATE 2400
+#define RES_FAX_MINRATE 4800
 #define RES_FAX_MAXRATE 14400
 #define RES_FAX_STATUSEVENTS 0
 #define RES_FAX_MODEM (AST_FAX_MODEM_V17 | AST_FAX_MODEM_V27 | AST_FAX_MODEM_V29)
@@ -704,7 +704,7 @@
 {
 	switch (rate) {
 	case 2400:
-		if (!(modems & (AST_FAX_MODEM_V27 | AST_FAX_MODEM_V34))) {
+		if (!(modems & (AST_FAX_MODEM_V34))) {
 			return 1;
 		}
 		break;
@@ -714,11 +714,15 @@
 		}
 		break;
 	case 7200:
-	case 9600:
 		if (!(modems & (AST_FAX_MODEM_V17 | AST_FAX_MODEM_V29 | AST_FAX_MODEM_V34))) {
 			return 1;
 		}
 		break;
+	case 9600:
+		if (!(modems & (AST_FAX_MODEM_V17 | AST_FAX_MODEM_V27 | AST_FAX_MODEM_V29 | AST_FAX_MODEM_V34))) {
+			return 1;
+		}
+		break;
 	case 12000:
 	case 14400:
 		if (!(modems & (AST_FAX_MODEM_V17 | AST_FAX_MODEM_V34))) {
@@ -3879,6 +3883,13 @@
 		goto end;
 	}
 
+	if (options.minrate == 2400 && (options.modems & AST_FAX_MODEM_V27) && !(options.modems & (AST_FAX_MODEM_V34))) {
+		ast_fax_modem_to_str(options.modems, modems, sizeof(modems));
+		ast_log(LOG_WARNING, "'modems' setting '%s' is no longer accepted with 'minrate' setting %d\n", modems, options.minrate);
+		ast_log(LOG_WARNING, "'minrate' has been reset to 4800, please update res_fax.conf.\n");
+		options.minrate = 4800;
+	}
+
 	if (check_modem_rate(options.modems, options.minrate)) {
 		ast_fax_modem_to_str(options.modems, modems, sizeof(modems));
 		ast_log(LOG_ERROR, "'modems' setting '%s' is incompatible with 'minrate' setting %d\n", modems, options.minrate);
--- res/res_fax_spandsp.c
+++ res/res_fax_spandsp.c
@@ -50,7 +50,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 403450 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409990 $")
 
 #define SPANDSP_EXPOSE_INTERNAL_STRUCTURES
 #include <spandsp.h>
@@ -649,6 +649,8 @@
 
 static int spandsp_v21_detect(struct ast_fax_session *s, const struct ast_frame *f) {
 	struct spandsp_pvt *p = s->tech_pvt;
+	int16_t *slndata;
+	g711_state_t *decoder;
 
 	if (p->v21_detected) {
 		return 0;
@@ -659,10 +661,33 @@
 		return -1;
 	}
 
-	modem_connect_tones_rx(p->tone_state, f->data.ptr, f->samples);
+	ast_debug(5, "frame={ datalen=%d, samples=%d, mallocd=%d, src=%s, flags=%d, ts=%ld, len=%ld, seqno=%d, data.ptr=%p, subclass.format.id=%d  }\n", f->datalen, f->samples, f->mallocd, f->src, f->flags, f->ts, f->len, f->seqno, f->data.ptr, f->subclass.format.id);
+
+	/* slinear frame can be passed to spandsp */
+	if (f->subclass.format.id == AST_FORMAT_SLINEAR) {
+		modem_connect_tones_rx(p->tone_state, f->data.ptr, f->samples);
+
+	/* alaw/ulaw frame must be converted to slinear before passing to spandsp */
+	} else if (f->subclass.format.id == AST_FORMAT_ALAW || f->subclass.format.id == AST_FORMAT_ULAW) {
+		if (!(slndata = ast_malloc(sizeof(*slndata) * f->samples))) {
+			return -1;
+		}
+		decoder = g711_init(NULL, (f->subclass.format.id == AST_FORMAT_ALAW ? G711_ALAW : G711_ULAW));
+		g711_decode(decoder, slndata, f->data.ptr, f->samples);
+		ast_debug(5, "spandsp transcoding frame from %s to slinear for v21 detection\n", (f->subclass.format.id == AST_FORMAT_ALAW ? "G711_ALAW" : "G711_ULAW"));
+		modem_connect_tones_rx(p->tone_state, slndata, f->samples);
+		g711_release(decoder);
+		ast_free(slndata);
+
+	/* frame in other formats cannot be passed to spandsp, it could cause segfault */
+	} else {
+		ast_log(LOG_WARNING, "Unknown frame format %d, v.21 detection skipped\n", f->subclass.format.id);
+		return -1;
+	}
 
 	if (p->v21_detected) {
 		s->details->option.v21_detected = 1;
+		ast_debug(5, "v.21 detected\n");
 	}
 
 	return 0;
--- res/res_http_websocket.c
+++ res/res_http_websocket.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391560 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409703 $")
 
 #include "asterisk/module.h"
 #include "asterisk/http.h"
@@ -58,6 +58,16 @@
 /*! \brief Maximum reconstruction size for multi-frame payload reconstruction. */
 #define MAXIMUM_RECONSTRUCTION_CEILING 16384
 
+/*! \brief Maximum size of a websocket frame header
+ * 1 byte flags and opcode
+ * 1 byte mask flag + payload len
+ * 8 bytes max extended length
+ * 4 bytes optional masking key
+ * ... payload follows ...
+ * */
+#define MAX_WS_HDR_SZ 14
+#define MIN_WS_HDR_SZ 2
+
 /*! \brief Structure definition for session */
 struct ast_websocket {
 	FILE *f;                          /*!< Pointer to the file instance used for writing and reading */
@@ -230,6 +240,7 @@
 	if (fwrite(payload, 1, actual_length, session->f) != actual_length) {
 		return -1;
 	}
+	fflush(session->f);
 
 	return 0;
 }
@@ -286,111 +297,131 @@
 	return 0;
 }
 
+/* MAINTENANCE WARNING on ast_websocket_read()!
+ *
+ * We have to keep in mind during this function that the fact that session->fd seems ready
+ * (via poll) does not necessarily mean we have application data ready, because in the case
+ * of an SSL socket, there is some encryption data overhead that needs to be read from the
+ * TCP socket, so poll() may say there are bytes to be read, but whether it is just 1 byte
+ * or N bytes we do not know that, and we do not know how many of those bytes (if any) are
+ * for application data (for us) and not just for the SSL protocol consumption
+ *
+ * There used to be a couple of nasty bugs here that were fixed in last refactoring but I
+ * want to document them so the constraints are clear and we do not re-introduce them:
+ *
+ * - This function would incorrectly assume that fread() would necessarily return more than
+ *   1 byte of data, just because a websocket frame is always >= 2 bytes, but the thing
+ *   is we're dealing with a TCP bitstream here, we could read just one byte and that's normal.
+ *   The problem before was that if just one byte was read, the function bailed out and returned
+ *   an error, effectively dropping the first byte of a websocket frame header!
+ *
+ * - Another subtle bug was that it would just read up to MAX_WS_HDR_SZ (14 bytes) via fread()
+ *   then assume that executing poll() would tell you if there is more to read, but since
+ *   we're dealing with a buffered stream (session->f is a FILE*), poll would say there is
+ *   nothing else to read (in the real tcp socket session->fd) and we would get stuck here
+ *   without processing the rest of the data in session->f internal buffers until another packet
+ *   came on the network to unblock us!
+ *
+ * Note during the header parsing stage we try to read in small chunks just what we need, this
+ * is buffered data anyways, no expensive syscall required most of the time ...
+ */
+static inline int ws_safe_read(struct ast_websocket *session, char *buf, int len, enum ast_websocket_opcode *opcode)
+{
+	int sanity;
+	size_t rlen;
+	int xlen = len;
+	char *rbuf = buf;
+	for (sanity = 10; sanity; sanity--) {
+		clearerr(session->f);
+		rlen = fread(rbuf, 1, xlen, session->f);
+		if (0 == rlen && ferror(session->f) && errno != EAGAIN) {
+			ast_log(LOG_ERROR, "Error reading from web socket: %s\n", strerror(errno));
+			(*opcode) = AST_WEBSOCKET_OPCODE_CLOSE;
+			session->closing = 1;
+			return -1;
+		}
+		xlen = (xlen - rlen);
+		rbuf = rbuf + rlen;
+		if (0 == xlen) {
+			break;
+		}
+		if (ast_wait_for_input(session->fd, 1000) < 0) {
+			ast_log(LOG_ERROR, "ast_wait_for_input returned err: %s\n", strerror(errno));
+			(*opcode) = AST_WEBSOCKET_OPCODE_CLOSE;
+			session->closing = 1;
+			return -1;
+		}
+	}
+	if (!sanity) {
+		ast_log(LOG_WARNING, "Websocket seems unresponsive, disconnecting ...\n");
+		(*opcode) = AST_WEBSOCKET_OPCODE_CLOSE;
+		session->closing = 1;
+		return -1;
+	}
+	return 0;
+}
+
 int AST_OPTIONAL_API_NAME(ast_websocket_read)(struct ast_websocket *session, char **payload, uint64_t *payload_len, enum ast_websocket_opcode *opcode, int *fragmented)
 {
 	char buf[MAXIMUM_FRAME_SIZE] = "";
-	size_t frame_size, expected = 2;
+	int fin = 0;
+	int mask_present = 0;
+	char *mask = NULL, *new_payload = NULL;
+	size_t options_len = 0, frame_size = 0;
 
 	*payload = NULL;
 	*payload_len = 0;
 	*fragmented = 0;
 
-	/* We try to read in 14 bytes, which is the largest possible WebSocket header */
-	if ((frame_size = fread(&buf, 1, 14, session->f)) < 1) {
-		return -1;
-	}
-
-	/* The minimum size for a WebSocket frame is 2 bytes */
-	if (frame_size < expected) {
-		return -1;
+	if (ws_safe_read(session, &buf[0], MIN_WS_HDR_SZ, opcode)) {
+		return 0;
 	}
+	frame_size += MIN_WS_HDR_SZ;
 
+	/* ok, now we have the first 2 bytes, so we know some flags, opcode and payload length (or whether payload length extension will be required) */
 	*opcode = buf[0] & 0xf;
-
+	*payload_len = buf[1] & 0x7f;
 	if (*opcode == AST_WEBSOCKET_OPCODE_TEXT || *opcode == AST_WEBSOCKET_OPCODE_BINARY || *opcode == AST_WEBSOCKET_OPCODE_CONTINUATION ||
 	    *opcode == AST_WEBSOCKET_OPCODE_PING || *opcode == AST_WEBSOCKET_OPCODE_PONG) {
-		int fin = (buf[0] >> 7) & 1;
-		int mask_present = (buf[1] >> 7) & 1;
-		char *mask = NULL, *new_payload;
-		size_t remaining;
-
-		if (mask_present) {
-			/* The mask should take up 4 bytes */
-			expected += 4;
+		fin = (buf[0] >> 7) & 1;
+		mask_present = (buf[1] >> 7) & 1;
 
-			if (frame_size < expected) {
-				/* Per the RFC 1009 means we received a message that was too large for us to process */
-				ast_websocket_close(session, 1009);
+		/* Based on the mask flag and payload length, determine how much more we need to read before start parsing the rest of the header */
+		options_len += mask_present ? 4 : 0;
+		options_len += (*payload_len == 126) ? 2 : (*payload_len == 127) ? 8 : 0;
+		if (options_len) {
+			/* read the rest of the header options */
+			if (ws_safe_read(session, &buf[frame_size], options_len, opcode)) {
 				return 0;
 			}
+			frame_size += options_len;
 		}
 
-		/* Assume no extended length and no masking at the beginning */
-		*payload_len = buf[1] & 0x7f;
-		*payload = &buf[2];
-
-		/* Determine if extended length is being used */
 		if (*payload_len == 126) {
-			/* Use the next 2 bytes to get a uint16_t */
-			expected += 2;
-			*payload += 2;
-
-			if (frame_size < expected) {
-				ast_websocket_close(session, 1009);
-				return 0;
-			}
-
+			/* Grab the 2-byte payload length  */
 			*payload_len = ntohs(get_unaligned_uint16(&buf[2]));
+			mask = &buf[4];
 		} else if (*payload_len == 127) {
-			/* Use the next 8 bytes to get a uint64_t */
-			expected += 8;
-			*payload += 8;
-
-			if (frame_size < expected) {
-				ast_websocket_close(session, 1009);
-				return 0;
-			}
-
+			/* Grab the 8-byte payload length  */
 			*payload_len = ntohl(get_unaligned_uint64(&buf[2]));
+			mask = &buf[10];
+		} else {
+			/* Just set the mask after the small 2-byte header */
+			mask = &buf[2];
 		}
 
-		/* If masking is present the payload currently points to the mask, so move it over 4 bytes to the actual payload */
-		if (mask_present) {
-			mask = *payload;
-			*payload += 4;
-		}
-
-		/* Determine how much payload we need to read in as we may have already read some in */
-		remaining = *payload_len - (frame_size - expected);
-
-		/* If how much payload they want us to read in exceeds what we are capable of close the session, things
-		 * will fail no matter what most likely */
-		if (remaining > (MAXIMUM_FRAME_SIZE - frame_size)) {
+		/* Now read the rest of the payload */
+		*payload = &buf[frame_size]; /* payload will start here, at the end of the options, if any */
+		frame_size = frame_size + (*payload_len); /* final frame size is header + optional headers + payload data */
+		if (frame_size > MAXIMUM_FRAME_SIZE) {
+			ast_log(LOG_WARNING, "Cannot fit huge websocket frame of %zd bytes\n", frame_size);
+			/* The frame won't fit :-( */
 			ast_websocket_close(session, 1009);
-			return 0;
+			return -1;
 		}
 
-		new_payload = *payload + (frame_size - expected);
-
-		/* Read in the remaining payload */
-		while (remaining > 0) {
-			size_t payload_read;
-
-			/* Wait for data to come in */
-			if (ast_wait_for_input(session->fd, -1) <= 0) {
-				*opcode = AST_WEBSOCKET_OPCODE_CLOSE;
-				*payload = NULL;
-				session->closing = 1;
-				return 0;
-			}
-
-			/* If some sort of failure occurs notify the caller */
-			if ((payload_read = fread(new_payload, 1, remaining, session->f)) < 1) {
-				return -1;
-			}
-
-			remaining -= payload_read;
-			new_payload += payload_read;
+		if (ws_safe_read(session, (*payload), (*payload_len), opcode)) {
+			return 0;
 		}
 
 		/* If a mask is present unmask the payload */
@@ -401,7 +432,9 @@
 			}
 		}
 
-		if (!(new_payload = ast_realloc(session->payload, session->payload_len + *payload_len))) {
+		if (!(new_payload = ast_realloc(session->payload, (session->payload_len + *payload_len)))) {
+			ast_log(LOG_WARNING, "Failed allocation: %p, %zd, %"PRIu64"\n",
+				session->payload, session->payload_len, *payload_len);
 			*payload_len = 0;
 			ast_websocket_close(session, 1009);
 			return 0;
@@ -413,7 +446,7 @@
 		}
 
 		session->payload = new_payload;
-		memcpy(session->payload + session->payload_len, *payload, *payload_len);
+		memcpy((session->payload + session->payload_len), (*payload), (*payload_len));
 		session->payload_len += *payload_len;
 
 		if (!fin && session->reconstruct && (session->payload_len < session->reconstruct)) {
@@ -439,15 +472,15 @@
 			session->payload_len = 0;
 		}
 	} else if (*opcode == AST_WEBSOCKET_OPCODE_CLOSE) {
-		char *new_payload;
-
-		*payload_len = buf[1] & 0x7f;
-
 		/* Make the payload available so the user can look at the reason code if they so desire */
 		if ((*payload_len) && (new_payload = ast_realloc(session->payload, *payload_len))) {
+			if (ws_safe_read(session, &buf[frame_size], (*payload_len), opcode)) {
+				return 0;
+			}
 			session->payload = new_payload;
-			memcpy(session->payload, &buf[2], *payload_len);
+			memcpy(session->payload, &buf[frame_size], *payload_len);
 			*payload = session->payload;
+			frame_size += (*payload_len);
 		}
 
 		if (!session->closing) {
@@ -458,6 +491,7 @@
 		session->f = NULL;
 		ast_verb(2, "WebSocket connection from '%s' closed\n", ast_sockaddr_stringify(&session->address));
 	} else {
+		ast_log(LOG_WARNING, "WebSocket unknown opcode %d\n", *opcode);
 		/* We received an opcode that we don't understand, the RFC states that 1003 is for a type of data that can't be accepted... opcodes
 		 * fit that, I think. */
 		ast_websocket_close(session, 1003);
@@ -578,6 +612,7 @@
 			upgrade,
 			base64,
 			protocol);
+		fflush(ser->f);
 	} else {
 
 		/* Specification defined in http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75 or completely unknown */
@@ -634,6 +669,8 @@
 {
 	int flags, res;
 
+	ast_debug(1, "Entering WebSocket echo loop\n");
+
 	if ((flags = fcntl(ast_websocket_fd(session), F_GETFL)) == -1) {
 		goto end;
 	}
@@ -652,6 +689,7 @@
 
 		if (ast_websocket_read(session, &payload, &payload_len, &opcode, &fragmented)) {
 			/* We err on the side of caution and terminate the session if any error occurs */
+			ast_log(LOG_WARNING, "Read failure during WebSocket echo loop\n");
 			break;
 		}
 
@@ -659,10 +697,13 @@
 			ast_websocket_write(session, opcode, payload, payload_len);
 		} else if (opcode == AST_WEBSOCKET_OPCODE_CLOSE) {
 			break;
+		} else {
+			ast_debug(1, "Ignored WebSocket opcode %d\n", opcode);
 		}
 	}
 
 end:
+	ast_debug(1, "Exitting WebSocket echo loop\n");
 	ast_websocket_unref(session);
 }
 
--- res/res_musiconhold.c
+++ res/res_musiconhold.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 410044 $")
 
 #include <ctype.h>
 #include <signal.h>
@@ -1471,12 +1471,6 @@
 				if (state && state->class) {
 					/* Class already exist for this channel */
 					ast_log(LOG_NOTICE, "This channel already has a MOH class attached (%s)!\n", state->class->name);
-					if (state->class->realtime && !ast_test_flag(global_flags, MOH_CACHERTCLASSES) && !strcasecmp(mohclass->name, state->class->name)) {
-						/* we found RT class with the same name, seems like we should continue playing existing one */
-						/* XXX This code is impossible to reach */
-						mohclass = mohclass_unref(mohclass, "unreffing potential mohclass (channel already has a class)");
-						mohclass = state->class;
-					}
 				}
 				/* We don't want moh_register to unref the mohclass because we do it at the end of this function as well.
 				 * If we allowed moh_register to unref the mohclass,too, then the count would be off by one. The result would
@@ -1529,7 +1523,7 @@
 						if (state->class->realtime && !ast_test_flag(global_flags, MOH_CACHERTCLASSES) && !strcasecmp(mohclass->name, state->class->name)) {
 							/* we found RT class with the same name, seems like we should continue playing existing one */
 							mohclass = mohclass_unref(mohclass, "unreffing potential mohclass (channel already has one)");
-							mohclass = state->class;
+							mohclass = mohclass_ref(state->class, "using existing class from state");
 						}
 					} else {
 						if (ast_pthread_create_background(&mohclass->thread, NULL, monmp3thread, mohclass)) {
--- res/res_pktccops.c
+++ res/res_pktccops.c
@@ -37,7 +37,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 350791 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 406038 $")
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -1347,7 +1347,7 @@
 	if (a->argc < 9)
 		return CLI_SHOWUSAGE;
 
-	if (!strncmp(a->argv[2], "null", sizeof(a->argv[2]))) {
+	if (!strcmp(a->argv[2], "null")) {
 		cmts = NULL;
 	} else {
 		AST_LIST_LOCK(&cmts_list);
--- res/res_rtp_asterisk.c
+++ res/res_rtp_asterisk.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409150 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409565 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -70,6 +70,7 @@
 #include "asterisk/unaligned.h"
 #include "asterisk/module.h"
 #include "asterisk/rtp_engine.h"
+#include "asterisk/test.h"
 
 #define MAX_TIMESTAMP_SKEW	640
 
@@ -266,7 +267,7 @@
 	pj_turn_state_t turn_state; /*!< Current state of the TURN relay session */
 	ast_cond_t cond;            /*!< Condition for signaling */
 	unsigned int passthrough:1; /*!< Bit to indicate that the received packet should be passed through */
-	unsigned int ice_started:1; /*!< Bit to indicate ICE connectivity checks have started */
+	unsigned int ice_port;      /*!< Port that ICE was started with if it was previously started */
 
 	char remote_ufrag[256];  /*!< The remote ICE username */
 	char remote_passwd[256]; /*!< The remote ICE password */
@@ -274,8 +275,10 @@
 	char local_ufrag[256];  /*!< The local ICE username */
 	char local_passwd[256]; /*!< The local ICE password */
 
-	struct ao2_container *local_candidates;   /*!< The local ICE candidates */
-	struct ao2_container *remote_candidates;  /*!< The remote ICE candidates */
+	struct ao2_container *ice_local_candidates;           /*!< The local ICE candidates */
+	struct ao2_container *ice_active_remote_candidates;   /*!< The remote ICE candidates */
+	struct ao2_container *ice_proposed_remote_candidates; /*!< Incoming remote ICE candidates for new session */
+	struct ast_sockaddr ice_original_rtp_addr;            /*!< rtp address that ICE started on first session */
 #endif
 
 #ifdef HAVE_OPENSSL_SRTP
@@ -432,17 +435,32 @@
 	}
 }
 
+static int ice_candidate_cmp(void *obj, void *arg, int flags)
+{
+	struct ast_rtp_engine_ice_candidate *candidate1 = obj, *candidate2 = arg;
+
+	if (strcmp(candidate1->foundation, candidate2->foundation) ||
+			candidate1->id != candidate2->id ||
+			ast_sockaddr_cmp(&candidate1->address, &candidate2->address) ||
+			candidate1->type != candidate1->type) {
+		return 0;
+	}
+
+	return CMP_MATCH | CMP_STOP;
+}
+
 static void ast_rtp_ice_add_remote_candidate(struct ast_rtp_instance *instance, const struct ast_rtp_engine_ice_candidate *candidate)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 	struct ast_rtp_engine_ice_candidate *remote_candidate;
 
-	if (!rtp->remote_candidates && !(rtp->remote_candidates = ao2_container_alloc(1, NULL, NULL))) {
+	if (!rtp->ice_proposed_remote_candidates &&
+			!(rtp->ice_proposed_remote_candidates = ao2_container_alloc(1, NULL, ice_candidate_cmp))) {
 		return;
 	}
 
 	/* If this is going to exceed the maximum number of ICE candidates don't even add it */
-	if (ao2_container_count(rtp->remote_candidates) == PJ_ICE_MAX_CAND) {
+	if (ao2_container_count(rtp->ice_proposed_remote_candidates) == PJ_ICE_MAX_CAND) {
 		return;
 	}
 
@@ -458,7 +476,7 @@
 	ast_sockaddr_copy(&remote_candidate->relay_address, &candidate->relay_address);
 	remote_candidate->type = candidate->type;
 
-	ao2_link(rtp->remote_candidates, remote_candidate);
+	ao2_link(rtp->ice_proposed_remote_candidates, remote_candidate);
 	ao2_ref(remote_candidate, -1);
 }
 
@@ -500,6 +518,58 @@
 	ast_sockaddr_set_port(cand_address, pj_sockaddr_get_port(&rtp->ice->comp[component - 1].valid_check->rcand->addr));
 }
 
+static int ice_create(struct ast_rtp_instance *instance, struct ast_sockaddr *addr,
+	int port, int replace);
+
+static void ast_rtp_ice_stop(struct ast_rtp_instance *instance)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+
+	if (!rtp->ice) {
+		return;
+	}
+
+	pj_thread_register_check();
+
+	pj_ice_sess_destroy(rtp->ice);
+	rtp->ice = NULL;
+}
+
+static int ice_reset_session(struct ast_rtp_instance *instance)
+{
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+
+	ast_rtp_ice_stop(instance);
+	return ice_create(instance, &rtp->ice_original_rtp_addr, rtp->ice_port, 1);
+}
+
+static int ice_candidates_compare(struct ao2_container *left, struct ao2_container *right)
+{
+	struct ao2_iterator i;
+	struct ast_rtp_engine_ice_candidate *right_candidate;
+
+	if (ao2_container_count(left) != ao2_container_count(right)) {
+		return -1;
+	}
+
+	i = ao2_iterator_init(right, 0);
+	while ((right_candidate = ao2_iterator_next(&i))) {
+		struct ast_rtp_engine_ice_candidate *left_candidate = ao2_find(left, right_candidate, OBJ_POINTER);
+
+		if (!left_candidate) {
+			ao2_ref(right_candidate, -1);
+			ao2_iterator_destroy(&i);
+			return -1;
+		}
+
+		ao2_ref(left_candidate, -1);
+		ao2_ref(right_candidate, -1);
+	}
+	ao2_iterator_destroy(&i);
+
+	return 0;
+}
+
 static void ast_rtp_ice_start(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -509,13 +579,32 @@
 	struct ast_rtp_engine_ice_candidate *candidate;
 	int cand_cnt = 0;
 
-	if (!rtp->ice || !rtp->remote_candidates || rtp->ice_started) {
+	if (!rtp->ice || !rtp->ice_proposed_remote_candidates) {
+		return;
+	}
+
+	/* Check for equivalence in the lists */
+	if (rtp->ice_active_remote_candidates &&
+			!ice_candidates_compare(rtp->ice_proposed_remote_candidates, rtp->ice_active_remote_candidates)) {
+		ao2_cleanup(rtp->ice_proposed_remote_candidates);
+		rtp->ice_proposed_remote_candidates = NULL;
+		return;
+	}
+
+	/* Out with the old, in with the new */
+	ao2_cleanup(rtp->ice_active_remote_candidates);
+	rtp->ice_active_remote_candidates = rtp->ice_proposed_remote_candidates;
+	rtp->ice_proposed_remote_candidates = NULL;
+
+	/* Reset the ICE session. Is this going to work? */
+	if (ice_reset_session(instance)) {
+		ast_log(LOG_NOTICE, "Failed to create replacement ICE session\n");
 		return;
 	}
 
 	pj_thread_register_check();
 
-	i = ao2_iterator_init(rtp->remote_candidates, 0);
+	i = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);
 
 	while ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {
 		pj_str_t address;
@@ -545,42 +634,31 @@
 		}
 
 		cand_cnt++;
+		ao2_ref(candidate, -1);
 	}
 
 	ao2_iterator_destroy(&i);
 
-	if (pj_ice_sess_create_check_list(rtp->ice, &ufrag, &passwd, ao2_container_count(rtp->remote_candidates), &candidates[0]) == PJ_SUCCESS) {
+	if (pj_ice_sess_create_check_list(rtp->ice, &ufrag, &passwd, ao2_container_count(rtp->ice_active_remote_candidates), &candidates[0]) == PJ_SUCCESS) {
+		ast_test_suite_event_notify("ICECHECKLISTCREATE", "Result: SUCCESS");
 		pj_ice_sess_start_check(rtp->ice);
 		pj_timer_heap_poll(timerheap, NULL);
-		rtp->ice_started = 1;
 		rtp->strict_rtp_state = STRICT_RTP_OPEN;
 		return;
 	}
 
+	ast_test_suite_event_notify("ICECHECKLISTCREATE", "Result: FAILURE");
+
 	/* even though create check list failed don't stop ice as
 	   it might still work */
 	ast_debug(1, "Failed to create ICE session check list\n");
 	/* however we do need to reset remote candidates since
 	   this function may be re-entered */
-	ao2_ref(rtp->remote_candidates, -1);
-	rtp->remote_candidates = NULL;
+	ao2_ref(rtp->ice_active_remote_candidates, -1);
+	rtp->ice_active_remote_candidates = NULL;
 	rtp->ice->rcand_cnt = rtp->ice->clist.count = 0;
 }
 
-static void ast_rtp_ice_stop(struct ast_rtp_instance *instance)
-{
-	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
-
-	if (!rtp->ice) {
-		return;
-	}
-
-	pj_thread_register_check();
-
-	pj_ice_sess_destroy(rtp->ice);
-	rtp->ice = NULL;
-}
-
 static const char *ast_rtp_ice_get_ufrag(struct ast_rtp_instance *instance)
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
@@ -599,11 +677,11 @@
 {
 	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
 
-	if (rtp->local_candidates) {
-		ao2_ref(rtp->local_candidates, +1);
+	if (rtp->ice_local_candidates) {
+		ao2_ref(rtp->ice_local_candidates, +1);
 	}
 
-	return rtp->local_candidates;
+	return rtp->ice_local_candidates;
 }
 
 static void ast_rtp_ice_lite(struct ast_rtp_instance *instance)
@@ -619,20 +697,6 @@
 	pj_ice_sess_change_role(rtp->ice, PJ_ICE_SESS_ROLE_CONTROLLING);
 }
 
-static int ice_candidate_cmp(void *obj, void *arg, int flags)
-{
-	struct ast_rtp_engine_ice_candidate *candidate1 = obj, *candidate2 = arg;
-
-	if ((strcmp(candidate1->foundation, candidate2->foundation)) ||
-	    (candidate1->id != candidate2->id) ||
-	    (ast_sockaddr_cmp(&candidate1->address, &candidate2->address)) ||
-	    (candidate1->type != candidate1->type)) {
-		return 0;
-	}
-
-	return CMP_MATCH | CMP_STOP;
-}
-
 static void ast_rtp_ice_add_cand(struct ast_rtp *rtp, unsigned comp_id, unsigned transport_id, pj_ice_cand_type type, pj_uint16_t local_pref,
 					const pj_sockaddr_t *addr, const pj_sockaddr_t *base_addr, const pj_sockaddr_t *rel_addr, int addr_len)
 {
@@ -644,7 +708,7 @@
 
 	pj_ice_calc_foundation(rtp->ice->pool, &foundation, type, addr);
 
-	if (!rtp->local_candidates && !(rtp->local_candidates = ao2_container_alloc(1, NULL, ice_candidate_cmp))) {
+	if (!rtp->ice_local_candidates && !(rtp->ice_local_candidates = ao2_container_alloc(1, NULL, ice_candidate_cmp))) {
 		return;
 	}
 
@@ -672,7 +736,7 @@
 		candidate->type = AST_RTP_ICE_CANDIDATE_TYPE_RELAYED;
 	}
 
-	if ((existing = ao2_find(rtp->local_candidates, candidate, OBJ_POINTER))) {
+	if ((existing = ao2_find(rtp->ice_local_candidates, candidate, OBJ_POINTER))) {
 		ao2_ref(existing, -1);
 		ao2_ref(candidate, -1);
 		return;
@@ -686,7 +750,7 @@
 	/* By placing the candidate into the ICE session it will have produced the priority, so update the local candidate with it */
 	candidate->priority = rtp->ice->lcand[rtp->ice->lcand_cnt - 1].prio;
 
-	ao2_link(rtp->local_candidates, candidate);
+	ao2_link(rtp->ice_local_candidates, candidate);
 	ao2_ref(candidate, -1);
 }
 
@@ -1766,16 +1830,68 @@
 	return (unsigned int) ms;
 }
 
+#ifdef USE_PJPROJECT
+/*!
+ * \internal
+ * \brief Creates an ICE session. Can be used to replace a destroyed ICE session.
+ *
+ * \param instance RTP instance for which the ICE session is being replaced
+ * \param addr ast_sockaddr to use for adding RTP candidates to the ICE session
+ * \param port port to use for adding RTP candidates to the ICE session
+ * \param replace 0 when creating a new session, 1 when replacing a destroyed session
+ *
+ * \retval 0 on success
+ * \retval -1 on failure
+ */
+static int ice_create(struct ast_rtp_instance *instance, struct ast_sockaddr *addr,
+	int port, int replace)
+{
+	pj_stun_config stun_config;
+	pj_str_t ufrag, passwd;
+	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
+
+	ao2_cleanup(rtp->ice_local_candidates);
+	rtp->ice_local_candidates = NULL;
+
+	pj_thread_register_check();
+
+	pj_stun_config_init(&stun_config, &cachingpool.factory, 0, ioqueue, timerheap);
+
+	ufrag = pj_str(rtp->local_ufrag);
+	passwd = pj_str(rtp->local_passwd);
+
+	/* Create an ICE session for ICE negotiation */
+	if (pj_ice_sess_create(&stun_config, NULL, PJ_ICE_SESS_ROLE_UNKNOWN, 2,
+			&ast_rtp_ice_sess_cb, &ufrag, &passwd, &rtp->ice) == PJ_SUCCESS) {
+		/* Make this available for the callbacks */
+		rtp->ice->user_data = rtp;
+
+		/* Add all of the available candidates to the ICE session */
+		rtp_add_candidates_to_ice(instance, rtp, addr, port, AST_RTP_ICE_COMPONENT_RTP,
+			TRANSPORT_SOCKET_RTP, &ast_rtp_turn_rtp_sock_cb, &rtp->turn_rtp);
+
+		/* Only add the RTCP candidates to ICE when replacing the session. New sessions
+		 * handle this in a separate part of the setup phase */
+		if (replace && rtp->rtcp) {
+			rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us,
+				ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP,
+				TRANSPORT_SOCKET_RTCP, &ast_rtp_turn_rtcp_sock_cb, &rtp->turn_rtcp);
+		}
+
+		return 0;
+	}
+
+	return -1;
+
+}
+#endif
+
 static int ast_rtp_new(struct ast_rtp_instance *instance,
 		       struct ast_sched_context *sched, struct ast_sockaddr *addr,
 		       void *data)
 {
 	struct ast_rtp *rtp = NULL;
 	int x, startplace;
-#ifdef USE_PJPROJECT
-	pj_stun_config stun_config;
-	pj_str_t ufrag, passwd;
-#endif
 
 	/* Create a new RTP structure to hold all of our data */
 	if (!(rtp = ast_calloc(1, sizeof(*rtp)))) {
@@ -1827,7 +1943,7 @@
 		}
 
 		/* See if we ran out of ports or if the bind actually failed because of something other than the address being in use */
-		if (x == startplace || errno != EADDRINUSE) {
+		if (x == startplace || (errno != EADDRINUSE && errno != EACCES)) {
 			ast_log(LOG_ERROR, "Oh dear... we couldn't allocate a port for RTP instance '%p'\n", instance);
 			close(rtp->s);
 			ast_free(rtp);
@@ -1838,22 +1954,17 @@
 	ast_rtp_instance_set_data(instance, rtp);
 
 #ifdef USE_PJPROJECT
-	pj_thread_register_check();
-
-	pj_stun_config_init(&stun_config, &cachingpool.factory, 0, ioqueue, timerheap);
-
 	generate_random_string(rtp->local_ufrag, sizeof(rtp->local_ufrag));
-	ufrag = pj_str(rtp->local_ufrag);
 	generate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));
-	passwd = pj_str(rtp->local_passwd);
 
 	/* Create an ICE session for ICE negotiation */
-	if (icesupport && pj_ice_sess_create(&stun_config, NULL, PJ_ICE_SESS_ROLE_UNKNOWN, 2, &ast_rtp_ice_sess_cb, &ufrag, &passwd, &rtp->ice) == PJ_SUCCESS) {
-		/* Make this available for the callbacks */
-		rtp->ice->user_data = rtp;
-
-		/* Add all of the available candidates to the ICE session */
-		rtp_add_candidates_to_ice(instance, rtp, addr, x, AST_RTP_ICE_COMPONENT_RTP, TRANSPORT_SOCKET_RTP, &ast_rtp_turn_rtp_sock_cb, &rtp->turn_rtp);
+	if (icesupport) {
+		if (ice_create(instance, addr, x, 0)) {
+			ast_log(LOG_NOTICE, "Failed to start ICE session\n");
+		} else {
+			rtp->ice_port = x;
+			ast_sockaddr_copy(&rtp->ice_original_rtp_addr, addr);
+		}
 	}
 #endif
 
@@ -1919,12 +2030,12 @@
 	}
 
 	/* Destroy any candidates */
-	if (rtp->local_candidates) {
-		ao2_ref(rtp->local_candidates, -1);
+	if (rtp->ice_local_candidates) {
+		ao2_ref(rtp->ice_local_candidates, -1);
 	}
 
-	if (rtp->remote_candidates) {
-		ao2_ref(rtp->remote_candidates, -1);
+	if (rtp->ice_active_remote_candidates) {
+		ao2_ref(rtp->ice_active_remote_candidates, -1);
 	}
 
 	/* Destroy synchronization items */
--- utils/astman.c
+++ utils/astman.c
@@ -27,7 +27,7 @@
  ***/
 
 #include "asterisk.h"
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 359118 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 409083 $")
 #include "asterisk.h"
 
 #include <newt.h>
@@ -737,7 +737,6 @@
 					show_message("Login Failed", get_header(m, "Message"));
 				}
 			} else {
-				memset(m, 0, sizeof(m));
 				manager_action("Login", 
 					"Username: %s\r\n"
 					"Secret: %s\r\n",
--- utils/conf2ael.c
+++ utils/conf2ael.c
@@ -28,7 +28,7 @@
  ***/
 
 #include "asterisk.h"
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398749 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 408786 $")
 
 #include "asterisk/paths.h"	/* CONFIG_DIR */
 #include <locale.h>
@@ -75,8 +75,6 @@
 static int clearglobalvars_config = 0;
 char ast_config_AST_SYSTEM_NAME[20] = ""; */
 
-/*! Go no deeper than this through includes (not counting loops) */
-#define AST_PBX_MAX_STACK	128
 /* static AST_RWLIST_HEAD_STATIC(acf_root, ast_custom_function); */
 //extern char ast_config_AST_CONFIG_DIR[PATH_MAX];
 int option_debug = 0;
--- utils/extconf.c
+++ utils/extconf.c
@@ -80,6 +80,7 @@
 #include "asterisk/inline_api.h"
 #include "asterisk/endian.h"
 #include "asterisk/ast_expr.h"
+#include "asterisk/extconf.h"
 
 /* logger.h */
 
@@ -2677,8 +2678,6 @@
 static int write_protect_config = 1;
 static int autofallthrough_config = 0;
 static int clearglobalvars_config = 0;
-/*! Go no deeper than this through includes (not counting loops) */
-#define AST_PBX_MAX_STACK	128
 static void pbx_substitute_variables_helper(struct ast_channel *c,const char *cp1,char *cp2,int count);
 
 
@@ -4219,20 +4218,6 @@
 #else
 #define EXT_DATA_SIZE 8192
 #endif
-/*!
- * When looking up extensions, we can have different requests
- * identified by the 'action' argument, as follows.
- * Note that the coding is such that the low 4 bits are the
- * third argument to extension_match_core.
- */
-enum ext_match_t {
-	E_MATCHMORE = 	0x00,	/* extension can match but only with more 'digits' */
-	E_CANMATCH =	0x01,	/* extension can match with or without more 'digits' */
-	E_MATCH =	0x02,	/* extension is an exact match */
-	E_MATCH_MASK =	0x03,	/* mask for the argument to extension_match_core() */
-	E_SPAWN =	0x12,	/* want to spawn an extension. Requires exact match */
-	E_FINDLABEL =	0x22	/* returns the priority for a given label. Requires exact match */
-};
 
 #ifdef NOT_ANYMORE
 static AST_RWLIST_HEAD_STATIC(switches, ast_switch);
@@ -4439,6 +4424,8 @@
 	char *info;
 	int j, num_fields, last_sep = -1;
 
+	i->timezone = NULL;
+
 	/* Check for empty just in case */
 	if (ast_strlen_zero(info_in)) {
 		return 0;
@@ -4458,8 +4445,6 @@
 	/* save the timezone, if it is specified */
 	if (num_fields == 5) {
 		i->timezone = ast_strdup(info + last_sep + 1);
-	} else {
-		i->timezone = NULL;
 	}
 
 	/* Assume everything except time */
@@ -4759,22 +4744,6 @@
 	return tmp;
 }
 
-/* request and result for pbx_find_extension */
-struct pbx_find_info {
-#if 0
-	const char *context;
-	const char *exten;
-	int priority;
-#endif
-
-	char *incstack[AST_PBX_MAX_STACK];      /* filled during the search */
-	int stacklen;                   /* modified during the search */
-	int status;                     /* set on return */
-	struct ast_switch *swo;         /* set on return */
-	const char *data;               /* set on return */
-	const char *foundcontext;       /* set on return */
-};
-
 /*
  * Internal function for ast_extension_{match|close}
  * return 0 on no-match, 1 on match, 2 on early match.
@@ -6205,9 +6174,7 @@
 	return;
 }
 
-void localized_merge_contexts_and_delete(struct ast_context **extcontexts, const char *registrar);
-
-void localized_merge_contexts_and_delete(struct ast_context **extcontexts, const char *registrar)
+void localized_merge_contexts_and_delete(struct ast_context **extcontexts, void *tab, const char *registrar)
 {
 	ast_merge_contexts_and_delete(extcontexts, registrar);
 }
