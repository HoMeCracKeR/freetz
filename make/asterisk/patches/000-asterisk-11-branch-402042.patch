--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400741 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -1342,6 +1342,9 @@
 
 	ast_channel_internal_bridge_set(conference_bridge->playback_chan, conference_bridge->bridge);
 
+	/* To make sure playback_chan has the same language of that profile */
+	ast_channel_language_set(conference_bridge->playback_chan, conference_bridge->b_profile.language);
+
 	if (ast_call(conference_bridge->playback_chan, "", 0)) {
 		ast_hangup(conference_bridge->playback_chan);
 		conference_bridge->playback_chan = NULL;
--- apps/app_queue.c
+++ apps/app_queue.c
@@ -63,7 +63,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398885 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401433 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -7192,7 +7192,7 @@
 			}
 		} else if (qe.valid_digits) {
 			ast_queue_log(args.queuename, ast_channel_uniqueid(chan), "NONE", "EXITWITHKEY",
-				"%s|%d", qe.digits, qe.pos);
+				"%s|%d|%d|%ld", qe.digits, qe.pos, qe.opos, (long) time(NULL) - qe.start);
 		}
 	}
 
@@ -8253,9 +8253,10 @@
 		ao2_lock(q);
 		/* This check is to make sure we don't print information for realtime
 		 * queues which have been deleted from realtime but which have not yet
-		 * been deleted from the in-core container
+		 * been deleted from the in-core container. Only do this if we're not
+		 * looking for a specific queue.
 		 */
-		if (q->realtime) {
+		if (argc < 3 && q->realtime) {
 			realtime_queue = find_load_queue_rt_friendly(q->name);
 			if (!realtime_queue) {
 				ao2_unlock(q);
@@ -9134,6 +9135,7 @@
 {
 	const char *queuename, *interface;
 	struct member *mem = NULL;
+	char *res = CLI_FAILURE;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -9155,36 +9157,39 @@
 	queuename = a->argv[5];
 	interface = a->argv[3];
 
+	if (log_membername_as_agent) {
+		mem = find_member_by_queuename_and_interface(queuename, interface);
+	}
+
 	switch (remove_from_queue(queuename, interface)) {
 	case RES_OKAY:
-		if (log_membername_as_agent) {
-			mem = find_member_by_queuename_and_interface(queuename, interface);
-		}
 		if (!mem || ast_strlen_zero(mem->membername)) {
 			ast_queue_log(queuename, "CLI", interface, "REMOVEMEMBER", "%s", "");
 		} else {
 			ast_queue_log(queuename, "CLI", mem->membername, "REMOVEMEMBER", "%s", "");
 		}
-		if (mem) {
-			ao2_ref(mem, -1);
-		}
 		ast_cli(a->fd, "Removed interface %s from queue '%s'\n", interface, queuename);
-		return CLI_SUCCESS;
+		res = CLI_SUCCESS;
+		break;
 	case RES_EXISTS:
 		ast_cli(a->fd, "Unable to remove interface '%s' from queue '%s': Not there\n", interface, queuename);
-		return CLI_FAILURE;
+		break;
 	case RES_NOSUCHQUEUE:
 		ast_cli(a->fd, "Unable to remove interface from queue '%s': No such queue\n", queuename);
-		return CLI_FAILURE;
+		break;
 	case RES_OUTOFMEMORY:
 		ast_cli(a->fd, "Out of memory\n");
-		return CLI_FAILURE;
+		break;
 	case RES_NOT_DYNAMIC:
 		ast_cli(a->fd, "Unable to remove interface '%s' from queue '%s': Member is not dynamic\n", interface, queuename);
-		return CLI_FAILURE;
-	default:
-		return CLI_FAILURE;
+		break;
 	}
+
+	if (mem) {
+		ao2_ref(mem, -1);
+	}
+
+	return res;
 }
 
 static char *complete_queue_pause_member(const char *line, const char *word, int pos, int state)
--- apps/app_voicemail.c
+++ apps/app_voicemail.c
@@ -91,7 +91,7 @@
 #endif
 #endif
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398281 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401744 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_SPOOL_DIR */
 #include <sys/time.h>
@@ -11994,6 +11994,7 @@
 
 static int acf_vm_info(struct ast_channel *chan, const char *cmd, char *args, char *buf, size_t len)
 {
+	struct ast_vm_user svm;
 	struct ast_vm_user *vmu = NULL;
 	char *tmp, *mailbox, *context, *parse;
 	int res = 0;
@@ -12027,7 +12028,7 @@
 		 context = "default";
 	}
 
-	vmu = find_user(NULL, context, mailbox);
+	vmu = find_user(&svm, context, mailbox);
 
 	if (!strncasecmp(arg.attribute, "exists", 5)) {
 		ast_copy_string(buf, vmu ? "1" : "0", len);
@@ -13752,6 +13753,7 @@
 {
 	int i, j, res = AST_TEST_PASS, syserr;
 	struct ast_vm_user *vmu;
+	struct ast_vm_user svm;
 	struct vm_state vms;
 #ifdef IMAP_STORAGE
 	struct ast_channel *chan = NULL;
@@ -13804,7 +13806,7 @@
 	}
 #endif
 
-	if (!(vmu = find_user(NULL, testcontext, testmailbox)) &&
+	if (!(vmu = find_user(&svm, testcontext, testmailbox)) &&
 		!(vmu = find_or_create(testcontext, testmailbox))) {
 		ast_test_status_update(test, "Cannot create vmu structure\n");
 		ast_unreplace_sigchld();
--- apps/confbridge/conf_config_parser.c
+++ apps/confbridge/conf_config_parser.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400741 $")
 #include "asterisk/logger.h"
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -852,6 +852,7 @@
 
 	ast_cli(a->fd,"--------------------------------------------\n");
 	ast_cli(a->fd,"Name:                 %s\n", b_profile.name);
+	ast_cli(a->fd,"Language:             %s\n", b_profile.language);
 
 	if (b_profile.internal_sample_rate) {
 		snprintf(tmp, sizeof(tmp), "%d", b_profile.internal_sample_rate);
@@ -1306,7 +1307,7 @@
 		ao2_link(cfg->bridge_profiles, bridge_profile);
 	}
 
-	user_profile = ao2_find(cfg->bridge_profiles, DEFAULT_USER_PROFILE, OBJ_KEY);
+	user_profile = ao2_find(cfg->user_profiles, DEFAULT_USER_PROFILE, OBJ_KEY);
 	if (!user_profile) {
 		user_profile = user_profile_alloc(DEFAULT_USER_PROFILE);
 		if (!user_profile) {
@@ -1364,6 +1365,7 @@
 	aco_option_register_custom(&cfg_info, "video_mode", ACO_EXACT, bridge_types, NULL, video_mode_handler, 0);
 	aco_option_register(&cfg_info, "max_members", ACO_EXACT, bridge_types, "0", OPT_UINT_T, 0, FLDSET(struct bridge_profile, max_members));
 	aco_option_register(&cfg_info, "record_file", ACO_EXACT, bridge_types, NULL, OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct bridge_profile, rec_file));
+	aco_option_register(&cfg_info, "language", ACO_EXACT, bridge_types, "en", OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct bridge_profile, language));
 	aco_option_register_custom(&cfg_info, "^sound_", ACO_REGEX, bridge_types, NULL, sound_option_handler, 0);
 	/* This option should only be used with the CONFBRIDGE dialplan function */
 	aco_option_register_custom(&cfg_info, "template", ACO_EXACT, bridge_types, NULL, bridge_template_handler, 0);
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -191,6 +191,7 @@
 
 struct bridge_profile {
 	char name[64];
+	char language[MAX_LANGUAGE];		  /*!< Language used for playback_chan */
 	char rec_file[PATH_MAX];
 	unsigned int flags;
 	unsigned int max_members;          /*!< The maximum number of participants allowed in the conference */
--- cdr/cdr_adaptive_odbc.c
+++ cdr/cdr_adaptive_odbc.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 360724 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401579 $")
 
 #include <sys/types.h>
 #include <time.h>
@@ -711,6 +711,14 @@
 					continue;
 				}
 				first = 0;
+			} else if (entry->filtervalue
+				&& ((!entry->negatefiltervalue && entry->filtervalue[0] != '\0')
+					|| (entry->negatefiltervalue && entry->filtervalue[0] == '\0'))) {
+				ast_verb(4, "CDR column '%s' was not set and does not match filter of"
+					" %s'%s'.  Cancelling this CDR.\n",
+					entry->cdrname, entry->negatefiltervalue ? "!" : "",
+					entry->filtervalue);
+				goto early_release;
 			}
 		}
 
--- channels/chan_dahdi.c
+++ channels/chan_dahdi.c
@@ -49,7 +49,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397744 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401705 $")
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <pthread.h>
@@ -744,9 +744,9 @@
 	struct dahdi_pvt *oprpeer;				/*!< "Operator Services" peer tech_pvt ptr */
 	/*! \brief Amount of gain to increase during caller id */
 	float cid_rxgain;
-	/*! \brief Rx gain set by chan_dahdi.conf */
+	/*! \brief Software Rx gain set by chan_dahdi.conf */
 	float rxgain;
-	/*! \brief Tx gain set by chan_dahdi.conf */
+	/*! \brief Software Tx gain set by chan_dahdi.conf */
 	float txgain;
 
 	float txdrc; /*!< Dynamic Range Compression factor. a number between 1 and 6ish */
@@ -11949,6 +11949,11 @@
 	return NULL;
 }
 
+static void monitor_pfds_clean(void *arg) {
+	struct pollfd **pfds = arg;
+	ast_free(*pfds);
+}
+
 static void *do_monitor(void *data)
 {
 	int count, res, res2, spoint, pollres=0;
@@ -11972,6 +11977,7 @@
 #endif
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 
+	pthread_cleanup_push(monitor_pfds_clean, &pfds);
 	for (;;) {
 		/* Lock the interface list */
 		ast_mutex_lock(&iflock);
@@ -12231,6 +12237,7 @@
 		ast_mutex_unlock(&iflock);
 	}
 	/* Never reached */
+	pthread_cleanup_pop(1);
 	return NULL;
 
 }
@@ -15975,15 +15982,20 @@
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "dahdi set hwgain";
+		e->command = "dahdi set hwgain {rx|tx}";
 		e->usage =
 			"Usage: dahdi set hwgain <rx|tx> <chan#> <gain>\n"
-			"	Sets the hardware gain on a a given channel, overriding the\n"
-			"   value provided at module loadtime, whether the channel is in\n"
-			"   use or not.  Changes take effect immediately.\n"
+			"   Sets the hardware gain on a given channel.  Changes take effect\n"
+			"   immediately whether the channel is in use or not.\n"
+			"\n"
 			"   <rx|tx> which direction do you want to change (relative to our module)\n"
 			"   <chan num> is the channel number relative to the device\n"
-			"   <gain> is the gain in dB (e.g. -3.5 for -3.5dB)\n";
+			"   <gain> is the gain in dB (e.g. -3.5 for -3.5dB)\n"
+			"\n"
+			"   Please note:\n"
+			"   * This is currently the only way to set hwgain by the channel driver.\n"
+			"   * hwgain is only supportable by hardware with analog ports because\n"
+			"     hwgain works on the analog side of an analog-digital conversion.\n";
 		return NULL;
 	case CLI_GENERATE:
 		return NULL;
@@ -16044,12 +16056,13 @@
 
 	switch (cmd) {
 	case CLI_INIT:
-		e->command = "dahdi set swgain";
+		e->command = "dahdi set swgain {rx|tx}";
 		e->usage =
 			"Usage: dahdi set swgain <rx|tx> <chan#> <gain>\n"
-			"	Sets the software gain on a a given channel, overriding the\n"
-			"   value provided at module loadtime, whether the channel is in\n"
-			"   use or not.  Changes take effect immediately.\n"
+			"   Sets the software gain on a given channel and overrides the\n"
+			"   value provided at module loadtime.  Changes take effect\n"
+			"   immediately whether the channel is in use or not.\n"
+			"\n"
 			"   <rx|tx> which direction do you want to change (relative to our module)\n"
 			"   <chan num> is the channel number relative to the device\n"
 			"   <gain> is the gain in dB (e.g. -3.5 for -3.5dB)\n";
@@ -16093,6 +16106,12 @@
 
 		ast_cli(a->fd, "software %s gain set to %.1f on channel %d\n",
 			tx ? "tx" : "rx", gain, channel);
+
+		if (tx) {
+			tmp->txgain = gain;
+		} else {
+			tmp->rxgain = gain;
+		}
 		break;
 	}
 	ast_mutex_unlock(&iflock);
@@ -17065,8 +17084,10 @@
 
 #ifdef HAVE_PRI
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (pris[i].pri.master != AST_PTHREADT_NULL)
+		if (pris[i].pri.master != AST_PTHREADT_NULL) {
 			pthread_cancel(pris[i].pri.master);
+			pthread_kill(pris[i].pri.master, SIGURG);
+		}
 	}
 	ast_cli_unregister_multiple(dahdi_pri_cli, ARRAY_LEN(dahdi_pri_cli));
 	ast_unregister_application(dahdi_send_keypad_facility_app);
@@ -17076,9 +17097,11 @@
 #endif
 #if defined(HAVE_SS7)
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (linksets[i].ss7.master != AST_PTHREADT_NULL)
+		if (linksets[i].ss7.master != AST_PTHREADT_NULL) {
 			pthread_cancel(linksets[i].ss7.master);
+			pthread_kill(linksets[i].ss7.master, SIGURG);
 		}
+	}
 	ast_cli_unregister_multiple(dahdi_ss7_cli, ARRAY_LEN(dahdi_ss7_cli));
 #endif	/* defined(HAVE_SS7) */
 #if defined(HAVE_OPENR2)
@@ -17122,8 +17145,9 @@
 
 #if defined(HAVE_PRI)
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (pris[i].pri.master && (pris[i].pri.master != AST_PTHREADT_NULL))
+		if (pris[i].pri.master && (pris[i].pri.master != AST_PTHREADT_NULL)) {
 			pthread_join(pris[i].pri.master, NULL);
+		}
 		for (j = 0; j < SIG_PRI_NUM_DCHANS; j++) {
 			dahdi_close_pri_fd(&(pris[i]), j);
 		}
@@ -17138,8 +17162,9 @@
 
 #if defined(HAVE_SS7)
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL))
+		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL)) {
 			pthread_join(linksets[i].ss7.master, NULL);
+		}
 		for (j = 0; j < SIG_SS7_NUM_DCHANS; j++) {
 			dahdi_close_ss7_fd(&(linksets[i]), j);
 		}
--- channels/chan_iax2.c
+++ channels/chan_iax2.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399159 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401016 $")
 
 #include <sys/mman.h>
 #include <dirent.h>
@@ -5655,35 +5655,44 @@
 			break;
 		}
 		other = (who == c0) ? c1 : c0;  /* the 'other' channel */
-		if ((f->frametype == AST_FRAME_CONTROL)) {
-			if (f->subclass.integer == AST_CONTROL_PVT_CAUSE_CODE) {
+		if (f->frametype == AST_FRAME_CONTROL && !(flags & AST_BRIDGE_IGNORE_SIGS)) {
+			switch (f->subclass.integer) {
+			case AST_CONTROL_VIDUPDATE:
+			case AST_CONTROL_SRCUPDATE:
+			case AST_CONTROL_SRCCHANGE:
+			case AST_CONTROL_T38_PARAMETERS:
+				ast_write(other, f);
+				break;
+			case AST_CONTROL_PVT_CAUSE_CODE:
 				ast_channel_hangupcause_hash_set(other, f->data.ptr, f->datalen);
-			} else if (!(flags & AST_BRIDGE_IGNORE_SIGS)
-				&& (f->subclass.integer != AST_CONTROL_SRCUPDATE)) {
+				break;
+			default:
 				*fo = f;
 				*rc = who;
-				res =  AST_BRIDGE_COMPLETE;
+				res = AST_BRIDGE_COMPLETE;
 				break;
 			}
-		}
-		if ((f->frametype == AST_FRAME_VOICE) ||
-			(f->frametype == AST_FRAME_TEXT) ||
-			(f->frametype == AST_FRAME_VIDEO) || 
-			(f->frametype == AST_FRAME_IMAGE) ||
-			(f->frametype == AST_FRAME_DTMF) ||
-			(f->frametype == AST_FRAME_CONTROL && f->subclass.integer != AST_CONTROL_PVT_CAUSE_CODE)) {
+			if (res == AST_BRIDGE_COMPLETE) {
+				break;
+			}
+		} else if (f->frametype == AST_FRAME_VOICE
+			|| f->frametype == AST_FRAME_TEXT
+			|| f->frametype == AST_FRAME_VIDEO
+			|| f->frametype == AST_FRAME_IMAGE) {
+			ast_write(other, f);
+		} else if (f->frametype == AST_FRAME_DTMF) {
 			/* monitored dtmf take out of the bridge.
 			 * check if we monitor the specific source.
 			 */
 			int monitored_source = (who == c0) ? AST_BRIDGE_DTMF_CHANNEL_0 : AST_BRIDGE_DTMF_CHANNEL_1;
-			if (f->frametype == AST_FRAME_DTMF && (flags & monitored_source)) {
+
+			if (flags & monitored_source) {
 				*rc = who;
 				*fo = f;
 				res = AST_BRIDGE_COMPLETE;
 				/* Remove from native mode */
 				break;
 			}
-			/* everything else goes to the other side */
 			ast_write(other, f);
 		}
 		ast_frfree(f);
@@ -8718,7 +8727,7 @@
 		realtime_update_peer(peer->name, &peer->addr, 0);
 	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n", peer->name);
 	/* modify entry in peercnts table as _not_ registered */
-	peercnt_modify(0, 0, &peer->addr);
+	peercnt_modify((unsigned char) 0, 0, &peer->addr);
 	/* Reset the address */
 	memset(&peer->addr, 0, sizeof(peer->addr));
 	/* Reset expiry value */
@@ -8860,7 +8869,7 @@
 		}
 
 		/* modify entry in peercnts table as _not_ registered */
-		peercnt_modify(0, 0, &p->addr);
+		peercnt_modify((unsigned char) 0, 0, &p->addr);
 
 		/* Stash the IP address from which they registered */
 		ast_sockaddr_from_sin(&p->addr, sin);
@@ -8888,7 +8897,7 @@
 
 	/* modify entry in peercnts table as registered */
 	if (p->maxcallno) {
-		peercnt_modify(1, p->maxcallno, &p->addr);
+		peercnt_modify((unsigned char) 1, p->maxcallno, &p->addr);
 	}
 
 	/* Make sure our call still exists, an INVAL at the right point may make it go away */
@@ -10533,9 +10542,9 @@
 										ast_set_read_format(iaxs[fr->callno]->owner, ast_channel_readformat(iaxs[fr->callno]->owner));
 									}
 									ast_format_cap_copy(native, orignative);
-									ast_channel_unlock(iaxs[fr->callno]->owner);
 									orignative = ast_format_cap_destroy(orignative);
 								}
+								ast_channel_unlock(iaxs[fr->callno]->owner);
 							}
 						} else {
 							ast_debug(1, "Neat, somebody took away the channel at a magical time but i found it!\n");
@@ -12681,7 +12690,7 @@
 			peer->pokefreqok = DEFAULT_FREQ_OK;
 			peer->pokefreqnotok = DEFAULT_FREQ_NOTOK;
 			peer->maxcallno = 0;
-			peercnt_modify(0, 0, &peer->addr);
+			peercnt_modify((unsigned char) 0, 0, &peer->addr);
 			peer->calltoken_required = CALLTOKEN_DEFAULT;
 			ast_string_field_set(peer,context,"");
 			ast_string_field_set(peer,peercontext,"");
@@ -12869,7 +12878,7 @@
 				if (sscanf(v->value, "%10hu", &peer->maxcallno) != 1) {
 					ast_log(LOG_WARNING, "maxcallnumbers must be set to a valid number. %s is not valid at line %d.\n", v->value, v->lineno);
 				} else {
-					peercnt_modify(1, peer->maxcallno, &peer->addr);
+					peercnt_modify((unsigned char) 1, peer->maxcallno, &peer->addr);
 				}
 			} else if (!strcasecmp(v->name, "requirecalltoken")) {
 				/* default is required unless in optional ip list */
--- channels/chan_mgcp.c
+++ channels/chan_mgcp.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 366408 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401538 $")
 
 #include <sys/socket.h>
 #include <sys/ioctl.h>
@@ -1960,7 +1960,7 @@
 	char *c;
 	char *a;
 	char host[258];
-	int len;
+	int len = 0;
 	int portno;
 	struct ast_format_cap *peercap;
 	int peerNonCodecCapability;
@@ -1990,8 +1990,8 @@
 		ast_log(LOG_WARNING, "Unable to lookup host in c= line, '%s'\n", c);
 		return -1;
 	}
-	if (sscanf(m, "audio %30d RTP/AVP %n", &portno, &len) != 1) {
-		ast_log(LOG_WARNING, "Unable to determine port number for RTP in '%s'\n", m);
+	if (sscanf(m, "audio %30d RTP/AVP %n", &portno, &len) != 1 || !len) {
+		ast_log(LOG_WARNING, "Malformed media stream descriptor: %s\n", m);
 		return -1;
 	}
 	sin.sin_family = AF_INET;
--- channels/chan_sip.c
+++ channels/chan_sip.c
@@ -210,7 +210,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401235 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401884 $")
 
 #include <signal.h>
 #include <sys/signal.h>
@@ -770,6 +770,7 @@
 static int global_rtpkeepalive;     /*!< Send RTP keepalives */
 static int global_reg_timeout;      /*!< Global time between attempts for outbound registrations */
 static int global_regattempts_max;  /*!< Registration attempts before giving up */
+static int global_reg_retry_403;    /*!< Treat 403 responses to registrations as 401 responses */
 static int global_shrinkcallerid;   /*!< enable or disable shrinking of caller id  */
 static int global_callcounter;      /*!< Enable call counters for all devices. This is currently enabled by setting the peer
                                      *   call-limit to INT_MAX. When we remove the call-limit from the code, we can make it
@@ -7257,6 +7258,7 @@
 {
 	int res = 0;
 	struct sip_pvt *p = ast_channel_tech_pvt(ast);
+	int oldsdp = FALSE;
 
 	if (!p) {
 		ast_debug(1, "Asked to answer channel %s without tech pvt; ignoring\n",
@@ -7267,10 +7269,14 @@
 	if (ast_channel_state(ast) != AST_STATE_UP) {
 		try_suggested_sip_codec(p);
 
+		if (ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT)) {
+			oldsdp = TRUE;
+		}
+
 		ast_setstate(ast, AST_STATE_UP);
 		ast_debug(1, "SIP answering channel: %s\n", ast_channel_name(ast));
 		ast_rtp_instance_update_source(p->rtp);
-		res = transmit_response_with_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL, FALSE, TRUE);
+		res = transmit_response_with_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL, oldsdp, TRUE);
 		ast_set_flag(&p->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED);
 	}
 	sip_pvt_unlock(p);
@@ -10104,11 +10110,26 @@
 				}
 
 				if ((!strcmp(protocol, "RTP/SAVPF") || !strcmp(protocol, "UDP/TLS/RTP/SAVPF")) && !ast_test_flag(&p->flags[2], SIP_PAGE3_USE_AVPF)) {
-					ast_log(LOG_WARNING, "Received SAVPF profle in audio offer but AVPF is not enabled: %s\n", m);
-					continue;
+					if (req->method != SIP_RESPONSE) {
+						ast_log(LOG_NOTICE, "Received SAVPF profle in audio offer but AVPF is not enabled, enabling: %s\n", m);
+						secure_audio = 1;
+						ast_set_flag(&p->flags[2], SIP_PAGE3_USE_AVPF);
+					}
+					else {
+
+						ast_log(LOG_WARNING, "Received SAVPF profle in audio answer but AVPF is not enabled: %s\n", m);
+						continue;
+					}
 				} else if ((!strcmp(protocol, "RTP/SAVP") || !strcmp(protocol, "UDP/TLS/RTP/SAVP")) && ast_test_flag(&p->flags[2], SIP_PAGE3_USE_AVPF)) {
-					ast_log(LOG_WARNING, "Received SAVP profile in audio offer but AVPF is enabled: %s\n", m);
-					continue;
+					if (req->method != SIP_RESPONSE) {
+						ast_log(LOG_NOTICE, "Received SAVP profle in audio offer but AVPF is enabled, disabling: %s\n", m);
+						secure_audio = 1;
+						ast_clear_flag(&p->flags[2], SIP_PAGE3_USE_AVPF);
+					}
+					else {
+						ast_log(LOG_WARNING, "Received SAVP profile in audio offer but AVPF is enabled: %s\n", m);
+						continue;
+					}
 				} else if (!strcmp(protocol, "UDP/TLS/RTP/SAVP") || !strcmp(protocol, "UDP/TLS/RTP/SAVPF")) {
 					secure_audio = 1;
 
@@ -10118,11 +10139,23 @@
 				} else if (!strcmp(protocol, "RTP/SAVP") || !strcmp(protocol, "RTP/SAVPF")) {
 					secure_audio = 1;
 				} else if (!strcmp(protocol, "RTP/AVPF") && !ast_test_flag(&p->flags[2], SIP_PAGE3_USE_AVPF)) {
-					ast_log(LOG_WARNING, "Received AVPF profile in audio offer but AVPF is not enabled: %s\n", m);
-					continue;
+					if (req->method != SIP_RESPONSE) {
+						ast_log(LOG_NOTICE, "Received AVPF profile in audio offer but AVPF is not enabled, enabling: %s\n", m);
+						ast_set_flag(&p->flags[2], SIP_PAGE3_USE_AVPF);
+					}
+					else {
+						ast_log(LOG_WARNING, "Received AVP profile in audio answer but AVPF is enabled: %s\n", m);
+						continue;
+					}
 				} else if (!strcmp(protocol, "RTP/AVP") && ast_test_flag(&p->flags[2], SIP_PAGE3_USE_AVPF)) {
-					ast_log(LOG_WARNING, "Received AVP profile in audio offer but AVPF is enabled: %s\n", m);
-					continue;
+					if (req->method != SIP_RESPONSE) {
+						ast_log(LOG_NOTICE, "Received AVP profile in audio answer but AVPF is enabled, disabling: %s\n", m);
+						ast_clear_flag(&p->flags[2], SIP_PAGE3_USE_AVPF);
+					}
+					else {
+						ast_log(LOG_WARNING, "Received AVP profile in audio answer but AVPF is enabled: %s\n", m);
+						continue;
+					}
 				} else if ((!strcmp(protocol, "UDP/TLS/RTP/SAVP") || !strcmp(protocol, "UDP/TLS/RTP/SAVPF")) &&
 					   (!(dtls = ast_rtp_instance_get_dtls(p->rtp)) || !dtls->active(p->rtp))) {
 					ast_log(LOG_WARNING, "Received UDP/TLS in audio offer but DTLS is not enabled: %s\n", m);
@@ -13191,19 +13224,18 @@
 		*/
 
 		/* Prefer the audio codec we were requested to use, first, no matter what
-		   Note that p->prefcodec can include video codecs, so mask them out
+		   Note that p->prefcodec can include video codecs, so ignore them
 		*/
-		if (ast_format_cap_has_joint(tmpcap, p->prefcaps)) {
-			ast_format_cap_iter_start(p->prefcaps);
-			while (!(ast_format_cap_iter_next(p->prefcaps, &tmp_fmt))) {
-				if (AST_FORMAT_GET_TYPE(tmp_fmt.id) != AST_FORMAT_TYPE_AUDIO) {
-					continue;
-				}
-				add_codec_to_sdp(p, &tmp_fmt, &m_audio, &a_audio, debug, &min_audio_packet_size);
-				ast_format_cap_add(alreadysent, &tmp_fmt);
+		ast_format_cap_iter_start(p->prefcaps);
+		while (!(ast_format_cap_iter_next(p->prefcaps, &tmp_fmt))) {
+			if (AST_FORMAT_GET_TYPE(tmp_fmt.id) != AST_FORMAT_TYPE_AUDIO ||
+				!ast_format_cap_iscompatible(tmpcap, &tmp_fmt)) {
+				continue;
 			}
-			ast_format_cap_iter_end(p->prefcaps);
+			add_codec_to_sdp(p, &tmp_fmt, &m_audio, &a_audio, debug, &min_audio_packet_size);
+			ast_format_cap_add(alreadysent, &tmp_fmt);
 		}
+		ast_format_cap_iter_end(p->prefcaps);
 
 		/* Start by sending our preferred audio/video codecs */
 		for (x = 0; x < AST_CODEC_PREF_SIZE; x++) {
@@ -13282,13 +13314,9 @@
 		/* Our T.38 end is */
 		ast_udptl_get_us(p->udptl, &udptladdr);
 
-		/* Determine T.38 UDPTL destination */
-		if (!ast_sockaddr_isnull(&p->udptlredirip)) {
-			ast_sockaddr_copy(&udptldest, &p->udptlredirip);
-		} else {
-			ast_sockaddr_copy(&udptldest, &p->ourip);
-			ast_sockaddr_set_port(&udptldest, ast_sockaddr_port(&udptladdr));
-		}
+		/* We don't use directmedia for T.38, so keep the destination the same as our IP address. */
+		ast_sockaddr_copy(&udptldest, &p->ourip);
+		ast_sockaddr_set_port(&udptldest, ast_sockaddr_port(&udptladdr));
 
 		if (debug) {
 			ast_debug(1, "T.38 UDPTL is at %s port %d\n", ast_sockaddr_stringify_addr(&p->ourip), ast_sockaddr_port(&udptladdr));
@@ -13299,9 +13327,9 @@
 
 		ast_str_append(&m_modem, 0, "m=image %d udptl t38\r\n", ast_sockaddr_port(&udptldest));
 
-		if (!ast_sockaddr_cmp(&udptldest, &dest)) {
+		if (ast_sockaddr_cmp(&udptldest, &dest)) {
 			ast_str_append(&m_modem, 0, "c=IN %s %s\r\n",
-					(ast_sockaddr_is_ipv6(&dest) && !ast_sockaddr_is_ipv4_mapped(&dest)) ?
+					(ast_sockaddr_is_ipv6(&udptldest) && !ast_sockaddr_is_ipv4_mapped(&udptldest)) ?
 					"IP6" : "IP4", ast_sockaddr_stringify_addr_remote(&udptldest));
 		}
 
@@ -15912,6 +15940,14 @@
 		}
 	}
 
+	if (expire > max_expiry) {
+		expire = max_expiry;
+	}
+	if (expire < min_expiry && expire != 0) {
+		expire = min_expiry;
+	}
+	pvt->expiry = expire;
+
 	copy_socket_data(&pvt->socket, &req->socket);
 
 	do {
@@ -16051,12 +16087,6 @@
 	AST_SCHED_DEL_UNREF(sched, peer->expire,
 			sip_unref_peer(peer, "remove register expire ref"));
 
-	if (expire > max_expiry) {
-		expire = max_expiry;
-	}
-	if (expire < min_expiry) {
-		expire = min_expiry;
-	}
 	if (peer->is_realtime && !ast_test_flag(&peer->flags[1], SIP_PAGE2_RTCACHEFRIENDS)) {
 		peer->expire = -1;
 	} else {
@@ -16066,7 +16096,6 @@
 			sip_unref_peer(peer, "remote registration ref");
 		}
 	}
-	pvt->expiry = expire;
 	snprintf(data, sizeof(data), "%s:%d:%s:%s", ast_sockaddr_stringify(&peer->addr),
 		 expire, peer->username, peer->fullcontact);
 	/* We might not immediately be able to reconnect via TCP, but try caching it anyhow */
@@ -16918,7 +16947,10 @@
 						break;
 					case PARSE_REGISTER_UPDATE:
 						ast_string_field_set(p, fullcontact, peer->fullcontact);
-						update_peer(peer, p->expiry);
+						/* If expiry is 0, peer has been unregistered already */
+						if (p->expiry != 0) {
+							update_peer(peer, p->expiry);
+						}
 						/* Say OK and ask subsystem to retransmit msg counter */
 						transmit_response_with_date(p, "200 OK", req);
 						send_mwi = 1;
@@ -18275,9 +18307,9 @@
 					      int sipmethod, const char *uri, enum xmittype reliable,
 					      struct ast_sockaddr *addr, struct sip_peer **authpeer)
 {
-	char from[256] = "", *of, *name, *unused_password, *domain;
+	char from[256], *of, *name, *unused_password, *domain;
 	enum check_auth_result res = AUTH_DONT_KNOW;
-	char calleridname[50];
+	char calleridname[256];
 	char *uri2 = ast_strdupa(uri);
 
 	terminate_uri(uri2);	/* trim extra stuff */
@@ -20682,6 +20714,7 @@
 	ast_cli(a->fd, "  Sub. max duration:      %d secs\n", max_subexpiry);
 	ast_cli(a->fd, "  Outbound reg. timeout:  %d secs\n", global_reg_timeout);
 	ast_cli(a->fd, "  Outbound reg. attempts: %d\n", global_regattempts_max);
+	ast_cli(a->fd, "  Outbound reg. retry 403:%d\n", global_reg_retry_403);
 	ast_cli(a->fd, "  Notify ringing state:   %s\n", AST_CLI_YESNO(sip_cfg.notifyringing));
 	if (sip_cfg.notifyringing) {
 		ast_cli(a->fd, "    Include CID:          %s%s\n",
@@ -22780,13 +22813,26 @@
 		}
 		p->authtries = 0;
 		if (find_sdp(req)) {
-			if ((res = process_sdp(p, req, SDP_T38_ACCEPT)) && !req->ignore)
+			if ((res = process_sdp(p, req, SDP_T38_ACCEPT)) && !req->ignore) {
 				if (!reinvite) {
 					/* This 200 OK's SDP is not acceptable, so we need to ack, then hangup */
 					/* For re-invites, we try to recover */
 					ast_set_flag(&p->flags[0], SIP_PENDINGBYE);
+					ast_channel_hangupcause_set(p->owner, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
+					p->hangupcause = AST_CAUSE_BEARERCAPABILITY_NOTAVAIL;
+					sip_queue_hangup_cause(p, AST_CAUSE_BEARERCAPABILITY_NOTAVAIL);
 				}
+			}
 			ast_rtp_instance_activate(p->rtp);
+		} else if (!reinvite) {
+			struct ast_sockaddr remote_address = {{0,}};
+
+			ast_rtp_instance_get_remote_address(p->rtp, &remote_address);
+			if (ast_sockaddr_isnull(&remote_address) || (!ast_strlen_zero(p->theirprovtag) && strcmp(p->theirtag, p->theirprovtag))) {
+				ast_log(LOG_WARNING, "Received response: \"200 OK\" from '%s' without SDP\n", p->relatedpeer->name);
+				ast_set_flag(&p->flags[0], SIP_PENDINGBYE);
+				ast_rtp_instance_activate(p->rtp);
+			}
 		}
 
 		if (!req->ignore && p->owner) {
@@ -22846,7 +22892,7 @@
 		}
 
 		if (!req->ignore && p->owner) {
-			if (!reinvite) {
+			if (!reinvite && !res) {
 				ast_queue_control(p->owner, AST_CONTROL_ANSWER);
 				if (sip_cfg.callevents) {
 					manager_event(EVENT_FLAG_SYSTEM, "ChannelUpdate",
@@ -23406,8 +23452,9 @@
 			}
 			tmptmp = strcasestr(contact, "expires=");
 			if (tmptmp) {
-				if (sscanf(tmptmp + 8, "%30d;", &expires) != 1)
+				if (sscanf(tmptmp + 8, "%30d", &expires) != 1) {
 					expires = 0;
+				}
 			}
 			
 		}
@@ -23709,7 +23756,11 @@
 
 		gettag(req, "To", tag, sizeof(tag));
 		ast_string_field_set(p, theirtag, tag);
+	} else {
+		/* Store theirtag to track for changes when 200 responses to invites are received without SDP */
+		ast_string_field_set(p, theirprovtag, p->theirtag);
 	}
+
 	/* This needs to be configurable on a channel/peer level,
 	   not mandatory for all communication. Sadly enough, NAT implementations
 	   are not so stable so we can always rely on these headers.
@@ -31376,6 +31427,7 @@
 	sip_cfg.compactheaders = DEFAULT_COMPACTHEADERS;
 	global_reg_timeout = DEFAULT_REGISTRATION_TIMEOUT;
 	global_regattempts_max = 0;
+	global_reg_retry_403 = 0;
 	sip_cfg.pedanticsipchecking = DEFAULT_PEDANTIC;
 	sip_cfg.autocreatepeer = DEFAULT_AUTOCREATEPEER;
 	global_autoframing = 0;
@@ -31763,6 +31815,8 @@
 			}
 		} else if (!strcasecmp(v->name, "registerattempts")) {
 			global_regattempts_max = atoi(v->value);
+		} else if (!strcasecmp(v->name, "register_retry_403")) {
+			global_reg_retry_403 = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "bindaddr") || !strcasecmp(v->name, "udpbindaddr")) {
 			if (ast_parse_arg(v->value, PARSE_ADDR, &bindaddr)) {
 				ast_log(LOG_WARNING, "Invalid address: %s\n", v->value);
--- channels/sig_analog.c
+++ channels/sig_analog.c
@@ -689,13 +689,11 @@
  * \param p Analog private structure.
  * \param inthreeway TRUE if the 3-way call is conferenced.
  *
- * \note
- * On entry these locks are held: real-call, private, 3-way call.
+ * \note On entry these locks are held: real-call, private, 3-way call.
+ * \note On exit these locks are held: real-call, private.
  *
- * \retval 1 Transfer successful.  3-way call is unlocked and subchannel is unalloced.
- *         Swapped real and 3-way subchannel.
- * \retval 0 Transfer successful.  3-way call is unlocked and subchannel is unalloced.
- * \retval -1 on error.  Caller must unlock 3-way call.
+ * \retval 0 on success.
+ * \retval -1 on error.
  */
 static int analog_attempt_transfer(struct analog_pvt *p, int inthreeway)
 {
@@ -703,6 +701,7 @@
 	struct ast_channel *owner_3way;
 	struct ast_channel *bridge_real;
 	struct ast_channel *bridge_3way;
+	int ret = 0;
 
 	owner_real = p->subs[ANALOG_SUB_REAL].owner;
 	owner_3way = p->subs[ANALOG_SUB_THREEWAY].owner;
@@ -730,15 +729,8 @@
 			bridge_3way, ast_channel_connected(owner_3way), !inthreeway)) {
 			ast_log(LOG_WARNING, "Unable to masquerade %s as %s\n",
 				ast_channel_name(bridge_3way), ast_channel_name(owner_real));
-			return -1;
+			ret = -1;
 		}
-
-		/* Three-way is now the REAL */
-		analog_swap_subs(p, ANALOG_SUB_THREEWAY, ANALOG_SUB_REAL);
-		ast_channel_unlock(owner_3way);
-		analog_unalloc_sub(p, ANALOG_SUB_THREEWAY);
-		/* Tell the caller not to hangup */
-		return 1;
 	} else if (bridge_real) {
 		/* Try transferring the other way. */
 		ast_verb(3, "TRANSFERRING %s to %s\n", ast_channel_name(owner_real), ast_channel_name(owner_3way));
@@ -756,18 +748,19 @@
 			!inthreeway, bridge_real, ast_channel_connected(owner_real), 0)) {
 			ast_log(LOG_WARNING, "Unable to masquerade %s as %s\n",
 				ast_channel_name(bridge_real), ast_channel_name(owner_3way));
-			return -1;
+			ret = -1;
 		}
-
-		/* Orphan the channel after releasing the lock */
-		ast_channel_unlock(owner_3way);
-		analog_unalloc_sub(p, ANALOG_SUB_THREEWAY);
-		return 0;
 	} else {
 		ast_debug(1, "Neither %s nor %s are in a bridge, nothing to transfer\n",
 			ast_channel_name(owner_real), ast_channel_name(owner_3way));
-		return -1;
+		ret = -1;
+	}
+
+	if (ret) {
+		ast_softhangup_nolock(owner_3way, AST_SOFTHANGUP_DEV);
 	}
+	ast_channel_unlock(owner_3way);
+	return ret;
 }
 
 static int analog_update_conf(struct analog_pvt *p)
@@ -2912,16 +2905,13 @@
 								analog_set_new_owner(p, NULL);
 								/* Ring the phone */
 								analog_ring(p);
-							} else {
-								res = analog_attempt_transfer(p, inthreeway);
-								if (res < 0) {
-									/* Transfer attempt failed. */
-									ast_softhangup_nolock(p->subs[ANALOG_SUB_THREEWAY].owner, AST_SOFTHANGUP_DEV);
-									ast_channel_unlock(p->subs[ANALOG_SUB_THREEWAY].owner);
-								} else if (res) {
-									/* Don't actually hang up at this point */
-									break;
-								}
+							} else if (!analog_attempt_transfer(p, inthreeway)) {
+								/*
+								 * Transfer successful.  Don't actually hang up at this point.
+								 * Let our channel legs of the calls die off as the transfer
+								 * percolates through the core.
+								 */
+								break;
 							}
 						} else {
 							ast_softhangup_nolock(p->subs[ANALOG_SUB_THREEWAY].owner, AST_SOFTHANGUP_DEV);
--- channels/sig_ss7.c
+++ channels/sig_ss7.c
@@ -788,7 +788,9 @@
 	ss7_event *e = NULL;
 	struct sig_ss7_chan *p;
 	struct pollfd pollers[SIG_SS7_NUM_DCHANS];
-	int nextms = 0;
+	int nextms;
+
+#define SS7_MAX_POLL	60000	/* Maximum poll time in ms. */
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 
@@ -813,6 +815,11 @@
 			}
 			nextms = tv.tv_sec * 1000;
 			nextms += tv.tv_usec / 1000;
+			if (SS7_MAX_POLL < nextms) {
+				nextms = SS7_MAX_POLL;
+			}
+		} else {
+			nextms = SS7_MAX_POLL;
 		}
 
 		for (i = 0; i < linkset->numsigchans; i++) {
--- channels/sip/include/sip.h
+++ channels/sip/include/sip.h
@@ -1038,6 +1038,7 @@
 		AST_STRING_FIELD(rdnis);        /*!< Referring DNIS */
 		AST_STRING_FIELD(redircause);   /*!< Referring cause */
 		AST_STRING_FIELD(theirtag);     /*!< Their tag */
+		AST_STRING_FIELD(theirprovtag); /*!< Provisional their tag, used when evaluating responses to invites */
 		AST_STRING_FIELD(tag);          /*!< Our tag for this session */
 		AST_STRING_FIELD(username);     /*!< [user] name */
 		AST_STRING_FIELD(peername);     /*!< [peer] name, not set if [user] */
--- channels/sip/reqresp_parser.c
+++ channels/sip/reqresp_parser.c
@@ -25,7 +25,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 379393 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401661 $")
 
 #include "include/sip.h"
 #include "include/sip_utils.h"
@@ -806,7 +806,7 @@
 int get_name_and_number(const char *hdr, char **name, char **number)
 {
 	char header[256];
-	char tmp_name[50];
+	char tmp_name[256];
 	char *tmp_number = NULL;
 	char *hostport = NULL;
 	char *dummy = NULL;
@@ -1562,6 +1562,10 @@
 
 				contactptr = AST_LIST_NEXT(contactptr,list);
 			}
+
+			while ((contactptr = AST_LIST_REMOVE_HEAD(contactlistptr,list))) {
+				ast_free(contactptr);
+			}
 		}
 	}
 
--- codecs/ilbc/doCPLC.c
+++ codecs/ilbc/doCPLC.c
@@ -90,7 +90,7 @@
        int lag=20, randlag;
        float gain, maxcc;
        float use_gain;
-       float gain_comp, maxcc_comp, per, max_per;
+       float gain_comp, maxcc_comp, per, max_per=0;
        int i, pick, use_lag;
        float ftmp, randvec[BLOCKL_MAX], pitchfact, energy;
 
--- configs/confbridge.conf.sample
+++ configs/confbridge.conf.sample
@@ -197,6 +197,9 @@
                            ;               is the single source of video distribution among all participants. If
                            ;               that user leaves, the marked user to join after them becomes the source.
 
+;language=en               ; Set the language used for announcements to the conference.
+                           ; Default is en (English).
+
 ; All sounds in the conference are customizable using the bridge profile options below.
 ; Simply state the option followed by the filename or full path of the filename after
 ; the option.  Example: sound_had_joined=conf-hasjoin  This will play the conf-hasjoin
--- configs/sip.conf.sample
+++ configs/sip.conf.sample
@@ -774,6 +774,9 @@
                                 ; 0 = continue forever, hammering the other server
                                 ; until it accepts the registration
                                 ; Default is 0 tries, continue forever
+;register_retry_403=yes         ; Treat 403 responses to registrations as if they were
+                                ; 401 responses and continue retrying according to normal
+                                ; retry rules.
 
 ;----------------------------------------- OUTBOUND MWI SUBSCRIPTIONS -------------------------
 ; Asterisk can subscribe to receive the MWI from another SIP server and store it locally for retrieval
--- configure
+++ configure
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.ac Revision: 385356 .
+# From configure.ac Revision: 400075 .
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.69 for asterisk trunk.
 #
@@ -17517,6 +17517,114 @@
 
 fi
 
+if test "${PBX_BFD}" = "0"; then
+  # openSUSE requires -lz
+
+if test "x${PBX_BFD}" != "x1" -a "${USE_BFD}" != "no"; then
+   pbxlibdir=""
+   # if --with-BFD=DIR has been specified, use it.
+   if test "x${BFD_DIR}" != "x"; then
+      if test -d ${BFD_DIR}/lib; then
+         pbxlibdir="-L${BFD_DIR}/lib"
+      else
+         pbxlibdir="-L${BFD_DIR}"
+      fi
+   fi
+   pbxfuncname="bfd_check_format"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_BFD_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} "
+      as_ac_Lib=`$as_echo "ac_cv_lib_bfd_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lbfd" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lbfd... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbfd ${pbxlibdir} -ldl -liberty -lz $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_BFD_FOUND=yes
+else
+  AST_BFD_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_BFD_FOUND}" = "yes"; then
+      BFD_LIB="${pbxlibdir} -lbfd -ldl -liberty -lz"
+      # if --with-BFD=DIR has been specified, use it.
+      if test "x${BFD_DIR}" != "x"; then
+         BFD_INCLUDE="-I${BFD_DIR}/include"
+      fi
+      BFD_INCLUDE="${BFD_INCLUDE} "
+      if test "xbfd.h" = "x" ; then	# no header, assume found
+         BFD_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${BFD_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "bfd.h" "ac_cv_header_bfd_h" "$ac_includes_default"
+if test "x$ac_cv_header_bfd_h" = xyes; then :
+  BFD_HEADER_FOUND=1
+else
+  BFD_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${BFD_HEADER_FOUND}" = "x0" ; then
+         BFD_LIB=""
+         BFD_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            BFD_LIB=""
+         fi
+         PBX_BFD=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_BFD 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+fi
+
 if test "x${OSARCH}" = "xlinux-gnu" ; then
 
 if test "x${PBX_CAP}" != "x1" -a "${USE_CAP}" != "no"; then
@@ -31765,6 +31873,15 @@
 echo
 fi
 
+if test "x${AST_IODBC_FOUND}" = "xyes"; then
+	echo "WARNING: iodbc libs/headers found!"
+	echo
+	echo "  If you plan to use ODBC functionality, you should consider"
+	echo "  switching to unixodbc instead."
+	echo "  See: https://issues.asterisk.org/jira/browse/ASTERISK-22459"
+	echo
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: Package configured for: " >&5
 $as_echo "$as_me: Package configured for: " >&6;}
 { $as_echo "$as_me:${as_lineno-$LINENO}: OS type  : $host_os" >&5
--- doc/astdb2bdb.8
+++ doc/astdb2bdb.8
@@ -0,0 +1,46 @@
+.TH "ASTDB2BDB" "8" "30 SEPTEMBER 2013" "Asterisk 11" ""
+
+.SH NAME
+astdb2bdb \- convert astdb back to Berkeley DB 1.86
+.SH SYNOPSIS
+
+.B cd \fIastvarlibdir\fB && astdb2bdb path/to/astdb.sqlite3
+
+.SH "DESCRIPTION"
+Up until version version 11, Asterisk used an old version of the
+Berkeley DB 1.86 (bdb) to store its internal persistent database. In
+version 11 it switched to using a SQLIte 3 database. This program is
+used to convert the newly-formatted SQLite 3 astdb back to bdb.
+
+You may need it in case of reverting an upgrade or other similar
+scenarios.
+
+.SH OPTIONS
+There is a single (and required) parameter: the path the the sqlite file.
+The output file will be a file called
+.B astdb
+in the current working directory.
+
+.SH EXAMPLES
+In case you want to revert an upgrade to Asterisk 11, you can do the
+following (while Asterisk is not running):
+
+  cd /var/lib/asterisk && astdb2bdb astdb.sqlite3 && rm astdb.sqlite3
+
+This will convert the newly-formatted astdb back to the old format, and
+delete it (to avoid obsolete data copies).
+
+.SH NOTES
+Berkeley DB 1.86 is obsolete. It is incompatible with newer versions
+(4.x and newer) that you may see around. Chances are you don't have the
+tools to use it independently of Asterisk.
+
+.SH SEE ALSO
+.B astdb2sqlite3(8),
+.B asterisk(8)
+
+.SH AUTHOR
+astdb2bdb was written by Terry Wilson <twilson@digium.com>.
+
+This manual page was written by Tzafrir Cohen <tzafrir.cohen@xorcom.com>.
+
--- doc/astdb2sqlite3.8
+++ doc/astdb2sqlite3.8
@@ -0,0 +1,39 @@
+.TH "ASTDB2SQLITE3" "8" "30 SEPTEMBER 2013" "Asterisk 11" ""
+
+.SH NAME
+astdb2sqlite3 \- convert astdb to SQLite 3
+.SH SYNOPSIS
+
+.B astdb2sqlite3 path/to/astdb
+
+.SH "DESCRIPTION"
+Up until version version 11, Asterisk used an old version of the
+Berkeley DB 1.86 (bdb) to store its internal persistent database. In
+version 11 it switched to using a SQLite 3 database. This program is
+used to convert an existing bdb astdb file to astdb.sqlite3.
+
+Normally the conversion is done by Asterisk itself which will run this
+program. But you may need to run it on your own.
+
+.SH OPTIONS
+There is a single (and required) parameter: the path the the bdb file.
+The output file name will be the same as the input, with
+.B .sqlite3
+appended.
+
+.SH EXAMPLES
+Asterisk will typically run the following to upgrade the database:
+
+  astdb2sqlite3 /var/lib/asterisk/astdb
+
+which will create \fB/var/lib/asterisk/astdb.sqlite3\fR.
+
+.SH SEE ALSO
+.B astdb2bdb(8),
+.B asterisk(8)
+
+.SH AUTHOR
+astdb2sqlite3 was written by Terry Wilson <twilson@digium.com>.
+
+This manual page was written by Tzafrir Cohen <tzafrir.cohen@xorcom.com>.
+
--- funcs/func_config.c
+++ funcs/func_config.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 328259 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400697 $")
 
 #include "asterisk/module.h"
 #include "asterisk/channel.h"
@@ -120,7 +120,7 @@
 			/* At worst, we might leak an entry while upgrading locks */
 			AST_RWLIST_UNLOCK(&configs);
 			AST_RWLIST_WRLOCK(&configs);
-			if (!(cur = ast_malloc(sizeof(*cur) + strlen(args.filename) + 1))) {
+			if (!(cur = ast_calloc(1, sizeof(*cur) + strlen(args.filename) + 1))) {
 				AST_RWLIST_UNLOCK(&configs);
 				return -1;
 			}
@@ -149,7 +149,7 @@
 		}
 
 		if (!cur) {
-			if (!(cur = ast_malloc(sizeof(*cur) + strlen(args.filename) + 1))) {
+			if (!(cur = ast_calloc(1, sizeof(*cur) + strlen(args.filename) + 1))) {
 				AST_RWLIST_UNLOCK(&configs);
 				return -1;
 			}
--- funcs/func_math.c
+++ funcs/func_math.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 372630 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401661 $")
 
 #include <math.h>
 
@@ -503,6 +503,9 @@
 		res = AST_TEST_FAIL;
 	}
 
+	ast_free(expr);
+	ast_free(result);
+
 	return res;
 }
 #endif
--- include/asterisk/pbx.h
+++ include/asterisk/pbx.h
@@ -69,6 +69,16 @@
 	AST_EXTENSION_ONHOLD = 1 << 4,	/*!< All devices ONHOLD */
 };
 
+/*!
+ * \brief extension matchcid types
+ * \note matchcid in ast_exten retains 0/1, this adds 3rd state for functions to specify all
+ * \see ast_context_remove_extension_callerid
+ */
+enum ast_ext_matchcid_types {
+	AST_EXT_MATCHCID_OFF = 0,	/*!< Match only extensions with matchcid=0 */
+	AST_EXT_MATCHCID_ON = 1,	/*!< Match only extensions with matchcid=1 AND cidmatch matches */
+	AST_EXT_MATCHCID_ANY = 2,	/*!< Match both - used only in functions manipulating ast_exten's */
+};
 
 struct ast_context;
 struct ast_exten;
--- include/asterisk/rtp_engine.h
+++ include/asterisk/rtp_engine.h
@@ -1608,12 +1608,12 @@
 /*!
  * \brief Make two channels compatible for early bridging
  *
- * \param c0 First channel part of the bridge
- * \param c1 Second channel part of the bridge
+ * \param c_dst Destination channel to copy to
+ * \param c_src Source channel to copy from
  *
  * \since 1.8
  */
-void ast_rtp_instance_early_bridge_make_compatible(struct ast_channel *c0, struct ast_channel *c1);
+void ast_rtp_instance_early_bridge_make_compatible(struct ast_channel *c_dst, struct ast_channel *c_src);
 
 /*!
  * \brief Early bridge two channels that use RTP instances
--- main/app.c
+++ main/app.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 375301 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401705 $")
 
 #ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
@@ -2579,7 +2579,9 @@
 		return -1;
 	}
 
-	if ((res = sscanf(timestr, FMT, &amount, u)) == 0) {
+	res = sscanf(timestr, FMT, &amount, u);
+
+	if (res == 0 || res == EOF) {
 #undef FMT
 		return -1;
 	} else if (res == 2) {
--- main/asterisk.c
+++ main/asterisk.c
@@ -65,7 +65,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399267 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401705 $")
 
 #include "asterisk/_private.h"
 
@@ -1836,11 +1836,17 @@
 		close(ast_socket);
 		ast_socket = -1;
 		unlink(ast_config_AST_SOCKET);
+		pthread_kill(lthread, SIGURG);
+		pthread_join(lthread, NULL);
 	}
 	if (ast_consock > -1)
 		close(ast_consock);
 	if (!ast_opt_remote)
 		unlink(ast_config_AST_PID);
+	if (sig_alert_pipe[0])
+		close(sig_alert_pipe[0]);
+	if (sig_alert_pipe[1])
+		close(sig_alert_pipe[1]);
 	printf("%s", term_quit());
 	if (restart) {
 		int i;
--- main/astobj2.c
+++ main/astobj2.c
@@ -24,7 +24,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399099 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401783 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/astobj2.h"
@@ -1710,12 +1710,18 @@
 	AST_CLI_DEFINE(handle_astobj2_stats, "Print astobj2 statistics"),
 	AST_CLI_DEFINE(handle_astobj2_test, "Test astobj2"),
 };
+
+static void astobj2_cleanup(void)
+{
+	ast_cli_unregister_multiple(cli_astobj2, ARRAY_LEN(cli_astobj2));
+}
 #endif /* AO2_DEBUG */
 
 int astobj2_init(void)
 {
 #ifdef AO2_DEBUG
 	ast_cli_register_multiple(cli_astobj2, ARRAY_LEN(cli_astobj2));
+	ast_register_atexit(astobj2_cleanup);
 #endif
 
 	return 0;
--- main/channel.c
+++ main/channel.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401235 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401179 $")
 
 #include "asterisk/_private.h"
 
--- main/config_options.c
+++ main/config_options.c
@@ -27,7 +27,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399564 $")
 
 #include <regex.h>
 
@@ -370,10 +370,6 @@
 	}
 
 	if (type->type == ACO_GLOBAL && *field) {
-		if (aco_set_defaults(type, cat, *field)) {
-			ast_log(LOG_ERROR, "In %s: Setting defaults for %s failed\n", file->filename, cat);
-			return -1;
-		}
 		if (aco_process_category_options(type, cfg, cat, *field)) {
 			ast_log(LOG_ERROR, "In %s: Processing options for %s failed\n", file->filename, cat);
 			return -1;
@@ -504,6 +500,28 @@
 
 	while (res != ACO_PROCESS_ERROR && (file = info->files[x++])) {
 		const char *filename = file->filename;
+		struct aco_type *match;
+		int i;
+
+		/* set defaults for global objects */
+		for (i = 0, match = file->types[i]; match; match = file->types[++i]) {
+			void **field = info->internal->pending + match->item_offset;
+
+			if (match->type != ACO_GLOBAL || !*field) {
+				continue;
+			}
+
+			if (aco_set_defaults(match, match->category, *field)) {
+				ast_log(LOG_ERROR, "In %s: Setting defaults for %s failed\n", file->filename, match->category);
+				res = ACO_PROCESS_ERROR;
+				break;
+			}
+		}
+
+		if (res == ACO_PROCESS_ERROR) {
+			break;
+		}
+
 try_alias:
 		if (!(cfg = ast_config_load(filename, cfg_flags))) {
 			if (file->alias && strcmp(file->alias, filename)) {
--- main/data.c
+++ main/data.c
@@ -28,7 +28,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396961 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401705 $")
 
 #include "asterisk/_private.h"
 
@@ -3322,6 +3322,7 @@
 	ao2_t_ref(root_data.container, -1, "Unref root_data.container in data_shutdown");
 	root_data.container = NULL;
 	ast_rwlock_destroy(&root_data.lock);
+	AST_TEST_UNREGISTER(test_data_get);
 }
 
 int ast_data_init(void)
@@ -3339,9 +3340,7 @@
 
 	res |= ast_manager_register_xml_core("DataGet", 0, manager_data_get);
 
-#ifdef TEST_FRAMEWORK
 	AST_TEST_REGISTER(test_data_get);
-#endif
 
 	ast_register_atexit(data_shutdown);
 
--- main/editline/readline.c
+++ main/editline/readline.c
@@ -1236,8 +1236,11 @@
 	filename_len = strlen(filename);
 
 	dir = opendir(dirname ? dirname : ".");
-	if (!dir)
+	if (!dir) {
+		free(filename);
+		free(dirname);
 		return (NULL);	/* cannot open the directory */
+	}
 
 	/* find the match */
 	while ((entry = readdir(dir)) != NULL) {
@@ -1274,6 +1277,8 @@
 	} else
 		temp = NULL;
 	closedir(dir);
+	free(filename);
+	free(dirname);
 
 	return (temp);
 }
--- main/editline/term.c
+++ main/editline/term.c
@@ -65,15 +65,17 @@
 #include <ncurses.h>
 #endif
 #if defined(HAVE_TERM_H)
-#include "term.h"
 /* Can not use /usr/include/term.h because of a lot of incompatibilities, so just define some prototypes */
+#include "term.h"
+#endif /* defined(HAVE_TERM_H) */
+#if defined(HAVE_TERM_H) || !(defined(HAVE_TERMCAP_H) || defined(HAVE_CURSES_H) || defined(HAVE_NCURSES_H))
 extern int tgetent(char *, const char *);
 extern int tgetflag(const char *);
 extern int tgetnum(const char *);
 extern char *tgetstr(const char *, char **);
 extern int tputs (const char *, int, int (*)(int));
 extern char *tgoto (const char *, int, int);
-#endif /* defined(HAVE_TERM_H) */
+#endif /* defined(HAVE_TERM_H) or none_of_the_others */
 #include <sys/types.h>
 #include <sys/ioctl.h>
 
--- main/jitterbuf.c
+++ main/jitterbuf.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 369013 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401787 $")
 
 #include "jitterbuf.h"
 #include "asterisk/utils.h"
@@ -73,10 +73,12 @@
 
 void jb_reset(jitterbuf *jb)
 {
-	/* only save settings */
+	/* only save settings and free list */
 	jb_conf s = jb->info.conf;
+	jb_frame *fr = jb->free;
 	memset(jb, 0, sizeof(*jb));
 	jb->info.conf = s;
+	jb->free = fr;
 
 	/* initialize length, using the default value */
 	jb->info.current = jb->info.target = jb->info.conf.target_extra = JB_TARGET_EXTRA;
@@ -87,7 +89,7 @@
 {
 	jitterbuf *jb;
 
-	if (!(jb = ast_malloc(sizeof(*jb))))
+	if (!(jb = ast_calloc(1, sizeof(*jb))))
 		return NULL;
 
 	jb_reset(jb);
--- main/logger.c
+++ main/logger.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401235 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401833 $")
 
 /* When we include logger.h again it will trample on some stuff in syslog.h, but
  * nothing we care about in here. */
@@ -254,7 +254,6 @@
 			break;
 		} else if (!strncasecmp(w, "verbose(", 8) && sscanf(w + 8, "%d)", verbosity) == 1) {
 			res |= (1 << __LOG_VERBOSE);
-			break;
 		} else for (x = 0; x < ARRAY_LEN(levels); x++) {
 			if (levels[x] && !strcasecmp(w, levels[x])) {
 				res |= (1 << x);
--- main/pbx.c
+++ main/pbx.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401960 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_SYSTEM_NAME */
@@ -1239,13 +1239,22 @@
 	}
 
 	/* but if they are the same, do the cidmatch values match? */
-	if (ac->matchcid && bc->matchcid) {
-		return strcmp(ac->cidmatch,bc->cidmatch);
-	} else if (!ac->matchcid && !bc->matchcid) {
-		return 0; /* if there's no matchcid on either side, then this is a match */
-	} else {
-		return 1; /* if there's matchcid on one but not the other, they are different */
+	/* not sure which side may be using ast_ext_matchcid_types, so check both */
+	if (ac->matchcid == AST_EXT_MATCHCID_ANY || bc->matchcid == AST_EXT_MATCHCID_ANY) {
+		return 0;
+	}
+	if (ac->matchcid == AST_EXT_MATCHCID_OFF && bc->matchcid == AST_EXT_MATCHCID_OFF) {
+		return 0;
+	}
+	if (ac->matchcid != bc->matchcid) {
+		return 1;
 	}
+	/* all other cases already disposed of, match now required on callerid string (cidmatch) */
+	/* although ast_add_extension2_lockopt() enforces non-zero ptr, caller may not have */
+	if (ast_strlen_zero(ac->cidmatch) && ast_strlen_zero(bc->cidmatch)) {
+		return 0;
+	}
+	return strcmp(ac->cidmatch, bc->cidmatch);
 }
 
 static int hashtab_compare_exten_numbers(const void *ah_a, const void *ah_b)
@@ -1273,7 +1282,7 @@
 	const struct ast_exten *ac = obj;
 	unsigned int x = ast_hashtab_hash_string(ac->exten);
 	unsigned int y = 0;
-	if (ac->matchcid)
+	if (ac->matchcid == AST_EXT_MATCHCID_ON)
 		y = ast_hashtab_hash_string(ac->cidmatch);
 	return x+y;
 }
@@ -1459,7 +1468,7 @@
 				ast_copy_string(dummy_name, e1->exten, sizeof(dummy_name));
 				e2 = ast_hashtab_lookup(c1->root_table, &ex);
 				if (!e2) {
-					if (e1->matchcid) {
+					if (e1->matchcid == AST_EXT_MATCHCID_ON) {
 						ast_log(LOG_NOTICE,"Called from: %s:%d: The %s context records the exten %s (CID match: %s) but it is not in its root_table\n", file, line, c2->name, dummy_name, e1->cidmatch );
 					} else {
 						ast_log(LOG_NOTICE,"Called from: %s:%d: The %s context records the exten %s but it is not in its root_table\n", file, line, c2->name, dummy_name );
@@ -6828,7 +6837,7 @@
 /*! \note This function will lock conlock. */
 int ast_context_remove_extension(const char *context, const char *extension, int priority, const char *registrar)
 {
-	return ast_context_remove_extension_callerid(context, extension, priority, NULL, 0, registrar);
+	return ast_context_remove_extension_callerid(context, extension, priority, NULL, AST_EXT_MATCHCID_ANY, registrar);
 }
 
 int ast_context_remove_extension_callerid(const char *context, const char *extension, int priority, const char *callerid, int matchcallerid, const char *registrar)
@@ -6858,7 +6867,7 @@
  */
 int ast_context_remove_extension2(struct ast_context *con, const char *extension, int priority, const char *registrar, int already_locked)
 {
-	return ast_context_remove_extension_callerid2(con, extension, priority, NULL, 0, registrar, already_locked);
+	return ast_context_remove_extension_callerid2(con, extension, priority, NULL, AST_EXT_MATCHCID_ANY, registrar, already_locked);
 }
 
 int ast_context_remove_extension_callerid2(struct ast_context *con, const char *extension, int priority, const char *callerid, int matchcallerid, const char *registrar, int already_locked)
@@ -6874,10 +6883,6 @@
 	if (!already_locked)
 		ast_wrlock_context(con);
 
-	/* Handle this is in the new world */
-
-	/* FIXME For backwards compatibility, if callerid==NULL, then remove ALL
-	 * peers, not just those matching the callerid. */
 #ifdef NEED_DEBUG
 	ast_verb(3,"Removing %s/%s/%d%s%s from trees, registrar=%s\n", con->name, extension, priority, matchcallerid ? "/" : "", matchcallerid ? callerid : "", registrar);
 #endif
@@ -6886,7 +6891,7 @@
 #endif
 	/* find this particular extension */
 	ex.exten = dummy_name;
-	ex.matchcid = matchcallerid && !ast_strlen_zero(callerid); /* don't say match if there's no callerid */
+	ex.matchcid = matchcallerid;
 	ex.cidmatch = callerid;
 	ast_copy_string(dummy_name, extension, sizeof(dummy_name));
 	exten = ast_hashtab_lookup(con->root_table, &ex);
@@ -6909,7 +6914,6 @@
 			ex.priority = priority;
 			exten2 = ast_hashtab_lookup(exten->peer_table, &ex);
 			if (exten2) {
-
 				if (exten2->label) { /* if this exten has a label, remove that, too */
 					exten3 = ast_hashtab_remove_this_object(exten->peer_label_table,exten2);
 					if (!exten3)
@@ -6970,10 +6974,11 @@
 
 	/* scan the priority list to remove extension with exten->priority == priority */
 	for (peer = exten, next_peer = exten->peer ? exten->peer : exten->next;
-		 peer && !strcmp(peer->exten, extension) && (!matchcallerid || (!ast_strlen_zero(callerid) && !ast_strlen_zero(peer->cidmatch) && !strcmp(peer->cidmatch,callerid)) || (ast_strlen_zero(callerid) && ast_strlen_zero(peer->cidmatch)));
+		 peer && !strcmp(peer->exten, extension) &&
+			(!callerid || (!matchcallerid && !peer->matchcid) || (matchcallerid && peer->matchcid && !strcmp(peer->cidmatch, callerid))) ;
 			peer = next_peer, next_peer = next_peer ? (next_peer->peer ? next_peer->peer : next_peer->next) : NULL) {
+
 		if ((priority == 0 || peer->priority == priority) &&
-				(!callerid || !matchcallerid || (matchcallerid && !strcmp(peer->cidmatch, callerid))) &&
 				(!registrar || !strcmp(peer->registrar, registrar) )) {
 			found = 1;
 
@@ -7004,6 +7009,7 @@
 				previous_peer->peer = peer->peer;
 			}
 
+
 			/* now, free whole priority extension */
 			destroy_exten(peer);
 		} else {
@@ -7683,7 +7689,7 @@
 			dpc->total_prio++;
 
 			/* write extension name and first peer */
-			if (e->matchcid)
+			if (e->matchcid == AST_EXT_MATCHCID_ON)
 				snprintf(buf, sizeof(buf), "'%s' (CID match '%s') => ", ast_get_extension_name(e), e->cidmatch);
 			else
 				snprintf(buf, sizeof(buf), "'%s' =>", ast_get_extension_name(e));
@@ -9853,10 +9859,10 @@
 	/* Blank callerid and NULL callerid are two SEPARATE things.  Do NOT confuse the two!!! */
 	if (callerid) {
 		p += ext_strncpy(p, callerid, strlen(callerid) + 1) + 1;
-		tmp->matchcid = 1;
+		tmp->matchcid = AST_EXT_MATCHCID_ON;
 	} else {
 		*p++ = '\0';
-		tmp->matchcid = 0;
+		tmp->matchcid = AST_EXT_MATCHCID_OFF;
 	}
 	tmp->app = p;
 	strcpy(p, application);
@@ -9873,7 +9879,7 @@
 								an extension, and the trie exists, then we need to incrementally add this pattern to it. */
 		ast_copy_string(dummy_name, extension, sizeof(dummy_name));
 		dummy_exten.exten = dummy_name;
-		dummy_exten.matchcid = 0;
+		dummy_exten.matchcid = AST_EXT_MATCHCID_OFF;
 		dummy_exten.cidmatch = 0;
 		tmp2 = ast_hashtab_lookup(con->root_table, &dummy_exten);
 		if (!tmp2) {
@@ -9886,11 +9892,11 @@
 	for (e = con->root; e; el = e, e = e->next) {   /* scan the extension list */
 		res = ext_cmp(e->exten, tmp->exten);
 		if (res == 0) { /* extension match, now look at cidmatch */
-			if (!e->matchcid && !tmp->matchcid)
+			if (e->matchcid == AST_EXT_MATCHCID_OFF && tmp->matchcid == AST_EXT_MATCHCID_OFF)
 				res = 0;
-			else if (tmp->matchcid && !e->matchcid)
+			else if (tmp->matchcid == AST_EXT_MATCHCID_ON && e->matchcid == AST_EXT_MATCHCID_OFF)
 				res = 1;
-			else if (e->matchcid && !tmp->matchcid)
+			else if (e->matchcid == AST_EXT_MATCHCID_ON && tmp->matchcid == AST_EXT_MATCHCID_OFF)
 				res = -1;
 			else
 				res = ext_cmp(e->cidmatch, tmp->cidmatch);
@@ -9967,7 +9973,7 @@
 		}
 	}
 	if (option_debug) {
-		if (tmp->matchcid) {
+		if (tmp->matchcid == AST_EXT_MATCHCID_ON) {
 			ast_debug(1, "Added extension '%s' priority %d (CID match '%s') to %s (%p)\n",
 					  tmp->exten, tmp->priority, tmp->cidmatch, con->name, con);
 		} else {
@@ -9976,7 +9982,7 @@
 		}
 	}
 
-	if (tmp->matchcid) {
+	if (tmp->matchcid == AST_EXT_MATCHCID_ON) {
 		ast_verb(3, "Added extension '%s' priority %d (CID match '%s') to %s\n",
 				 tmp->exten, tmp->priority, tmp->cidmatch, con->name);
 	} else {
@@ -10598,12 +10604,11 @@
 						}
 						ast_verb(3, "Remove %s/%s/%d, registrar=%s; con=%s(%p); con->root=%p\n",
 								 tmp->name, prio_item->exten, prio_item->priority, registrar, con? con->name : "<nil>", con, con? con->root_table: NULL);
-						/* set matchcid to 1 to insure we get a direct match, and NULL registrar to make sure no wildcarding is done */
 						ast_copy_string(extension, prio_item->exten, sizeof(extension));
 						if (prio_item->cidmatch) {
 							ast_copy_string(cidmatch, prio_item->cidmatch, sizeof(cidmatch));
 						}
-						end_traversal &= ast_context_remove_extension_callerid2(tmp, extension, prio_item->priority, prio_item->cidmatch ? cidmatch : NULL, 1, NULL, 1);
+						end_traversal &= ast_context_remove_extension_callerid2(tmp, extension, prio_item->priority, cidmatch, prio_item->matchcid, NULL, 1);
 					}
 					/* Explanation:
 					 * ast_context_remove_extension_callerid2 will destroy the extension that it comes across. This
--- main/rtp_engine.c
+++ main/rtp_engine.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 381306 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402042 $")
 
 #include <math.h>
 
@@ -1627,90 +1627,90 @@
 	return instance->bridged;
 }
 
-void ast_rtp_instance_early_bridge_make_compatible(struct ast_channel *c0, struct ast_channel *c1)
+void ast_rtp_instance_early_bridge_make_compatible(struct ast_channel *c_dst, struct ast_channel *c_src)
 {
-	struct ast_rtp_instance *instance0 = NULL, *instance1 = NULL,
-		*vinstance0 = NULL, *vinstance1 = NULL,
-		*tinstance0 = NULL, *tinstance1 = NULL;
-	struct ast_rtp_glue *glue0, *glue1;
-	enum ast_rtp_glue_result audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID, video_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
-	enum ast_rtp_glue_result audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID, video_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
-	struct ast_format_cap *cap0 = ast_format_cap_alloc_nolock();
-	struct ast_format_cap *cap1 = ast_format_cap_alloc_nolock();
+	struct ast_rtp_instance *instance_dst = NULL, *instance_src = NULL,
+		*vinstance_dst = NULL, *vinstance_src = NULL,
+		*tinstance_dst = NULL, *tinstance_src = NULL;
+	struct ast_rtp_glue *glue_dst, *glue_src;
+	enum ast_rtp_glue_result audio_glue_dst_res = AST_RTP_GLUE_RESULT_FORBID, video_glue_dst_res = AST_RTP_GLUE_RESULT_FORBID;
+	enum ast_rtp_glue_result audio_glue_src_res = AST_RTP_GLUE_RESULT_FORBID, video_glue_src_res = AST_RTP_GLUE_RESULT_FORBID;
+	struct ast_format_cap *cap_dst = ast_format_cap_alloc_nolock();
+	struct ast_format_cap *cap_src = ast_format_cap_alloc_nolock();
 
 	/* Lock both channels so we can look for the glue that binds them together */
-	ast_channel_lock_both(c0, c1);
+	ast_channel_lock_both(c_dst, c_src);
 
-	if (!cap1 || !cap0) {
+	if (!cap_src || !cap_dst) {
 		goto done;
 	}
 
 	/* Grab glue that binds each channel to something using the RTP engine */
-	if (!(glue0 = ast_rtp_instance_get_glue(ast_channel_tech(c0)->type)) || !(glue1 = ast_rtp_instance_get_glue(ast_channel_tech(c1)->type))) {
-		ast_debug(1, "Can't find native functions for channel '%s'\n", glue0 ? ast_channel_name(c1) : ast_channel_name(c0));
+	if (!(glue_dst = ast_rtp_instance_get_glue(ast_channel_tech(c_dst)->type)) || !(glue_src = ast_rtp_instance_get_glue(ast_channel_tech(c_src)->type))) {
+		ast_debug(1, "Can't find native functions for channel '%s'\n", glue_dst ? ast_channel_name(c_src) : ast_channel_name(c_dst));
 		goto done;
 	}
 
-	audio_glue0_res = glue0->get_rtp_info(c0, &instance0);
-	video_glue0_res = glue0->get_vrtp_info ? glue0->get_vrtp_info(c0, &vinstance0) : AST_RTP_GLUE_RESULT_FORBID;
+	audio_glue_dst_res = glue_dst->get_rtp_info(c_dst, &instance_dst);
+	video_glue_dst_res = glue_dst->get_vrtp_info ? glue_dst->get_vrtp_info(c_dst, &vinstance_dst) : AST_RTP_GLUE_RESULT_FORBID;
 
-	audio_glue1_res = glue1->get_rtp_info(c1, &instance1);
-	video_glue1_res = glue1->get_vrtp_info ? glue1->get_vrtp_info(c1, &vinstance1) : AST_RTP_GLUE_RESULT_FORBID;
+	audio_glue_src_res = glue_src->get_rtp_info(c_src, &instance_src);
+	video_glue_src_res = glue_src->get_vrtp_info ? glue_src->get_vrtp_info(c_src, &vinstance_src) : AST_RTP_GLUE_RESULT_FORBID;
 
 	/* If we are carrying video, and both sides are not going to remotely bridge... fail the native bridge */
-	if (video_glue0_res != AST_RTP_GLUE_RESULT_FORBID && (audio_glue0_res != AST_RTP_GLUE_RESULT_REMOTE || video_glue0_res != AST_RTP_GLUE_RESULT_REMOTE)) {
-		audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
+	if (video_glue_dst_res != AST_RTP_GLUE_RESULT_FORBID && (audio_glue_dst_res != AST_RTP_GLUE_RESULT_REMOTE || video_glue_dst_res != AST_RTP_GLUE_RESULT_REMOTE)) {
+		audio_glue_dst_res = AST_RTP_GLUE_RESULT_FORBID;
 	}
-	if (video_glue1_res != AST_RTP_GLUE_RESULT_FORBID && (audio_glue1_res != AST_RTP_GLUE_RESULT_REMOTE || video_glue1_res != AST_RTP_GLUE_RESULT_REMOTE)) {
-		audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
+	if (video_glue_src_res != AST_RTP_GLUE_RESULT_FORBID && (audio_glue_src_res != AST_RTP_GLUE_RESULT_REMOTE || video_glue_src_res != AST_RTP_GLUE_RESULT_REMOTE)) {
+		audio_glue_src_res = AST_RTP_GLUE_RESULT_FORBID;
 	}
-	if (audio_glue0_res == AST_RTP_GLUE_RESULT_REMOTE && (video_glue0_res == AST_RTP_GLUE_RESULT_FORBID || video_glue0_res == AST_RTP_GLUE_RESULT_REMOTE) && glue0->get_codec) {
-		glue0->get_codec(c0, cap0);
+	if (audio_glue_dst_res == AST_RTP_GLUE_RESULT_REMOTE && (video_glue_dst_res == AST_RTP_GLUE_RESULT_FORBID || video_glue_dst_res == AST_RTP_GLUE_RESULT_REMOTE) && glue_dst->get_codec) {
+		glue_dst->get_codec(c_dst, cap_dst);
 	}
-	if (audio_glue1_res == AST_RTP_GLUE_RESULT_REMOTE && (video_glue1_res == AST_RTP_GLUE_RESULT_FORBID || video_glue1_res == AST_RTP_GLUE_RESULT_REMOTE) && glue1->get_codec) {
-		glue1->get_codec(c1, cap1);
+	if (audio_glue_src_res == AST_RTP_GLUE_RESULT_REMOTE && (video_glue_src_res == AST_RTP_GLUE_RESULT_FORBID || video_glue_src_res == AST_RTP_GLUE_RESULT_REMOTE) && glue_src->get_codec) {
+		glue_src->get_codec(c_src, cap_src);
 	}
 
 	/* If any sort of bridge is forbidden just completely bail out and go back to generic bridging */
-	if (audio_glue0_res != AST_RTP_GLUE_RESULT_REMOTE || audio_glue1_res != AST_RTP_GLUE_RESULT_REMOTE) {
+	if (audio_glue_dst_res != AST_RTP_GLUE_RESULT_REMOTE || audio_glue_src_res != AST_RTP_GLUE_RESULT_REMOTE) {
 		goto done;
 	}
 
 	/* Make sure we have matching codecs */
-	if (!ast_format_cap_has_joint(cap0, cap1)) {
+	if (!ast_format_cap_has_joint(cap_dst, cap_src)) {
 		goto done;
 	}
 
-	ast_rtp_codecs_payloads_copy(&instance0->codecs, &instance1->codecs, instance1);
+	ast_rtp_codecs_payloads_copy(&instance_src->codecs, &instance_dst->codecs, instance_dst);
 
-	if (vinstance0 && vinstance1) {
-		ast_rtp_codecs_payloads_copy(&vinstance0->codecs, &vinstance1->codecs, vinstance1);
+	if (vinstance_dst && vinstance_src) {
+		ast_rtp_codecs_payloads_copy(&vinstance_src->codecs, &vinstance_dst->codecs, vinstance_dst);
 	}
-	if (tinstance0 && tinstance1) {
-		ast_rtp_codecs_payloads_copy(&tinstance0->codecs, &tinstance1->codecs, tinstance1);
+	if (tinstance_dst && tinstance_src) {
+		ast_rtp_codecs_payloads_copy(&tinstance_src->codecs, &tinstance_dst->codecs, tinstance_dst);
 	}
 
-	if (glue0->update_peer(c0, instance1, vinstance1, tinstance1, cap1, 0)) {
+	if (glue_dst->update_peer(c_dst, instance_src, vinstance_src, tinstance_src, cap_src, 0)) {
 		ast_log(LOG_WARNING, "Channel '%s' failed to setup early bridge to '%s'\n",
-			ast_channel_name(c0), ast_channel_name(c1));
+			ast_channel_name(c_dst), ast_channel_name(c_src));
 	} else {
 		ast_debug(1, "Seeded SDP of '%s' with that of '%s'\n",
-			ast_channel_name(c0), ast_channel_name(c1));
+			ast_channel_name(c_dst), ast_channel_name(c_src));
 	}
 
 done:
-	ast_channel_unlock(c0);
-	ast_channel_unlock(c1);
+	ast_channel_unlock(c_dst);
+	ast_channel_unlock(c_src);
 
-	ast_format_cap_destroy(cap0);
-	ast_format_cap_destroy(cap1);
+	ast_format_cap_destroy(cap_dst);
+	ast_format_cap_destroy(cap_src);
 
-	unref_instance_cond(&instance0);
-	unref_instance_cond(&instance1);
-	unref_instance_cond(&vinstance0);
-	unref_instance_cond(&vinstance1);
-	unref_instance_cond(&tinstance0);
-	unref_instance_cond(&tinstance1);
+	unref_instance_cond(&instance_dst);
+	unref_instance_cond(&instance_src);
+	unref_instance_cond(&vinstance_dst);
+	unref_instance_cond(&vinstance_src);
+	unref_instance_cond(&tinstance_dst);
+	unref_instance_cond(&tinstance_src);
 }
 
 int ast_rtp_instance_early_bridge(struct ast_channel *c0, struct ast_channel *c1)
--- main/security_events.c
+++ main/security_events.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 376471 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400421 $")
 
 #include "asterisk/utils.h"
 #include "asterisk/strings.h"
@@ -341,14 +341,14 @@
 		{ AST_EVENT_IE_SESSION_ID, SEC_EVT_FIELD(common, session_id) },
 		{ AST_EVENT_IE_LOCAL_ADDR, SEC_EVT_FIELD(common, local_addr) },
 		{ AST_EVENT_IE_REMOTE_ADDR, SEC_EVT_FIELD(common, remote_addr) },
-		{ AST_EVENT_IE_CHALLENGE, SEC_EVT_FIELD(inval_password, challenge) },
-		{ AST_EVENT_IE_RECEIVED_CHALLENGE, SEC_EVT_FIELD(inval_password, received_challenge) },
-		{ AST_EVENT_IE_RECEIVED_HASH, SEC_EVT_FIELD(inval_password, received_hash) },
 		{ AST_EVENT_IE_END, 0 }
 	},
 	.optional_ies = {
 		{ AST_EVENT_IE_MODULE, SEC_EVT_FIELD(common, module) },
 		{ AST_EVENT_IE_SESSION_TV, SEC_EVT_FIELD(common, session_tv) },
+		{ AST_EVENT_IE_CHALLENGE, SEC_EVT_FIELD(inval_password, challenge) },
+		{ AST_EVENT_IE_RECEIVED_CHALLENGE, SEC_EVT_FIELD(inval_password, received_challenge) },
+		{ AST_EVENT_IE_RECEIVED_HASH, SEC_EVT_FIELD(inval_password, received_hash) },
 		{ AST_EVENT_IE_END, 0 }
 	},
 },
--- main/test.c
+++ main/test.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370598 $");
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401661 $");
 
 #include "asterisk/_private.h"
 
@@ -931,6 +931,11 @@
 	return 0;
 }
 
+static void test_shutdown(void)
+{
+	ast_cli_unregister_multiple(test_cli, ARRAY_LEN(test_cli));
+}
+
 #endif /* TEST_FRAMEWORK */
 
 int ast_test_init()
@@ -938,6 +943,7 @@
 #ifdef TEST_FRAMEWORK
 	/* Register cli commands */
 	ast_cli_register_multiple(test_cli, ARRAY_LEN(test_cli));
+	ast_register_atexit(test_shutdown);
 #endif
 
 	return 0;
--- main/translate.c
+++ main/translate.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401620 $")
 
 #include <sys/time.h>
 #include <sys/resource.h>
@@ -540,6 +540,10 @@
 		/* Predict next outgoing timestamp from samples in this
 		   frame. */
 		path->nextout = ast_tvadd(path->nextout, ast_samp2tv(out->samples, ast_format_rate(&out->subclass.format)));
+		if (f->samples != out->samples && ast_test_flag(out, AST_FRFLAG_HAS_TIMING_INFO)) {
+			ast_debug(4, "Sample size different %u vs %u\n", f->samples, out->samples);
+			ast_clear_flag(out, AST_FRFLAG_HAS_TIMING_INFO);
+		}
 	} else {
 		out->delivery = ast_tv(0, 0);
 		ast_set2_flag(out, has_timing_info, AST_FRFLAG_HAS_TIMING_INFO);
--- main/utils.c
+++ main/utils.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398649 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401830 $")
 
 #include <ctype.h>
 #include <sys/stat.h>
@@ -1025,9 +1025,6 @@
 	struct thr_lock_info *lock_info;
 	struct ast_str *str;
 
-	if (!(str = ast_str_create(4096)))
-		return CLI_FAILURE;
-
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "core show locks";
@@ -1041,7 +1038,10 @@
 		return NULL;
 	}
 
-	ast_str_append(&str, 0, "\n"
+	if (!(str = ast_str_create(4096)))
+		return CLI_FAILURE;
+
+	ast_str_append(&str, 0, "\n" 
 	               "=======================================================================\n"
 	               "=== %s\n"
 	               "=== Currently Held Locks\n"
@@ -2163,6 +2163,17 @@
 	return 0;
 }
 
+static void utils_shutdown(void)
+{
+#ifdef HAVE_DEV_URANDOM
+	close(dev_urandom_fd);
+	dev_urandom_fd = -1;
+#endif
+#if defined(DEBUG_THREADS) && !defined(LOW_MEMORY)
+	ast_cli_unregister_multiple(utils_cli, ARRAY_LEN(utils_cli));
+#endif
+}
+
 int ast_utils_init(void)
 {
 #ifdef HAVE_DEV_URANDOM
@@ -2174,6 +2185,7 @@
 	ast_cli_register_multiple(utils_cli, ARRAY_LEN(utils_cli));
 #endif
 #endif
+	ast_register_atexit(utils_shutdown);
 	return 0;
 }
 
--- Makefile
+++ Makefile
@@ -564,6 +564,7 @@
 	$(INSTALL) -m 644 doc/core-*.xml "$(DESTDIR)$(ASTDATADIR)/documentation"
 	$(INSTALL) -m 644 doc/appdocsxml.dtd "$(DESTDIR)$(ASTDATADIR)/documentation"
 	$(INSTALL) -m 644 doc/asterisk.8 "$(DESTDIR)$(ASTMANDIR)/man8"
+	$(INSTALL) -m 644 doc/astdb*.8 "$(DESTDIR)$(ASTMANDIR)/man8"
 	$(INSTALL) -m 644 contrib/scripts/astgenkey.8 "$(DESTDIR)$(ASTMANDIR)/man8"
 	$(INSTALL) -m 644 contrib/scripts/autosupport.8 "$(DESTDIR)$(ASTMANDIR)/man8"
 	$(INSTALL) -m 644 contrib/scripts/safe_asterisk.8 "$(DESTDIR)$(ASTMANDIR)/man8"
--- res/res_jabber.c
+++ res/res_jabber.c
@@ -40,7 +40,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398577 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401120 $")
 
 #include <ctype.h>
 #include <iksemel.h>
@@ -3567,7 +3567,7 @@
 	iks *orig_pubsub = iks_find(pak->x, "pubsub");
 	struct aji_client *client;
 	if (!orig_pubsub) {
-		ast_log(LOG_ERROR, "Error isn't a PubSub error, why are we here?\n");
+		ast_debug(1, "Error isn't a PubSub error, why are we here?\n");
 		return IKS_FILTER_EAT;
 	}
 	orig_request = iks_child(orig_pubsub);
--- res/res_rtp_asterisk.c
+++ res/res_rtp_asterisk.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397604 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401620 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -96,6 +96,7 @@
 #define RTCP_PT_APP     204
 
 #define RTP_MTU		1200
+#define DTMF_SAMPLE_RATE_MS    8 /*!< DTMF samples per millisecond */
 
 #define DEFAULT_DTMF_TIMEOUT (150 * (8000 / 1000))	/*!< samples */
 
@@ -1660,7 +1661,13 @@
 	unsigned int count = PJ_ARRAY_SIZE(address), pos = 0;
 
 	/* Add all the local interface IP addresses */
-	pj_enum_ip_interface(ast_sockaddr_is_ipv4(addr) ? pj_AF_INET() : pj_AF_INET6(), &count, address);
+	if (ast_sockaddr_is_ipv4(addr)) {
+		pj_enum_ip_interface(pj_AF_INET(), &count, address);
+	} else if (ast_sockaddr_is_any(addr)) {
+		pj_enum_ip_interface(pj_AF_UNSPEC(), &count, address);
+	} else {
+		pj_enum_ip_interface(pj_AF_INET6(), &count, address);
+	}
 
 	for (pos = 0; pos < count; pos++) {
 		pj_sockaddr_set_port(&address[pos], port);
@@ -1719,6 +1726,35 @@
 }
 #endif
 
+/*!
+ * \internal
+ * \brief Calculates the elapsed time from issue of the first tx packet in an
+ *        rtp session and a specified time
+ *
+ * \param rtp pointer to the rtp struct with the transmitted rtp packet
+ * \param delivery time of delivery - if NULL or zero value, will be ast_tvnow()
+ *
+ * \return time elapsed in milliseconds
+ */
+static unsigned int calc_txstamp(struct ast_rtp *rtp, struct timeval *delivery)
+{
+	struct timeval t;
+	long ms;
+
+	if (ast_tvzero(rtp->txcore)) {
+		rtp->txcore = ast_tvnow();
+		rtp->txcore.tv_usec -= rtp->txcore.tv_usec % 20000;
+	}
+
+	t = (delivery && !ast_tvzero(*delivery)) ? *delivery : ast_tvnow();
+	if ((ms = ast_tvdiff_ms(t, rtp->txcore)) < 0) {
+		ms = 0;
+	}
+	rtp->txcore = t;
+
+	return (unsigned int) ms;
+}
+
 static int ast_rtp_new(struct ast_rtp_instance *instance,
 		       struct ast_sched_context *sched, struct ast_sockaddr *addr,
 		       void *data)
@@ -1952,6 +1988,7 @@
 
 	rtp->dtmfmute = ast_tvadd(ast_tvnow(), ast_tv(0, 500000));
 	rtp->send_duration = 160;
+	rtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;
 	rtp->lastdigitts = rtp->lastts + rtp->send_duration;
 
 	/* Create the actual packet that we will be sending */
@@ -2036,6 +2073,7 @@
 	/* And now we increment some values for the next time we swing by */
 	rtp->seqno++;
 	rtp->send_duration += 160;
+	rtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;
 
 	return 0;
 }
@@ -2115,7 +2153,7 @@
 	res = 0;
 
 	/* Oh and we can't forget to turn off the stuff that says we are sending DTMF */
-	rtp->lastts += rtp->send_duration;
+	rtp->lastts += calc_txstamp(rtp, NULL) * DTMF_SAMPLE_RATE_MS;
 cleanup:
 	rtp->sending_digit = 0;
 	rtp->send_digit = 0;
@@ -2165,25 +2203,6 @@
 	return;
 }
 
-static unsigned int calc_txstamp(struct ast_rtp *rtp, struct timeval *delivery)
-{
-	struct timeval t;
-	long ms;
-
-	if (ast_tvzero(rtp->txcore)) {
-		rtp->txcore = ast_tvnow();
-		rtp->txcore.tv_usec -= rtp->txcore.tv_usec % 20000;
-	}
-
-	t = (delivery && !ast_tvzero(*delivery)) ? *delivery : ast_tvnow();
-	if ((ms = ast_tvdiff_ms(t, rtp->txcore)) < 0) {
-		ms = 0;
-	}
-	rtp->txcore = t;
-
-	return (unsigned int) ms;
-}
-
 static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw)
 {
 	unsigned int sec, usec, frac;
@@ -3654,8 +3673,16 @@
 		f = ast_frisolate(&srcupdate);
 		AST_LIST_INSERT_TAIL(&frames, f, frame_list);
 
+		rtp->seedrxseqno = 0;
+		rtp->rxcount = 0;
+		rtp->cycles = 0;
+		rtp->lastrxseqno = 0;
 		rtp->last_seqno = 0;
 		rtp->last_end_timestamp = 0;
+		if (rtp->rtcp) {
+			rtp->rtcp->expected_prior = 0;
+			rtp->rtcp->received_prior = 0;
+		}
 	}
 
 	rtp->rxssrc = ssrc;
--- res/res_rtp_multicast.c
+++ res/res_rtp_multicast.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 385689 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400394 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -260,15 +260,15 @@
 	/* Construct an RTP header for our packet */
 	rtpheader = (unsigned char *)(f->data.ptr - hdrlen);
 	put_unaligned_uint32(rtpheader, htonl((2 << 30) | (codec << 16) | (multicast->seqno)));
-	put_unaligned_uint32(rtpheader + 4, htonl(multicast->lastts));
 	
 	if (ast_test_flag(f, AST_FRFLAG_HAS_TIMING_INFO)) {
 		put_unaligned_uint32(rtpheader + 4, htonl(f->ts * 8));
-	} 
-	else {
-		put_unaligned_uint32(rtpheader + 8, htonl(multicast->ssrc));
+	} else {
+		put_unaligned_uint32(rtpheader + 4, htonl(multicast->lastts));
 	}
 
+	put_unaligned_uint32(rtpheader + 8, htonl(multicast->ssrc));
+
 	/* Increment sequence number and wrap to 0 if it overflows 16 bits. */
 	multicast->seqno = 0xFFFF & (multicast->seqno + 1);
 
--- res/res_xmpp.c
+++ res/res_xmpp.c
@@ -39,7 +39,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398618 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401120 $")
 
 #include <ctype.h>
 #include <iksemel.h>
@@ -1382,7 +1382,7 @@
 	}
 
 	if (!orig_pubsub) {
-		ast_log(LOG_ERROR, "Error isn't a PubSub error, why are we here?\n");
+		ast_debug(1, "Error isn't a PubSub error, why are we here?\n");
 		return IKS_FILTER_EAT;
 	}
 
--- tests/test_dlinklists.c
+++ tests/test_dlinklists.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 338557 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401661 $")
 
 #include "asterisk/file.h"
 #include "asterisk/channel.h"
@@ -337,6 +337,7 @@
 
 		if (e == b) {
 			AST_DLLIST_REMOVE_CURRENT(list);  /* C A */
+			free(b);
 			print_list(tc, "C <=> A");
 		}
 		if (e == a) {
@@ -348,6 +349,7 @@
 	AST_DLLIST_TRAVERSE_SAFE_END;
 	print_list(tc, "C <=> A <=> D");
 
+	destroy_test_container(tc);
 }
 
 static int unload_module(void)
--- tests/test_linkedlists.c
+++ tests/test_linkedlists.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401791 $")
 
 #include "asterisk/module.h"
 #include "asterisk/test.h"
@@ -105,19 +105,16 @@
 #define MATCH_OR_FAIL(list, val, retbuf) \
 	if (list_expect(list, val, &retbuf)) { \
 		ast_test_status_update(test, "Expected: %s, Got: %s\n", val, ast_str_buffer(retbuf)); \
-		ast_free(retbuf); \
 		return AST_TEST_FAIL; \
 	}
 
 #define MATCH_OR_FAIL_DBL(list, val, retbuf) \
 	if (dbl_list_expect_forward(list, val, &retbuf)) { \
 		ast_test_status_update(test, "Expected: %s, Got: %s\n", val, ast_str_buffer(retbuf)); \
-		ast_free(retbuf); \
 		return AST_TEST_FAIL; \
 	} \
 	if (dbl_list_expect_reverse(list, val, &retbuf)) { \
 		ast_test_status_update(test, "Expected reverse of: %s, Got: %s\n", val, ast_str_buffer(retbuf)); \
-		ast_free(retbuf); \
 		return AST_TEST_FAIL; \
 	}
 
@@ -129,7 +126,7 @@
 
 AST_TEST_DEFINE(single_ll_tests)
 {
-	struct ast_str *buf;
+	RAII_VAR(struct ast_str *, buf, NULL, ast_free);
 	struct test_llist test_list = { 0, };
 	struct test_llist other_list = { 0, };
 	struct test_val *bogus;
@@ -340,7 +337,7 @@
 
 AST_TEST_DEFINE(double_ll_tests)
 {
-	struct ast_str *buf;
+	RAII_VAR(struct ast_str *, buf, NULL, ast_free);
 	struct test_dbl_llist test_list = { 0, };
 	struct test_dbl_llist other_list = { 0, };
 	struct test_val *bogus;
--- utils/clicompat.c
+++ utils/clicompat.c
@@ -1,6 +1,6 @@
 /*
  * Stubs for some cli functions used by the test routines.
- * $Revision: 92103 $
+ * $Revision: 401935 $
  */
 void ast_cli(int fd, const char *fmt, ...);
 void ast_cli(int fd, const char *fmt, ...)
@@ -9,8 +9,18 @@
 
 struct ast_cli_entry;
 
+int ast_register_atexit(void (*func)(void));
+int ast_register_atexit(void (*func)(void))
+{
+	return 0;
+}
 int ast_cli_register_multiple(struct ast_cli_entry *e, int len);
 int ast_cli_register_multiple(struct ast_cli_entry *e, int len)
 {
 	return 0;
 }
+int ast_cli_unregister_multiple(struct ast_cli_entry *e, int len);
+int ast_cli_unregister_multiple(struct ast_cli_entry *e, int len)
+{
+	return 0;
+}
