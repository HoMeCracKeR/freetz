--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400741 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -1342,6 +1342,9 @@
 
 	ast_channel_internal_bridge_set(conference_bridge->playback_chan, conference_bridge->bridge);
 
+	/* To make sure playback_chan has the same language of that profile */
+	ast_channel_language_set(conference_bridge->playback_chan, conference_bridge->b_profile.language);
+
 	if (ast_call(conference_bridge->playback_chan, "", 0)) {
 		ast_hangup(conference_bridge->playback_chan);
 		conference_bridge->playback_chan = NULL;
--- apps/app_queue.c
+++ apps/app_queue.c
@@ -63,7 +63,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398885 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400623 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -7192,7 +7192,7 @@
 			}
 		} else if (qe.valid_digits) {
 			ast_queue_log(args.queuename, ast_channel_uniqueid(chan), "NONE", "EXITWITHKEY",
-				"%s|%d", qe.digits, qe.pos);
+				"%s|%d|%d|%ld", qe.digits, qe.pos, qe.opos, (long) time(NULL) - qe.start);
 		}
 	}
 
--- apps/confbridge/conf_config_parser.c
+++ apps/confbridge/conf_config_parser.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400741 $")
 #include "asterisk/logger.h"
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -852,6 +852,7 @@
 
 	ast_cli(a->fd,"--------------------------------------------\n");
 	ast_cli(a->fd,"Name:                 %s\n", b_profile.name);
+	ast_cli(a->fd,"Language:             %s\n", b_profile.language);
 
 	if (b_profile.internal_sample_rate) {
 		snprintf(tmp, sizeof(tmp), "%d", b_profile.internal_sample_rate);
@@ -1306,7 +1307,7 @@
 		ao2_link(cfg->bridge_profiles, bridge_profile);
 	}
 
-	user_profile = ao2_find(cfg->bridge_profiles, DEFAULT_USER_PROFILE, OBJ_KEY);
+	user_profile = ao2_find(cfg->user_profiles, DEFAULT_USER_PROFILE, OBJ_KEY);
 	if (!user_profile) {
 		user_profile = user_profile_alloc(DEFAULT_USER_PROFILE);
 		if (!user_profile) {
@@ -1364,6 +1365,7 @@
 	aco_option_register_custom(&cfg_info, "video_mode", ACO_EXACT, bridge_types, NULL, video_mode_handler, 0);
 	aco_option_register(&cfg_info, "max_members", ACO_EXACT, bridge_types, "0", OPT_UINT_T, 0, FLDSET(struct bridge_profile, max_members));
 	aco_option_register(&cfg_info, "record_file", ACO_EXACT, bridge_types, NULL, OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct bridge_profile, rec_file));
+	aco_option_register(&cfg_info, "language", ACO_EXACT, bridge_types, "en", OPT_CHAR_ARRAY_T, 0, CHARFLDSET(struct bridge_profile, language));
 	aco_option_register_custom(&cfg_info, "^sound_", ACO_REGEX, bridge_types, NULL, sound_option_handler, 0);
 	/* This option should only be used with the CONFBRIDGE dialplan function */
 	aco_option_register_custom(&cfg_info, "template", ACO_EXACT, bridge_types, NULL, bridge_template_handler, 0);
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -191,6 +191,7 @@
 
 struct bridge_profile {
 	char name[64];
+	char language[MAX_LANGUAGE];		  /*!< Language used for playback_chan */
 	char rec_file[PATH_MAX];
 	unsigned int flags;
 	unsigned int max_members;          /*!< The maximum number of participants allowed in the conference */
--- channels/chan_dahdi.c
+++ channels/chan_dahdi.c
@@ -49,7 +49,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397744 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399834 $")
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <pthread.h>
@@ -17065,8 +17065,10 @@
 
 #ifdef HAVE_PRI
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (pris[i].pri.master != AST_PTHREADT_NULL)
+		if (pris[i].pri.master != AST_PTHREADT_NULL) {
 			pthread_cancel(pris[i].pri.master);
+			pthread_kill(pris[i].pri.master, SIGURG);
+		}
 	}
 	ast_cli_unregister_multiple(dahdi_pri_cli, ARRAY_LEN(dahdi_pri_cli));
 	ast_unregister_application(dahdi_send_keypad_facility_app);
@@ -17076,9 +17078,11 @@
 #endif
 #if defined(HAVE_SS7)
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (linksets[i].ss7.master != AST_PTHREADT_NULL)
+		if (linksets[i].ss7.master != AST_PTHREADT_NULL) {
 			pthread_cancel(linksets[i].ss7.master);
+			pthread_kill(linksets[i].ss7.master, SIGURG);
 		}
+	}
 	ast_cli_unregister_multiple(dahdi_ss7_cli, ARRAY_LEN(dahdi_ss7_cli));
 #endif	/* defined(HAVE_SS7) */
 #if defined(HAVE_OPENR2)
@@ -17122,8 +17126,9 @@
 
 #if defined(HAVE_PRI)
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (pris[i].pri.master && (pris[i].pri.master != AST_PTHREADT_NULL))
+		if (pris[i].pri.master && (pris[i].pri.master != AST_PTHREADT_NULL)) {
 			pthread_join(pris[i].pri.master, NULL);
+		}
 		for (j = 0; j < SIG_PRI_NUM_DCHANS; j++) {
 			dahdi_close_pri_fd(&(pris[i]), j);
 		}
@@ -17138,8 +17143,9 @@
 
 #if defined(HAVE_SS7)
 	for (i = 0; i < NUM_SPANS; i++) {
-		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL))
+		if (linksets[i].ss7.master && (linksets[i].ss7.master != AST_PTHREADT_NULL)) {
 			pthread_join(linksets[i].ss7.master, NULL);
+		}
 		for (j = 0; j < SIG_SS7_NUM_DCHANS; j++) {
 			dahdi_close_ss7_fd(&(linksets[i]), j);
 		}
--- channels/chan_iax2.c
+++ channels/chan_iax2.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399159 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400315 $")
 
 #include <sys/mman.h>
 #include <dirent.h>
@@ -5655,35 +5655,44 @@
 			break;
 		}
 		other = (who == c0) ? c1 : c0;  /* the 'other' channel */
-		if ((f->frametype == AST_FRAME_CONTROL)) {
-			if (f->subclass.integer == AST_CONTROL_PVT_CAUSE_CODE) {
+		if (f->frametype == AST_FRAME_CONTROL && !(flags & AST_BRIDGE_IGNORE_SIGS)) {
+			switch (f->subclass.integer) {
+			case AST_CONTROL_VIDUPDATE:
+			case AST_CONTROL_SRCUPDATE:
+			case AST_CONTROL_SRCCHANGE:
+			case AST_CONTROL_T38_PARAMETERS:
+				ast_write(other, f);
+				break;
+			case AST_CONTROL_PVT_CAUSE_CODE:
 				ast_channel_hangupcause_hash_set(other, f->data.ptr, f->datalen);
-			} else if (!(flags & AST_BRIDGE_IGNORE_SIGS)
-				&& (f->subclass.integer != AST_CONTROL_SRCUPDATE)) {
+				break;
+			default:
 				*fo = f;
 				*rc = who;
-				res =  AST_BRIDGE_COMPLETE;
+				res = AST_BRIDGE_COMPLETE;
 				break;
 			}
-		}
-		if ((f->frametype == AST_FRAME_VOICE) ||
-			(f->frametype == AST_FRAME_TEXT) ||
-			(f->frametype == AST_FRAME_VIDEO) || 
-			(f->frametype == AST_FRAME_IMAGE) ||
-			(f->frametype == AST_FRAME_DTMF) ||
-			(f->frametype == AST_FRAME_CONTROL && f->subclass.integer != AST_CONTROL_PVT_CAUSE_CODE)) {
+			if (res == AST_BRIDGE_COMPLETE) {
+				break;
+			}
+		} else if (f->frametype == AST_FRAME_VOICE
+			|| f->frametype == AST_FRAME_TEXT
+			|| f->frametype == AST_FRAME_VIDEO
+			|| f->frametype == AST_FRAME_IMAGE) {
+			ast_write(other, f);
+		} else if (f->frametype == AST_FRAME_DTMF) {
 			/* monitored dtmf take out of the bridge.
 			 * check if we monitor the specific source.
 			 */
 			int monitored_source = (who == c0) ? AST_BRIDGE_DTMF_CHANNEL_0 : AST_BRIDGE_DTMF_CHANNEL_1;
-			if (f->frametype == AST_FRAME_DTMF && (flags & monitored_source)) {
+
+			if (flags & monitored_source) {
 				*rc = who;
 				*fo = f;
 				res = AST_BRIDGE_COMPLETE;
 				/* Remove from native mode */
 				break;
 			}
-			/* everything else goes to the other side */
 			ast_write(other, f);
 		}
 		ast_frfree(f);
@@ -8718,7 +8727,7 @@
 		realtime_update_peer(peer->name, &peer->addr, 0);
 	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "ChannelType: IAX2\r\nPeer: IAX2/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n", peer->name);
 	/* modify entry in peercnts table as _not_ registered */
-	peercnt_modify(0, 0, &peer->addr);
+	peercnt_modify((unsigned char) 0, 0, &peer->addr);
 	/* Reset the address */
 	memset(&peer->addr, 0, sizeof(peer->addr));
 	/* Reset expiry value */
@@ -8860,7 +8869,7 @@
 		}
 
 		/* modify entry in peercnts table as _not_ registered */
-		peercnt_modify(0, 0, &p->addr);
+		peercnt_modify((unsigned char) 0, 0, &p->addr);
 
 		/* Stash the IP address from which they registered */
 		ast_sockaddr_from_sin(&p->addr, sin);
@@ -8888,7 +8897,7 @@
 
 	/* modify entry in peercnts table as registered */
 	if (p->maxcallno) {
-		peercnt_modify(1, p->maxcallno, &p->addr);
+		peercnt_modify((unsigned char) 1, p->maxcallno, &p->addr);
 	}
 
 	/* Make sure our call still exists, an INVAL at the right point may make it go away */
@@ -12681,7 +12690,7 @@
 			peer->pokefreqok = DEFAULT_FREQ_OK;
 			peer->pokefreqnotok = DEFAULT_FREQ_NOTOK;
 			peer->maxcallno = 0;
-			peercnt_modify(0, 0, &peer->addr);
+			peercnt_modify((unsigned char) 0, 0, &peer->addr);
 			peer->calltoken_required = CALLTOKEN_DEFAULT;
 			ast_string_field_set(peer,context,"");
 			ast_string_field_set(peer,peercontext,"");
@@ -12869,7 +12878,7 @@
 				if (sscanf(v->value, "%10hu", &peer->maxcallno) != 1) {
 					ast_log(LOG_WARNING, "maxcallnumbers must be set to a valid number. %s is not valid at line %d.\n", v->value, v->lineno);
 				} else {
-					peercnt_modify(1, peer->maxcallno, &peer->addr);
+					peercnt_modify((unsigned char) 1, peer->maxcallno, &peer->addr);
 				}
 			} else if (!strcasecmp(v->name, "requirecalltoken")) {
 				/* default is required unless in optional ip list */
--- channels/chan_sip.c
+++ channels/chan_sip.c
@@ -210,7 +210,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398986 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400470 $")
 
 #include <signal.h>
 #include <sys/signal.h>
@@ -770,6 +770,7 @@
 static int global_rtpkeepalive;     /*!< Send RTP keepalives */
 static int global_reg_timeout;      /*!< Global time between attempts for outbound registrations */
 static int global_regattempts_max;  /*!< Registration attempts before giving up */
+static int global_reg_retry_403;    /*!< Treat 403 responses to registrations as 401 responses */
 static int global_shrinkcallerid;   /*!< enable or disable shrinking of caller id  */
 static int global_callcounter;      /*!< Enable call counters for all devices. This is currently enabled by setting the peer
                                      *   call-limit to INT_MAX. When we remove the call-limit from the code, we can make it
@@ -13282,13 +13283,9 @@
 		/* Our T.38 end is */
 		ast_udptl_get_us(p->udptl, &udptladdr);
 
-		/* Determine T.38 UDPTL destination */
-		if (!ast_sockaddr_isnull(&p->udptlredirip)) {
-			ast_sockaddr_copy(&udptldest, &p->udptlredirip);
-		} else {
-			ast_sockaddr_copy(&udptldest, &p->ourip);
-			ast_sockaddr_set_port(&udptldest, ast_sockaddr_port(&udptladdr));
-		}
+		/* We don't use directmedia for T.38, so keep the destination the same as our IP address. */
+		ast_sockaddr_copy(&udptldest, &p->ourip);
+		ast_sockaddr_set_port(&udptldest, ast_sockaddr_port(&udptladdr));
 
 		if (debug) {
 			ast_debug(1, "T.38 UDPTL is at %s port %d\n", ast_sockaddr_stringify_addr(&p->ourip), ast_sockaddr_port(&udptladdr));
@@ -13299,9 +13296,9 @@
 
 		ast_str_append(&m_modem, 0, "m=image %d udptl t38\r\n", ast_sockaddr_port(&udptldest));
 
-		if (!ast_sockaddr_cmp(&udptldest, &dest)) {
+		if (ast_sockaddr_cmp(&udptldest, &dest)) {
 			ast_str_append(&m_modem, 0, "c=IN %s %s\r\n",
-					(ast_sockaddr_is_ipv6(&dest) && !ast_sockaddr_is_ipv4_mapped(&dest)) ?
+					(ast_sockaddr_is_ipv6(&udptldest) && !ast_sockaddr_is_ipv4_mapped(&udptldest)) ?
 					"IP6" : "IP4", ast_sockaddr_stringify_addr_remote(&udptldest));
 		}
 
@@ -15912,6 +15909,14 @@
 		}
 	}
 
+	if (expire > max_expiry) {
+		expire = max_expiry;
+	}
+	if (expire < min_expiry && expire != 0) {
+		expire = min_expiry;
+	}
+	pvt->expiry = expire;
+
 	copy_socket_data(&pvt->socket, &req->socket);
 
 	do {
@@ -16051,12 +16056,6 @@
 	AST_SCHED_DEL_UNREF(sched, peer->expire,
 			sip_unref_peer(peer, "remove register expire ref"));
 
-	if (expire > max_expiry) {
-		expire = max_expiry;
-	}
-	if (expire < min_expiry) {
-		expire = min_expiry;
-	}
 	if (peer->is_realtime && !ast_test_flag(&peer->flags[1], SIP_PAGE2_RTCACHEFRIENDS)) {
 		peer->expire = -1;
 	} else {
@@ -16066,7 +16065,6 @@
 			sip_unref_peer(peer, "remote registration ref");
 		}
 	}
-	pvt->expiry = expire;
 	snprintf(data, sizeof(data), "%s:%d:%s:%s", ast_sockaddr_stringify(&peer->addr),
 		 expire, peer->username, peer->fullcontact);
 	/* We might not immediately be able to reconnect via TCP, but try caching it anyhow */
@@ -16919,7 +16917,10 @@
 						break;
 					case PARSE_REGISTER_UPDATE:
 						ast_string_field_set(p, fullcontact, peer->fullcontact);
-						update_peer(peer, p->expiry);
+						/* If expiry is 0, peer has been unregistered already */
+						if (p->expiry != 0) {
+							update_peer(peer, p->expiry);
+						}
 						/* Say OK and ask subsystem to retransmit msg counter */
 						transmit_response_with_date(p, "200 OK", req);
 						send_mwi = 1;
@@ -18276,9 +18277,9 @@
 					      int sipmethod, const char *uri, enum xmittype reliable,
 					      struct ast_sockaddr *addr, struct sip_peer **authpeer)
 {
-	char from[256] = "", *of, *name, *unused_password, *domain;
+	char from[256], *of, *name, *unused_password, *domain;
 	enum check_auth_result res = AUTH_DONT_KNOW;
-	char calleridname[50];
+	char calleridname[256];
 	char *uri2 = ast_strdupa(uri);
 
 	terminate_uri(uri2);	/* trim extra stuff */
@@ -20683,6 +20684,7 @@
 	ast_cli(a->fd, "  Sub. max duration:      %d secs\n", max_subexpiry);
 	ast_cli(a->fd, "  Outbound reg. timeout:  %d secs\n", global_reg_timeout);
 	ast_cli(a->fd, "  Outbound reg. attempts: %d\n", global_regattempts_max);
+	ast_cli(a->fd, "  Outbound reg. retry 403:%d\n", global_reg_retry_403);
 	ast_cli(a->fd, "  Notify ringing state:   %s\n", AST_CLI_YESNO(sip_cfg.notifyringing));
 	if (sip_cfg.notifyringing) {
 		ast_cli(a->fd, "    Include CID:          %s%s\n",
@@ -22788,6 +22790,15 @@
 					ast_set_flag(&p->flags[0], SIP_PENDINGBYE);
 				}
 			ast_rtp_instance_activate(p->rtp);
+		} else if (!reinvite) {
+			struct ast_sockaddr remote_address = {{0,}};
+
+			ast_rtp_instance_get_remote_address(p->rtp, &remote_address);
+			if (ast_sockaddr_isnull(&remote_address) || (!ast_strlen_zero(p->theirprovtag) && strcmp(p->theirtag, p->theirprovtag))) {
+				ast_log(LOG_WARNING, "Received response: \"200 OK\" from '%s' without SDP\n", p->relatedpeer->name);
+				ast_set_flag(&p->flags[0], SIP_PENDINGBYE);
+				ast_rtp_instance_activate(p->rtp);
+			}
 		}
 
 		if (!req->ignore && p->owner) {
@@ -23407,8 +23418,9 @@
 			}
 			tmptmp = strcasestr(contact, "expires=");
 			if (tmptmp) {
-				if (sscanf(tmptmp + 8, "%30d;", &expires) != 1)
+				if (sscanf(tmptmp + 8, "%30d", &expires) != 1) {
 					expires = 0;
+				}
 			}
 			
 		}
@@ -23710,7 +23722,11 @@
 
 		gettag(req, "To", tag, sizeof(tag));
 		ast_string_field_set(p, theirtag, tag);
+	} else {
+		/* Store theirtag to track for changes when 200 responses to invites are received without SDP */
+		ast_string_field_set(p, theirprovtag, p->theirtag);
 	}
+
 	/* This needs to be configurable on a channel/peer level,
 	   not mandatory for all communication. Sadly enough, NAT implementations
 	   are not so stable so we can always rely on these headers.
@@ -31377,6 +31393,7 @@
 	sip_cfg.compactheaders = DEFAULT_COMPACTHEADERS;
 	global_reg_timeout = DEFAULT_REGISTRATION_TIMEOUT;
 	global_regattempts_max = 0;
+	global_reg_retry_403 = 0;
 	sip_cfg.pedanticsipchecking = DEFAULT_PEDANTIC;
 	sip_cfg.autocreatepeer = DEFAULT_AUTOCREATEPEER;
 	global_autoframing = 0;
@@ -31764,6 +31781,8 @@
 			}
 		} else if (!strcasecmp(v->name, "registerattempts")) {
 			global_regattempts_max = atoi(v->value);
+		} else if (!strcasecmp(v->name, "register_retry_403")) {
+			global_reg_retry_403 = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "bindaddr") || !strcasecmp(v->name, "udpbindaddr")) {
 			if (ast_parse_arg(v->value, PARSE_ADDR, &bindaddr)) {
 				ast_log(LOG_WARNING, "Invalid address: %s\n", v->value);
--- channels/sig_ss7.c
+++ channels/sig_ss7.c
@@ -788,7 +788,9 @@
 	ss7_event *e = NULL;
 	struct sig_ss7_chan *p;
 	struct pollfd pollers[SIG_SS7_NUM_DCHANS];
-	int nextms = 0;
+	int nextms;
+
+#define SS7_MAX_POLL	60000	/* Maximum poll time in ms. */
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
 
@@ -813,6 +815,11 @@
 			}
 			nextms = tv.tv_sec * 1000;
 			nextms += tv.tv_usec / 1000;
+			if (SS7_MAX_POLL < nextms) {
+				nextms = SS7_MAX_POLL;
+			}
+		} else {
+			nextms = SS7_MAX_POLL;
 		}
 
 		for (i = 0; i < linkset->numsigchans; i++) {
--- channels/sip/include/sip.h
+++ channels/sip/include/sip.h
@@ -1038,6 +1038,7 @@
 		AST_STRING_FIELD(rdnis);        /*!< Referring DNIS */
 		AST_STRING_FIELD(redircause);   /*!< Referring cause */
 		AST_STRING_FIELD(theirtag);     /*!< Their tag */
+		AST_STRING_FIELD(theirprovtag); /*!< Provisional their tag, used when evaluating responses to invites */
 		AST_STRING_FIELD(tag);          /*!< Our tag for this session */
 		AST_STRING_FIELD(username);     /*!< [user] name */
 		AST_STRING_FIELD(peername);     /*!< [peer] name, not set if [user] */
--- channels/sip/reqresp_parser.c
+++ channels/sip/reqresp_parser.c
@@ -25,7 +25,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 379393 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400014 $")
 
 #include "include/sip.h"
 #include "include/sip_utils.h"
@@ -806,7 +806,7 @@
 int get_name_and_number(const char *hdr, char **name, char **number)
 {
 	char header[256];
-	char tmp_name[50];
+	char tmp_name[256];
 	char *tmp_number = NULL;
 	char *hostport = NULL;
 	char *dummy = NULL;
--- configs/confbridge.conf.sample
+++ configs/confbridge.conf.sample
@@ -197,6 +197,9 @@
                            ;               is the single source of video distribution among all participants. If
                            ;               that user leaves, the marked user to join after them becomes the source.
 
+;language=en               ; Set the language used for announcements to the conference.
+                           ; Default is en (English).
+
 ; All sounds in the conference are customizable using the bridge profile options below.
 ; Simply state the option followed by the filename or full path of the filename after
 ; the option.  Example: sound_had_joined=conf-hasjoin  This will play the conf-hasjoin
--- configs/sip.conf.sample
+++ configs/sip.conf.sample
@@ -774,6 +774,9 @@
                                 ; 0 = continue forever, hammering the other server
                                 ; until it accepts the registration
                                 ; Default is 0 tries, continue forever
+;register_retry_403=yes         ; Treat 403 responses to registrations as if they were
+                                ; 401 responses and continue retrying according to normal
+                                ; retry rules.
 
 ;----------------------------------------- OUTBOUND MWI SUBSCRIPTIONS -------------------------
 ; Asterisk can subscribe to receive the MWI from another SIP server and store it locally for retrieval
--- configure
+++ configure
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.ac Revision: 385356 .
+# From configure.ac Revision: 400075 .
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.69 for asterisk trunk.
 #
@@ -17517,6 +17517,114 @@
 
 fi
 
+if test "${PBX_BFD}" = "0"; then
+  # openSUSE requires -lz
+
+if test "x${PBX_BFD}" != "x1" -a "${USE_BFD}" != "no"; then
+   pbxlibdir=""
+   # if --with-BFD=DIR has been specified, use it.
+   if test "x${BFD_DIR}" != "x"; then
+      if test -d ${BFD_DIR}/lib; then
+         pbxlibdir="-L${BFD_DIR}/lib"
+      else
+         pbxlibdir="-L${BFD_DIR}"
+      fi
+   fi
+   pbxfuncname="bfd_check_format"
+   if test "x${pbxfuncname}" = "x" ; then   # empty lib, assume only headers
+      AST_BFD_FOUND=yes
+   else
+      ast_ext_lib_check_save_CFLAGS="${CFLAGS}"
+      CFLAGS="${CFLAGS} "
+      as_ac_Lib=`$as_echo "ac_cv_lib_bfd_${pbxfuncname}" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${pbxfuncname} in -lbfd" >&5
+$as_echo_n "checking for ${pbxfuncname} in -lbfd... " >&6; }
+if eval \${$as_ac_Lib+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lbfd ${pbxlibdir} -ldl -liberty -lz $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ${pbxfuncname} ();
+int
+main ()
+{
+return ${pbxfuncname} ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
+  AST_BFD_FOUND=yes
+else
+  AST_BFD_FOUND=no
+fi
+
+      CFLAGS="${ast_ext_lib_check_save_CFLAGS}"
+   fi
+
+   # now check for the header.
+   if test "${AST_BFD_FOUND}" = "yes"; then
+      BFD_LIB="${pbxlibdir} -lbfd -ldl -liberty -lz"
+      # if --with-BFD=DIR has been specified, use it.
+      if test "x${BFD_DIR}" != "x"; then
+         BFD_INCLUDE="-I${BFD_DIR}/include"
+      fi
+      BFD_INCLUDE="${BFD_INCLUDE} "
+      if test "xbfd.h" = "x" ; then	# no header, assume found
+         BFD_HEADER_FOUND="1"
+      else				# check for the header
+         ast_ext_lib_check_saved_CPPFLAGS="${CPPFLAGS}"
+         CPPFLAGS="${CPPFLAGS} ${BFD_INCLUDE}"
+         ac_fn_c_check_header_mongrel "$LINENO" "bfd.h" "ac_cv_header_bfd_h" "$ac_includes_default"
+if test "x$ac_cv_header_bfd_h" = xyes; then :
+  BFD_HEADER_FOUND=1
+else
+  BFD_HEADER_FOUND=0
+fi
+
+
+         CPPFLAGS="${ast_ext_lib_check_saved_CPPFLAGS}"
+      fi
+      if test "x${BFD_HEADER_FOUND}" = "x0" ; then
+         BFD_LIB=""
+         BFD_INCLUDE=""
+      else
+         if test "x${pbxfuncname}" = "x" ; then		# only checking headers -> no library
+            BFD_LIB=""
+         fi
+         PBX_BFD=1
+         cat >>confdefs.h <<_ACEOF
+#define HAVE_BFD 1
+_ACEOF
+
+      fi
+   fi
+fi
+
+
+fi
+
 if test "x${OSARCH}" = "xlinux-gnu" ; then
 
 if test "x${PBX_CAP}" != "x1" -a "${USE_CAP}" != "no"; then
@@ -31765,6 +31873,15 @@
 echo
 fi
 
+if test "x${AST_IODBC_FOUND}" = "xyes"; then
+	echo "WARNING: iodbc libs/headers found!"
+	echo
+	echo "  If you plan to use ODBC functionality, you should consider"
+	echo "  switching to unixodbc instead."
+	echo "  See: https://issues.asterisk.org/jira/browse/ASTERISK-22459"
+	echo
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: Package configured for: " >&5
 $as_echo "$as_me: Package configured for: " >&6;}
 { $as_echo "$as_me:${as_lineno-$LINENO}: OS type  : $host_os" >&5
--- doc/astdb2bdb.8
+++ doc/astdb2bdb.8
@@ -0,0 +1,46 @@
+.TH "ASTDB2BDB" "8" "30 SEPTEMBER 2013" "Asterisk 11" ""
+
+.SH NAME
+astdb2bdb \- convert astdb back to Berkeley DB 1.86
+.SH SYNOPSIS
+
+.B cd \fIastvarlibdir\fB && astdb2bdb path/to/astdb.sqlite3
+
+.SH "DESCRIPTION"
+Up until version version 11, Asterisk used an old version of the
+Berkeley DB 1.86 (bdb) to store its internal persistent database. In
+version 11 it switched to using a SQLIte 3 database. This program is
+used to convert the newly-formatted SQLite 3 astdb back to bdb.
+
+You may need it in case of reverting an upgrade or other similar
+scenarios.
+
+.SH OPTIONS
+There is a single (and required) parameter: the path the the sqlite file.
+The output file will be a file called
+.B astdb
+in the current working directory.
+
+.SH EXAMPLES
+In case you want to revert an upgrade to Asterisk 11, you can do the
+following (while Asterisk is not running):
+
+  cd /var/lib/asterisk && astdb2bdb astdb.sqlite3 && rm astdb.sqlite3
+
+This will convert the newly-formatted astdb back to the old format, and
+delete it (to avoid obsolete data copies).
+
+.SH NOTES
+Berkeley DB 1.86 is obsolete. It is incompatible with newer versions
+(4.x and newer) that you may see around. Chances are you don't have the
+tools to use it independently of Asterisk.
+
+.SH SEE ALSO
+.B astdb2sqlite3(8),
+.B asterisk(8)
+
+.SH AUTHOR
+astdb2bdb was written by Terry Wilson <twilson@digium.com>.
+
+This manual page was written by Tzafrir Cohen <tzafrir.cohen@xorcom.com>.
+
--- doc/astdb2sqlite3.8
+++ doc/astdb2sqlite3.8
@@ -0,0 +1,39 @@
+.TH "ASTDB2SQLITE3" "8" "30 SEPTEMBER 2013" "Asterisk 11" ""
+
+.SH NAME
+astdb2sqlite3 \- convert astdb to SQLite 3
+.SH SYNOPSIS
+
+.B astdb2sqlite3 path/to/astdb
+
+.SH "DESCRIPTION"
+Up until version version 11, Asterisk used an old version of the
+Berkeley DB 1.86 (bdb) to store its internal persistent database. In
+version 11 it switched to using a SQLite 3 database. This program is
+used to convert an existing bdb astdb file to astdb.sqlite3.
+
+Normally the conversion is done by Asterisk itself which will run this
+program. But you may need to run it on your own.
+
+.SH OPTIONS
+There is a single (and required) parameter: the path the the bdb file.
+The output file name will be the same as the input, with
+.B .sqlite3
+appended.
+
+.SH EXAMPLES
+Asterisk will typically run the following to upgrade the database:
+
+  astdb2sqlite3 /var/lib/asterisk/astdb
+
+which will create \fB/var/lib/asterisk/astdb.sqlite3\fR.
+
+.SH SEE ALSO
+.B astdb2bdb(8),
+.B asterisk(8)
+
+.SH AUTHOR
+astdb2sqlite3 was written by Terry Wilson <twilson@digium.com>.
+
+This manual page was written by Tzafrir Cohen <tzafrir.cohen@xorcom.com>.
+
--- funcs/func_config.c
+++ funcs/func_config.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 328259 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400697 $")
 
 #include "asterisk/module.h"
 #include "asterisk/channel.h"
@@ -120,7 +120,7 @@
 			/* At worst, we might leak an entry while upgrading locks */
 			AST_RWLIST_UNLOCK(&configs);
 			AST_RWLIST_WRLOCK(&configs);
-			if (!(cur = ast_malloc(sizeof(*cur) + strlen(args.filename) + 1))) {
+			if (!(cur = ast_calloc(1, sizeof(*cur) + strlen(args.filename) + 1))) {
 				AST_RWLIST_UNLOCK(&configs);
 				return -1;
 			}
@@ -149,7 +149,7 @@
 		}
 
 		if (!cur) {
-			if (!(cur = ast_malloc(sizeof(*cur) + strlen(args.filename) + 1))) {
+			if (!(cur = ast_calloc(1, sizeof(*cur) + strlen(args.filename) + 1))) {
 				AST_RWLIST_UNLOCK(&configs);
 				return -1;
 			}
--- main/config_options.c
+++ main/config_options.c
@@ -27,7 +27,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399564 $")
 
 #include <regex.h>
 
@@ -370,10 +370,6 @@
 	}
 
 	if (type->type == ACO_GLOBAL && *field) {
-		if (aco_set_defaults(type, cat, *field)) {
-			ast_log(LOG_ERROR, "In %s: Setting defaults for %s failed\n", file->filename, cat);
-			return -1;
-		}
 		if (aco_process_category_options(type, cfg, cat, *field)) {
 			ast_log(LOG_ERROR, "In %s: Processing options for %s failed\n", file->filename, cat);
 			return -1;
@@ -504,6 +500,28 @@
 
 	while (res != ACO_PROCESS_ERROR && (file = info->files[x++])) {
 		const char *filename = file->filename;
+		struct aco_type *match;
+		int i;
+
+		/* set defaults for global objects */
+		for (i = 0, match = file->types[i]; match; match = file->types[++i]) {
+			void **field = info->internal->pending + match->item_offset;
+
+			if (match->type != ACO_GLOBAL || !*field) {
+				continue;
+			}
+
+			if (aco_set_defaults(match, match->category, *field)) {
+				ast_log(LOG_ERROR, "In %s: Setting defaults for %s failed\n", file->filename, match->category);
+				res = ACO_PROCESS_ERROR;
+				break;
+			}
+		}
+
+		if (res == ACO_PROCESS_ERROR) {
+			break;
+		}
+
 try_alias:
 		if (!(cfg = ast_config_load(filename, cfg_flags))) {
 			if (file->alias && strcmp(file->alias, filename)) {
--- main/logger.c
+++ main/logger.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399267 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 399513 $")
 
 /* When we include logger.h again it will trample on some stuff in syslog.h, but
  * nothing we care about in here. */
@@ -1811,6 +1811,7 @@
 	res = ast_str_set_va(&buf, 0, fmt, ap);
 	/* If the build failed then we can drop this allocated message */
 	if (res == AST_DYNSTR_BUILD_FAILED) {
+		ast_free(buf);
 		return;
 	}
 
@@ -1838,6 +1839,7 @@
 	} while (p && *p);
 
 	ast_log_callid(__LOG_VERBOSE, file, line, func, callid, "%s", ast_str_buffer(prefixed));
+	ast_free(buf);
 }
 
 void __ast_verbose(const char *file, int line, const char *func, int level, const char *fmt, ...)
--- main/security_events.c
+++ main/security_events.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 376471 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400421 $")
 
 #include "asterisk/utils.h"
 #include "asterisk/strings.h"
@@ -341,14 +341,14 @@
 		{ AST_EVENT_IE_SESSION_ID, SEC_EVT_FIELD(common, session_id) },
 		{ AST_EVENT_IE_LOCAL_ADDR, SEC_EVT_FIELD(common, local_addr) },
 		{ AST_EVENT_IE_REMOTE_ADDR, SEC_EVT_FIELD(common, remote_addr) },
-		{ AST_EVENT_IE_CHALLENGE, SEC_EVT_FIELD(inval_password, challenge) },
-		{ AST_EVENT_IE_RECEIVED_CHALLENGE, SEC_EVT_FIELD(inval_password, received_challenge) },
-		{ AST_EVENT_IE_RECEIVED_HASH, SEC_EVT_FIELD(inval_password, received_hash) },
 		{ AST_EVENT_IE_END, 0 }
 	},
 	.optional_ies = {
 		{ AST_EVENT_IE_MODULE, SEC_EVT_FIELD(common, module) },
 		{ AST_EVENT_IE_SESSION_TV, SEC_EVT_FIELD(common, session_tv) },
+		{ AST_EVENT_IE_CHALLENGE, SEC_EVT_FIELD(inval_password, challenge) },
+		{ AST_EVENT_IE_RECEIVED_CHALLENGE, SEC_EVT_FIELD(inval_password, received_challenge) },
+		{ AST_EVENT_IE_RECEIVED_HASH, SEC_EVT_FIELD(inval_password, received_hash) },
 		{ AST_EVENT_IE_END, 0 }
 	},
 },
--- Makefile
+++ Makefile
@@ -564,6 +564,7 @@
 	$(INSTALL) -m 644 doc/core-*.xml "$(DESTDIR)$(ASTDATADIR)/documentation"
 	$(INSTALL) -m 644 doc/appdocsxml.dtd "$(DESTDIR)$(ASTDATADIR)/documentation"
 	$(INSTALL) -m 644 doc/asterisk.8 "$(DESTDIR)$(ASTMANDIR)/man8"
+	$(INSTALL) -m 644 doc/astdb*.8 "$(DESTDIR)$(ASTMANDIR)/man8"
 	$(INSTALL) -m 644 contrib/scripts/astgenkey.8 "$(DESTDIR)$(ASTMANDIR)/man8"
 	$(INSTALL) -m 644 contrib/scripts/autosupport.8 "$(DESTDIR)$(ASTMANDIR)/man8"
 	$(INSTALL) -m 644 contrib/scripts/safe_asterisk.8 "$(DESTDIR)$(ASTMANDIR)/man8"
--- res/res_rtp_asterisk.c
+++ res/res_rtp_asterisk.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397604 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400681 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -1660,7 +1660,13 @@
 	unsigned int count = PJ_ARRAY_SIZE(address), pos = 0;
 
 	/* Add all the local interface IP addresses */
-	pj_enum_ip_interface(ast_sockaddr_is_ipv4(addr) ? pj_AF_INET() : pj_AF_INET6(), &count, address);
+	if (ast_sockaddr_is_ipv4(addr)) {
+		pj_enum_ip_interface(pj_AF_INET(), &count, address);
+	} else if (ast_sockaddr_is_any(addr)) {
+		pj_enum_ip_interface(pj_AF_UNSPEC(), &count, address);
+	} else {
+		pj_enum_ip_interface(pj_AF_INET6(), &count, address);
+	}
 
 	for (pos = 0; pos < count; pos++) {
 		pj_sockaddr_set_port(&address[pos], port);
@@ -3654,6 +3660,12 @@
 		f = ast_frisolate(&srcupdate);
 		AST_LIST_INSERT_TAIL(&frames, f, frame_list);
 
+		rtp->seedrxseqno = 0;
+		rtp->rxcount = 0;
+		rtp->cycles = 0;
+		rtp->lastrxseqno = 0;
+		rtp->rtcp->expected_prior = 0;
+		rtp->rtcp->received_prior = 0;
 		rtp->last_seqno = 0;
 		rtp->last_end_timestamp = 0;
 	}
--- res/res_rtp_multicast.c
+++ res/res_rtp_multicast.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 385689 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400394 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -260,15 +260,15 @@
 	/* Construct an RTP header for our packet */
 	rtpheader = (unsigned char *)(f->data.ptr - hdrlen);
 	put_unaligned_uint32(rtpheader, htonl((2 << 30) | (codec << 16) | (multicast->seqno)));
-	put_unaligned_uint32(rtpheader + 4, htonl(multicast->lastts));
 	
 	if (ast_test_flag(f, AST_FRFLAG_HAS_TIMING_INFO)) {
 		put_unaligned_uint32(rtpheader + 4, htonl(f->ts * 8));
-	} 
-	else {
-		put_unaligned_uint32(rtpheader + 8, htonl(multicast->ssrc));
+	} else {
+		put_unaligned_uint32(rtpheader + 4, htonl(multicast->lastts));
 	}
 
+	put_unaligned_uint32(rtpheader + 8, htonl(multicast->ssrc));
+
 	/* Increment sequence number and wrap to 0 if it overflows 16 bits. */
 	multicast->seqno = 0xFFFF & (multicast->seqno + 1);
 
