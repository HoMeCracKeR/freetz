--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 382385 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -3098,7 +3098,7 @@
 {
 	int res = 0;
 
-	if (conf_load_config(0)) {
+	if (conf_load_config()) {
 		ast_log(LOG_ERROR, "Unable to load config. Not loading module.\n");
 		return AST_MODULE_LOAD_DECLINE;
 	}
@@ -3145,7 +3145,7 @@
 
 static int reload(void)
 {
-	return conf_load_config(1);
+	return conf_reload_config();
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Conference Bridge Application",
--- apps/app_meetme.c
+++ apps/app_meetme.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387689 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396944 $")
 
 #include <dahdi/user.h>
 
@@ -655,9 +655,9 @@
 #define CONFFLAG_INTROMSG           (1ULL << 32) /*!< If set play an intro announcement at start of conference */
 #define CONFFLAG_INTROUSER_VMREC    (1ULL << 33)
 /*! If there's only one person left in a conference when someone leaves, kill the conference */
-#define CONFFLAG_KILL_LAST_MAN_STANDING ((uint64_t)1 << 34)
+#define CONFFLAG_KILL_LAST_MAN_STANDING (1ULL << 34)
 /*! If set, don't enable a denoiser for the channel */
-#define CONFFLAG_DONT_DENOISE       (1ULL << 33)
+#define CONFFLAG_DONT_DENOISE       (1ULL << 35)
 
 enum {
 	OPT_ARG_WAITMARKED = 0,
@@ -866,17 +866,26 @@
 	/*! This option uses the values in the sla_hold_access enum and sets the
 	 * access control type for hold on this station. */
 	unsigned int hold_access:1;
-	/*! Use count for inside sla_station_exec */
-	unsigned int ref_count;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
+/*!
+ * \brief A reference to a station
+ *
+ * This struct looks near useless at first glance.  However, its existence
+ * in the list of stations in sla_trunk means that this station references
+ * that trunk.  We use the mark to keep track of whether it needs to be
+ * removed from the sla_trunk's list of stations during a reload.
+ */
 struct sla_station_ref {
 	AST_LIST_ENTRY(sla_station_ref) entry;
 	struct sla_station *station;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
 struct sla_trunk {
-	AST_RWLIST_ENTRY(sla_trunk) entry;
 	AST_DECLARE_STRING_FIELDS(
 		AST_STRING_FIELD(name);
 		AST_STRING_FIELD(device);
@@ -900,10 +909,16 @@
 	/*! Whether this trunk is currently on hold, meaning that once a station
 	 *  connects to it, the trunk channel needs to have UNHOLD indicated to it. */
 	unsigned int on_hold:1;
-	/*! Use count for inside sla_trunk_exec */
-	unsigned int ref_count;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
+/*!
+ * \brief A station's reference to a trunk
+ *
+ * An sla_station keeps a list of trunk_refs.  This holds metadata about the
+ * stations usage of the trunk.
+ */
 struct sla_trunk_ref {
 	AST_LIST_ENTRY(sla_trunk_ref) entry;
 	struct sla_trunk *trunk;
@@ -917,10 +932,12 @@
 	 *  station.  This takes higher priority than a ring delay set at
 	 *  the station level. */
 	unsigned int ring_delay;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
-static AST_RWLIST_HEAD_STATIC(sla_stations, sla_station);
-static AST_RWLIST_HEAD_STATIC(sla_trunks, sla_trunk);
+static struct ao2_container *sla_stations;
+static struct ao2_container *sla_trunks;
 
 static const char sla_registrar[] = "SLA";
 
@@ -932,10 +949,6 @@
 	SLA_EVENT_DIAL_STATE,
 	/*! The state of a ringing trunk has changed */
 	SLA_EVENT_RINGING_TRUNK,
-	/*! A reload of configuration has been requested */
-	SLA_EVENT_RELOAD,
-	/*! Poke the SLA thread so it can check if it can perform a reload */
-	SLA_EVENT_CHECK_RELOAD,
 };
 
 struct sla_event {
@@ -991,8 +1004,6 @@
 	/*! Attempt to handle CallerID, even though it is known not to work
 	 *  properly in some situations. */
 	unsigned int attempt_callerid:1;
-	/*! A reload has been requested */
-	unsigned int reload:1;
 } sla = {
 	.thread = AST_PTHREADT_NULL,
 };
@@ -1757,7 +1768,8 @@
 
 static char *sla_show_trunks(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const struct sla_trunk *trunk;
+	struct ao2_iterator i;
+	struct sla_trunk *trunk;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1775,12 +1787,17 @@
 	            "=== Configured SLA Trunks ===================================\n"
 	            "=============================================================\n"
 	            "===\n");
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
+	i = ao2_iterator_init(sla_trunks, 0);
+	for (; (trunk = ao2_iterator_next(&i)); ao2_ref(trunk, -1)) {
 		struct sla_station_ref *station_ref;
 		char ring_timeout[16] = "(none)";
-		if (trunk->ring_timeout)
+
+		ao2_lock(trunk);
+
+		if (trunk->ring_timeout) {
 			snprintf(ring_timeout, sizeof(ring_timeout), "%u Seconds", trunk->ring_timeout);
+		}
+
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n"
 		            "=== Trunk Name:       %s\n"
 		            "=== ==> Device:       %s\n"
@@ -1794,13 +1811,16 @@
 		            ring_timeout,
 		            trunk->barge_disabled ? "No" : "Yes",
 		            sla_hold_str(trunk->hold_access));
-		AST_RWLIST_RDLOCK(&sla_stations);
-		AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry)
+
+		AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
 			ast_cli(a->fd, "===    ==> Station name: %s\n", station_ref->station->name);
-		AST_RWLIST_UNLOCK(&sla_stations);
+		}
+
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n===\n");
+
+		ao2_unlock(trunk);
 	}
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	ao2_iterator_destroy(&i);
 	ast_cli(a->fd, "=============================================================\n\n");
 
 	return CLI_SUCCESS;
@@ -1822,7 +1842,8 @@
 
 static char *sla_show_stations(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const struct sla_station *station;
+	struct ao2_iterator i;
+	struct sla_station *station;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1840,11 +1861,14 @@
 	            "=== Configured SLA Stations =================================\n"
 	            "=============================================================\n"
 	            "===\n");
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	for (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {
 		struct sla_trunk_ref *trunk_ref;
 		char ring_timeout[16] = "(none)";
 		char ring_delay[16] = "(none)";
+
+		ao2_lock(station);
+
 		if (station->ring_timeout) {
 			snprintf(ring_timeout, sizeof(ring_timeout), 
 				"%u", station->ring_timeout);
@@ -1865,7 +1889,6 @@
 		            S_OR(station->autocontext, "(none)"), 
 		            ring_timeout, ring_delay,
 		            sla_hold_str(station->hold_access));
-		AST_RWLIST_RDLOCK(&sla_trunks);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			if (trunk_ref->ring_timeout) {
 				snprintf(ring_timeout, sizeof(ring_timeout),
@@ -1885,11 +1908,12 @@
 			            trunkstate2str(trunk_ref->state),
 			            ring_timeout, ring_delay);
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n"
 		            "===\n");
+
+		ao2_unlock(station);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
+	ao2_iterator_destroy(&i);
 	ast_cli(a->fd, "============================================================\n"
 	            "\n");
 
@@ -2043,11 +2067,16 @@
 	struct sla_event *event;
 
 	if (sla.thread == AST_PTHREADT_NULL) {
+		ao2_ref(station, -1);
+		ao2_ref(trunk_ref, -1);
 		return;
 	}
 
-	if (!(event = ast_calloc(1, sizeof(*event))))
+	if (!(event = ast_calloc(1, sizeof(*event)))) {
+		ao2_ref(station, -1);
+		ao2_ref(trunk_ref, -1);
 		return;
+	}
 
 	event->type = type;
 	event->trunk_ref = trunk_ref;
@@ -2081,6 +2110,7 @@
 	struct sla_station *station;
 	struct sla_trunk_ref *trunk_ref = NULL;
 	char *trunk_name;
+	struct ao2_iterator i;
 
 	trunk_name = ast_strdupa(conf->confno);
 	strsep(&trunk_name, "_");
@@ -2089,16 +2119,23 @@
 		return;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	while ((station = ao2_iterator_next(&i))) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-			if (trunk_ref->chan == chan && !strcmp(trunk_ref->trunk->name, trunk_name))
+			if (trunk_ref->chan == chan && !strcmp(trunk_ref->trunk->name, trunk_name)) {
+				ao2_ref(trunk_ref, 1);
 				break;
+			}
 		}
-		if (trunk_ref)
+		ao2_unlock(station);
+		if (trunk_ref) {
+			/* station reference given to sla_queue_event_full() */
 			break;
+		}
+		ao2_ref(station, -1);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
+	ao2_iterator_destroy(&i);
 
 	if (!trunk_ref) {
 		ast_debug(1, "Trunk not found for event!\n");
@@ -5571,34 +5608,30 @@
 	ast_config_destroy(cfg);
 }
 
-/*! \brief Find an SLA trunk by name
- * \note This must be called with the sla_trunks container locked
+/*!
+ * \internal
+ * \brief Find an SLA trunk by name
  */
 static struct sla_trunk *sla_find_trunk(const char *name)
 {
-	struct sla_trunk *trunk = NULL;
-
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (!strcasecmp(trunk->name, name))
-			break;
-	}
+	struct sla_trunk tmp_trunk = {
+		.name = name,
+	};
 
-	return trunk;
+	return ao2_find(sla_trunks, &tmp_trunk, OBJ_POINTER);
 }
 
-/*! \brief Find an SLA station by name
- * \note This must be called with the sla_stations container locked
+/*!
+ * \internal
+ * \brief Find an SLA station by name
  */
 static struct sla_station *sla_find_station(const char *name)
 {
-	struct sla_station *station = NULL;
-
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
-		if (!strcasecmp(station->name, name))
-			break;
-	}
+	struct sla_station tmp_station = {
+		.name = name,
+	};
 
-	return station;
+	return ao2_find(sla_stations, &tmp_station, OBJ_POINTER);
 }
 
 static int sla_check_station_hold_access(const struct sla_trunk *trunk,
@@ -5622,9 +5655,11 @@
 	return 0;
 }
 
-/*! \brief Find a trunk reference on a station by name
+/*!
+ * \brief Find a trunk reference on a station by name
  * \param station the station
  * \param name the trunk's name
+ * \pre sla_station is locked
  * \return a pointer to the station's trunk reference.  If the trunk
  *         is not found, it is not idle and barge is disabled, or if
  *         it is on hold and private hold is set, then NULL will be returned.
@@ -5651,16 +5686,32 @@
 		break;
 	}
 
+	if (trunk_ref) {
+		ao2_ref(trunk_ref, 1);
+	}
+
 	return trunk_ref;
 }
 
+static void sla_station_ref_destructor(void *obj)
+{
+	struct sla_station_ref *station_ref = obj;
+
+	if (station_ref->station) {
+		ao2_ref(station_ref->station, -1);
+		station_ref->station = NULL;
+	}
+}
+
 static struct sla_station_ref *sla_create_station_ref(struct sla_station *station)
 {
 	struct sla_station_ref *station_ref;
 
-	if (!(station_ref = ast_calloc(1, sizeof(*station_ref))))
+	if (!(station_ref = ao2_alloc(sizeof(*station_ref), sla_station_ref_destructor))) {
 		return NULL;
+	}
 
+	ao2_ref(station, 1);
 	station_ref->station = station;
 
 	return station_ref;
@@ -5673,12 +5724,48 @@
 	if (!(ringing_station = ast_calloc(1, sizeof(*ringing_station))))
 		return NULL;
 
+	ao2_ref(station, 1);
 	ringing_station->station = station;
 	ringing_station->ring_begin = ast_tvnow();
 
 	return ringing_station;
 }
 
+static void sla_ringing_station_destroy(struct sla_ringing_station *ringing_station)
+{
+	if (ringing_station->station) {
+		ao2_ref(ringing_station->station, -1);
+		ringing_station->station = NULL;
+	}
+
+	ast_free(ringing_station);
+}
+
+static struct sla_failed_station *sla_create_failed_station(struct sla_station *station)
+{
+	struct sla_failed_station *failed_station;
+
+	if (!(failed_station = ast_calloc(1, sizeof(*failed_station)))) {
+		return NULL;
+	}
+
+	ao2_ref(station, 1);
+	failed_station->station = station;
+	failed_station->last_try = ast_tvnow();
+
+	return failed_station;
+}
+
+static void sla_failed_station_destroy(struct sla_failed_station *failed_station)
+{
+	if (failed_station->station) {
+		ao2_ref(failed_station->station, -1);
+		failed_station->station = NULL;
+	}
+
+	ast_free(failed_station);
+}
+
 static enum ast_device_state sla_state_to_devstate(enum sla_trunk_state state)
 {
 	switch (state) {
@@ -5701,18 +5788,25 @@
 {
 	struct sla_station *station;
 	struct sla_trunk_ref *trunk_ref;
+	struct ao2_iterator i;
 
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	while ((station = ao2_iterator_next(&i))) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			if (trunk_ref->trunk != trunk || (inactive_only ? trunk_ref->chan : 0)
-				|| trunk_ref == exclude)
+					|| trunk_ref == exclude) {
 				continue;
+			}
 			trunk_ref->state = state;
 			ast_devstate_changed(sla_state_to_devstate(state), AST_DEVSTATE_CACHABLE,
 					     "SLA:%s_%s", station->name, trunk->name);
 			break;
 		}
+		ao2_unlock(station);
+		ao2_ref(station, -1);
 	}
+	ao2_iterator_destroy(&i);
 }
 
 struct run_station_args {
@@ -5730,8 +5824,8 @@
 
 static void *run_station(void *data)
 {
-	struct sla_station *station;
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	struct ast_str *conf_name = ast_str_create(16);
 	struct ast_flags64 conf_flags = { 0 };
 	struct ast_conference *conf;
@@ -5774,6 +5868,8 @@
 	return NULL;
 }
 
+static void sla_ringing_trunk_destroy(struct sla_ringing_trunk *ringing_trunk);
+
 static void sla_stop_ringing_trunk(struct sla_ringing_trunk *ringing_trunk)
 {
 	char buf[80];
@@ -5783,10 +5879,11 @@
 	admin_exec(NULL, buf);
 	sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
 
-	while ((station_ref = AST_LIST_REMOVE_HEAD(&ringing_trunk->timed_out_stations, entry)))
-		ast_free(station_ref);
+	while ((station_ref = AST_LIST_REMOVE_HEAD(&ringing_trunk->timed_out_stations, entry))) {
+		ao2_ref(station_ref, -1);
+	}
 
-	ast_free(ringing_trunk);
+	sla_ringing_trunk_destroy(ringing_trunk);
 }
 
 static void sla_stop_ringing_station(struct sla_ringing_station *ringing_station,
@@ -5821,7 +5918,7 @@
 	}
 
 done:
-	ast_free(ringing_station);
+	sla_ringing_station_destroy(ringing_station);
 }
 
 static void sla_dial_state_callback(struct ast_dial *dial)
@@ -5873,8 +5970,10 @@
 			if (rm)
 				AST_LIST_REMOVE_CURRENT(entry);
 
-			if (trunk_ref)
+			if (trunk_ref) {
+				ao2_ref(s_trunk_ref, 1);
 				*trunk_ref = s_trunk_ref;
+			}
 
 			break;
 		}
@@ -5892,7 +5991,7 @@
 	struct sla_ringing_station *ringing_station;
 
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_stations, ringing_station, entry) {
-		struct sla_trunk_ref *s_trunk_ref = NULL;
+		RAII_VAR(struct sla_trunk_ref *, s_trunk_ref, NULL, ao2_cleanup);
 		struct sla_ringing_trunk *ringing_trunk = NULL;
 		struct run_station_args args;
 		enum ast_dial_result dial_res;
@@ -5925,7 +6024,7 @@
 				ast_dial_join(ringing_station->station->dial);
 				ast_dial_destroy(ringing_station->station->dial);
 				ringing_station->station->dial = NULL;
-				ast_free(ringing_station);
+				sla_ringing_station_destroy(ringing_station);
 				break;
 			}
 			/* Track the channel that answered this trunk */
@@ -5936,12 +6035,14 @@
 			/* Now, start a thread that will connect this station to the trunk.  The rest of
 			 * the code here sets up the thread and ensures that it is able to save the arguments
 			 * before they are no longer valid since they are allocated on the stack. */
+			ao2_ref(s_trunk_ref, 1);
 			args.trunk_ref = s_trunk_ref;
+			ao2_ref(ringing_station->station, 1);
 			args.station = ringing_station->station;
 			args.cond = &cond;
 			args.cond_lock = &cond_lock;
-			ast_free(ringing_trunk);
-			ast_free(ringing_station);
+			sla_ringing_trunk_destroy(ringing_trunk);
+			sla_ringing_station_destroy(ringing_station);
 			ast_mutex_init(&cond_lock);
 			ast_cond_init(&cond, NULL);
 			ast_mutex_lock(&cond_lock);
@@ -5995,7 +6096,7 @@
 			continue;
 		if (ast_tvdiff_ms(ast_tvnow(), failed_station->last_try) > 1000) {
 			AST_LIST_REMOVE_CURRENT(entry);
-			ast_free(failed_station);
+			sla_failed_station_destroy(failed_station);
 			break;
 		}
 		res = 1;
@@ -6048,11 +6149,9 @@
 	if (res != AST_DIAL_RESULT_TRYING) {
 		struct sla_failed_station *failed_station;
 		ast_dial_destroy(dial);
-		if (!(failed_station = ast_calloc(1, sizeof(*failed_station))))
-			return -1;
-		failed_station->station = station;
-		failed_station->last_try = ast_tvnow();
-		AST_LIST_INSERT_HEAD(&sla.failed_stations, failed_station, entry);
+		if ((failed_station = sla_create_failed_station(station))) {
+			AST_LIST_INSERT_HEAD(&sla.failed_stations, failed_station, entry);
+		}
 		return -1;
 	}
 	if (!(ringing_station = sla_create_ringing_station(station))) {
@@ -6092,6 +6191,8 @@
 			break;
 	}
 
+	ao2_ref(trunk_ref, 1);
+
 	return trunk_ref;
 }
 
@@ -6103,7 +6204,7 @@
 static int sla_check_station_delay(struct sla_station *station, 
 	struct sla_ringing_trunk *ringing_trunk)
 {
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	unsigned int delay = UINT_MAX;
 	int time_left, time_elapsed;
 
@@ -6196,7 +6297,7 @@
 			ast_dial_join(ringing_station->station->dial);
 			ast_dial_destroy(ringing_station->station->dial);
 			ringing_station->station->dial = NULL;
-			ast_free(ringing_station);
+			sla_ringing_station_destroy(ringing_station);
 		}
 	}
 	AST_LIST_TRAVERSE_SAFE_END
@@ -6353,8 +6454,10 @@
 {
 	struct sla_station *station;
 	int res = 0;
+	struct ao2_iterator i;
 
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	for (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {
 		struct sla_ringing_trunk *ringing_trunk;
 		int time_left;
 
@@ -6384,6 +6487,7 @@
 		if (time_left < *timeout)
 			*timeout = time_left;
 	}
+	ao2_iterator_destroy(&i);
 
 	return res;
 }
@@ -6425,50 +6529,19 @@
 	return 1;
 }
 
-static int sla_load_config(int reload);
-
-/*! \brief Check if we can do a reload of SLA, and do it if we can */
-static void sla_check_reload(void)
+static void sla_event_destroy(struct sla_event *event)
 {
-	struct sla_station *station;
-	struct sla_trunk *trunk;
-
-	ast_mutex_lock(&sla.lock);
-
-	if (!AST_LIST_EMPTY(&sla.event_q) || !AST_LIST_EMPTY(&sla.ringing_trunks)
-		|| !AST_LIST_EMPTY(&sla.ringing_stations) || !AST_LIST_EMPTY(&sla.failed_stations)) {
-		ast_mutex_unlock(&sla.lock);
-		return;
-	}
-
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
-		if (station->ref_count)
-			break;
-	}
-	AST_RWLIST_UNLOCK(&sla_stations);
-	if (station) {
-		ast_mutex_unlock(&sla.lock);
-		return;
+	if (event->trunk_ref) {
+		ao2_ref(event->trunk_ref, -1);
+		event->trunk_ref = NULL;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (trunk->ref_count || trunk->chan || trunk->active_stations || trunk->hold_stations) {
-			break;
-		}
-	}
-	AST_RWLIST_UNLOCK(&sla_trunks);
-	if (trunk) {
-		ast_mutex_unlock(&sla.lock);
-		return;
+	if (event->station) {
+		ao2_ref(event->station, -1);
+		event->station = NULL;
 	}
 
-	/* yay */
-	sla_load_config(1);
-	sla.reload = 0;
-
-	ast_mutex_unlock(&sla.lock);
+	ast_free(event);
 }
 
 static void *sla_thread(void *data)
@@ -6507,27 +6580,21 @@
 			case SLA_EVENT_RINGING_TRUNK:
 				sla_handle_ringing_trunk_event();
 				break;
-			case SLA_EVENT_RELOAD:
-				sla.reload = 1;
-			case SLA_EVENT_CHECK_RELOAD:
-				break;
 			}
-			ast_free(event);
+			sla_event_destroy(event);
 			ast_mutex_lock(&sla.lock);
 		}
-
-		if (sla.reload) {
-			sla_check_reload();
-		}
 	}
 
 	ast_mutex_unlock(&sla.lock);
 
-	while ((ringing_station = AST_LIST_REMOVE_HEAD(&sla.ringing_stations, entry)))
-		ast_free(ringing_station);
+	while ((ringing_station = AST_LIST_REMOVE_HEAD(&sla.ringing_stations, entry))) {
+		sla_ringing_station_destroy(ringing_station);
+	}
 
-	while ((failed_station = AST_LIST_REMOVE_HEAD(&sla.failed_stations, entry)))
-		ast_free(failed_station);
+	while ((failed_station = AST_LIST_REMOVE_HEAD(&sla.failed_stations, entry))) {
+		sla_failed_station_destroy(failed_station);
+	}
 
 	return NULL;
 }
@@ -6548,7 +6615,8 @@
 	char conf_name[MAX_CONFNUM];
 	struct ast_conference *conf;
 	struct ast_flags64 conf_flags = { 0 };
-	struct sla_trunk_ref *trunk_ref = args->trunk_ref;
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, args->trunk_ref, ao2_cleanup);
+	RAII_VAR(struct sla_station *, station, args->station, ao2_cleanup);
 	int caller_is_saved;
 	struct ast_party_caller caller;
 	int last_state = 0;
@@ -6620,8 +6688,8 @@
 			break;
 
 		/* check that SLA station that originated trunk call is still alive */
-		if (args->station && ast_device_state(args->station->device) == AST_DEVICE_NOT_INUSE) {
-			ast_debug(3, "Originating station device %s no longer active\n", args->station->device);
+		if (station && ast_device_state(station->device) == AST_DEVICE_NOT_INUSE) {
+			ast_debug(3, "Originating station device %s no longer active\n", station->device);
 			trunk_ref->trunk->chan = NULL;
 			break;
 		}
@@ -6674,15 +6742,19 @@
 	return NULL;
 }
 
-/*! \brief For a given station, choose the highest priority idle trunk
+/*!
+ * \brief For a given station, choose the highest priority idle trunk
+ * \pre sla_station is locked
  */
 static struct sla_trunk_ref *sla_choose_idle_trunk(const struct sla_station *station)
 {
 	struct sla_trunk_ref *trunk_ref = NULL;
 
 	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-		if (trunk_ref->state == SLA_TRUNK_STATE_IDLE)
+		if (trunk_ref->state == SLA_TRUNK_STATE_IDLE) {
+			ao2_ref(trunk_ref, 1);
 			break;
+		}
 	}
 
 	return trunk_ref;
@@ -6691,8 +6763,8 @@
 static int sla_station_exec(struct ast_channel *chan, const char *data)
 {
 	char *station_name, *trunk_name;
-	struct sla_station *station;
-	struct sla_trunk_ref *trunk_ref = NULL;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	char conf_name[MAX_CONFNUM];
 	struct ast_flags64 conf_flags = { 0 };
 	struct ast_conference *conf;
@@ -6712,25 +6784,21 @@
 		return 0;
 	}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
 	station = sla_find_station(station_name);
-	if (station)
-		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
-	AST_RWLIST_UNLOCK(&sla_stations);
 
 	if (!station) {
 		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);
 		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 		return 0;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_trunks);
+	ao2_lock(station);
 	if (!ast_strlen_zero(trunk_name)) {
 		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);
-	} else
+	} else {
 		trunk_ref = sla_choose_idle_trunk(station);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	}
+	ao2_unlock(station);
 
 	if (!trunk_ref) {
 		if (ast_strlen_zero(trunk_name))
@@ -6740,8 +6808,6 @@
 				"'%s' due to access controls.\n", trunk_name);
 		}
 		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
-		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 		return 0;
 	}
 
@@ -6770,7 +6836,7 @@
 			answer_trunk_chan(ringing_trunk->trunk->chan);
 			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
 
-			free(ringing_trunk);
+			sla_ringing_trunk_destroy(ringing_trunk);
 
 			/* Queue up reprocessing ringing trunks, and then ringing stations again */
 			sla_queue_event(SLA_EVENT_RINGING_TRUNK);
@@ -6790,6 +6856,8 @@
 			.cond_lock = &cond_lock,
 			.cond = &cond,
 		};
+		ao2_ref(trunk_ref, 1);
+		ao2_ref(station, 1);
 		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
 		/* Create a thread to dial the trunk and dump it into the conference.
 		 * However, we want to wait until the trunk has been dialed and the
@@ -6809,8 +6877,6 @@
 			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
 			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
 			trunk_ref->chan = NULL;
-			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-			sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 			return 0;
 		}
 	}
@@ -6843,19 +6909,28 @@
 	
 	pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "SUCCESS");
 
-	ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-	sla_queue_event(SLA_EVENT_CHECK_RELOAD);
-
 	return 0;
 }
 
+static void sla_trunk_ref_destructor(void *obj)
+{
+	struct sla_trunk_ref *trunk_ref = obj;
+
+	if (trunk_ref->trunk) {
+		ao2_ref(trunk_ref->trunk, -1);
+		trunk_ref->trunk = NULL;
+	}
+}
+
 static struct sla_trunk_ref *create_trunk_ref(struct sla_trunk *trunk)
 {
 	struct sla_trunk_ref *trunk_ref;
 
-	if (!(trunk_ref = ast_calloc(1, sizeof(*trunk_ref))))
+	if (!(trunk_ref = ao2_alloc(sizeof(*trunk_ref), sla_trunk_ref_destructor))) {
 		return NULL;
+	}
 
+	ao2_ref(trunk, 1);
 	trunk_ref->trunk = trunk;
 
 	return trunk_ref;
@@ -6865,9 +6940,11 @@
 {
 	struct sla_ringing_trunk *ringing_trunk;
 
-	if (!(ringing_trunk = ast_calloc(1, sizeof(*ringing_trunk))))
+	if (!(ringing_trunk = ast_calloc(1, sizeof(*ringing_trunk)))) {
 		return NULL;
-	
+	}
+
+	ao2_ref(trunk, 1);
 	ringing_trunk->trunk = trunk;
 	ringing_trunk->ring_begin = ast_tvnow();
 
@@ -6882,6 +6959,16 @@
 	return ringing_trunk;
 }
 
+static void sla_ringing_trunk_destroy(struct sla_ringing_trunk *ringing_trunk)
+{
+	if (ringing_trunk->trunk) {
+		ao2_ref(ringing_trunk->trunk, -1);
+		ringing_trunk->trunk = NULL;
+	}
+
+	ast_free(ringing_trunk);
+}
+
 enum {
 	SLA_TRUNK_OPT_MOH = (1 << 0),
 };
@@ -6900,7 +6987,7 @@
 	char conf_name[MAX_CONFNUM];
 	struct ast_conference *conf;
 	struct ast_flags64 conf_flags = { 0 };
-	struct sla_trunk *trunk;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
 	struct sla_ringing_trunk *ringing_trunk;
 	AST_DECLARE_APP_ARGS(args,
 		AST_APP_ARG(trunk_name);
@@ -6924,16 +7011,11 @@
 		}
 	}
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
 	trunk = sla_find_trunk(args.trunk_name);
-	if (trunk)
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, 1);
-	AST_RWLIST_UNLOCK(&sla_trunks);
 
 	if (!trunk) {
 		ast_log(LOG_ERROR, "SLA Trunk '%s' not found!\n", args.trunk_name);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6941,8 +7023,6 @@
 		ast_log(LOG_ERROR, "Call came in on %s, but the trunk is already in use!\n",
 			args.trunk_name);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6950,8 +7030,6 @@
 
 	if (!(ringing_trunk = queue_ringing_trunk(trunk))) {
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6959,8 +7037,6 @@
 	conf = build_conf(conf_name, "", "", 1, 1, 1, chan, NULL);
 	if (!conf) {
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 	ast_set_flag64(&conf_flags, 
@@ -6994,46 +7070,37 @@
 	AST_LIST_TRAVERSE_SAFE_END;
 	ast_mutex_unlock(&sla.lock);
 	if (ringing_trunk) {
-		ast_free(ringing_trunk);
+		sla_ringing_trunk_destroy(ringing_trunk);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "UNANSWERED");
 		/* Queue reprocessing of ringing trunks to make stations stop ringing
 		 * that shouldn't be ringing after this trunk stopped. */
 		sla_queue_event(SLA_EVENT_RINGING_TRUNK);
 	}
 
-	ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-	sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
-
 	return 0;
 }
 
 static enum ast_device_state sla_state(const char *data)
 {
 	char *buf, *station_name, *trunk_name;
-	struct sla_station *station;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
 	struct sla_trunk_ref *trunk_ref;
 	enum ast_device_state res = AST_DEVICE_INVALID;
 
 	trunk_name = buf = ast_strdupa(data);
 	station_name = strsep(&trunk_name, "_");
 
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
-		if (strcasecmp(station_name, station->name))
-			continue;
-		AST_RWLIST_RDLOCK(&sla_trunks);
+	station = sla_find_station(station_name);
+	if (station) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-			if (!strcasecmp(trunk_name, trunk_ref->trunk->name))
+			if (!strcasecmp(trunk_name, trunk_ref->trunk->name)) {
+				res = sla_state_to_devstate(trunk_ref->state);
 				break;
+			}
 		}
-		if (!trunk_ref) {
-			AST_RWLIST_UNLOCK(&sla_trunks);
-			break;
-		}
-		res = sla_state_to_devstate(trunk_ref->state);
-		AST_RWLIST_UNLOCK(&sla_trunks);
+		ao2_unlock(station);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
 
 	if (res == AST_DEVICE_INVALID) {
 		ast_log(LOG_ERROR, "Could not determine state for trunk %s on station %s!\n",
@@ -7043,26 +7110,39 @@
 	return res;
 }
 
-static void destroy_trunk(struct sla_trunk *trunk)
+static int sla_trunk_release_refs(void *obj, void *arg, int flags)
 {
+	struct sla_trunk *trunk = obj;
 	struct sla_station_ref *station_ref;
 
-	if (!ast_strlen_zero(trunk->autocontext))
-		ast_context_remove_extension(trunk->autocontext, "s", 1, sla_registrar);
-
-	while ((station_ref = AST_LIST_REMOVE_HEAD(&trunk->stations, entry)))
-		ast_free(station_ref);
+	while ((station_ref = AST_LIST_REMOVE_HEAD(&trunk->stations, entry))) {
+		ao2_ref(station_ref, -1);
+	}
 
-	ast_string_field_free_memory(trunk);
-	ast_free(trunk);
+	return 0;
 }
 
-static void destroy_station(struct sla_station *station)
+static int sla_station_release_refs(void *obj, void *arg, int flags)
 {
+	struct sla_station *station = obj;
 	struct sla_trunk_ref *trunk_ref;
 
+	while ((trunk_ref = AST_LIST_REMOVE_HEAD(&station->trunks, entry))) {
+		ao2_ref(trunk_ref, -1);
+	}
+
+	return 0;
+}
+
+static void sla_station_destructor(void *obj)
+{
+	struct sla_station *station = obj;
+
+	ast_debug(1, "sla_station destructor for '%s'\n", station->name);
+
 	if (!ast_strlen_zero(station->autocontext)) {
-		AST_RWLIST_RDLOCK(&sla_trunks);
+		struct sla_trunk_ref *trunk_ref;
+
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			char exten[AST_MAX_EXTENSION];
 			char hint[AST_MAX_APP];
@@ -7073,31 +7153,43 @@
 			ast_context_remove_extension(station->autocontext, hint, 
 				PRIORITY_HINT, sla_registrar);
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 	}
 
-	while ((trunk_ref = AST_LIST_REMOVE_HEAD(&station->trunks, entry)))
-		ast_free(trunk_ref);
+	sla_station_release_refs(station, NULL, 0);
 
 	ast_string_field_free_memory(station);
-	ast_free(station);
 }
 
-static void sla_destroy(void)
+static int sla_trunk_hash(const void *obj, const int flags)
 {
-	struct sla_trunk *trunk;
-	struct sla_station *station;
+	const struct sla_trunk *trunk = obj;
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	while ((trunk = AST_RWLIST_REMOVE_HEAD(&sla_trunks, entry)))
-		destroy_trunk(trunk);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	return ast_str_case_hash(trunk->name);
+}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
-	while ((station = AST_RWLIST_REMOVE_HEAD(&sla_stations, entry)))
-		destroy_station(station);
-	AST_RWLIST_UNLOCK(&sla_stations);
+static int sla_trunk_cmp(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj, *trunk2 = arg;
+
+	return !strcasecmp(trunk->name, trunk2->name) ? CMP_MATCH | CMP_STOP : 0;
+}
+
+static int sla_station_hash(const void *obj, const int flags)
+{
+	const struct sla_station *station = obj;
+
+	return ast_str_case_hash(station->name);
+}
 
+static int sla_station_cmp(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj, *station2 = arg;
+
+	return !strcasecmp(station->name, station2->name) ? CMP_MATCH | CMP_STOP : 0;
+}
+
+static void sla_destroy(void)
+{
 	if (sla.thread != AST_PTHREADT_NULL) {
 		ast_mutex_lock(&sla.lock);
 		sla.stop = 1;
@@ -7111,6 +7203,15 @@
 
 	ast_mutex_destroy(&sla.lock);
 	ast_cond_destroy(&sla.cond);
+
+	ao2_callback(sla_trunks, 0, sla_trunk_release_refs, NULL);
+	ao2_callback(sla_stations, 0, sla_station_release_refs, NULL);
+
+	ao2_ref(sla_trunks, -1);
+	sla_trunks = NULL;
+
+	ao2_ref(sla_stations, -1);
+	sla_stations = NULL;
 }
 
 static int sla_check_device(const char *device)
@@ -7126,11 +7227,27 @@
 	return 0;
 }
 
+static void sla_trunk_destructor(void *obj)
+{
+	struct sla_trunk *trunk = obj;
+
+	ast_debug(1, "sla_trunk destructor for '%s'\n", trunk->name);
+
+	if (!ast_strlen_zero(trunk->autocontext)) {
+		ast_context_remove_extension(trunk->autocontext, "s", 1, sla_registrar);
+	}
+
+	sla_trunk_release_refs(trunk, NULL, 0);
+
+	ast_string_field_free_memory(trunk);
+}
+
 static int sla_build_trunk(struct ast_config *cfg, const char *cat)
 {
-	struct sla_trunk *trunk;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
 	struct ast_variable *var;
 	const char *dev;
+	int existing_trunk = 0;
 
 	if (!(dev = ast_variable_retrieve(cfg, cat, "device"))) {
 		ast_log(LOG_ERROR, "SLA Trunk '%s' defined with no device!\n", cat);
@@ -7138,16 +7255,25 @@
 	}
 
 	if (sla_check_device(dev)) {
-		ast_log(LOG_ERROR, "SLA Trunk '%s' define with invalid device '%s'!\n",
+		ast_log(LOG_ERROR, "SLA Trunk '%s' defined with invalid device '%s'!\n",
 			cat, dev);
 		return -1;
 	}
 
-	if (!(trunk = ast_calloc_with_stringfields(1, struct sla_trunk, 32))) {
+	if ((trunk = sla_find_trunk(cat))) {
+		trunk->mark = 0;
+		existing_trunk = 1;
+	} else if ((trunk = ao2_alloc(sizeof(*trunk), sla_trunk_destructor))) {
+		if (ast_string_field_init(trunk, 32)) {
+			return -1;
+		}
+		ast_string_field_set(trunk, name, cat);
+	} else {
 		return -1;
 	}
 
-	ast_string_field_set(trunk, name, cat);
+	ao2_lock(trunk);
+
 	ast_string_field_set(trunk, device, dev);
 
 	for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
@@ -7176,54 +7302,65 @@
 		}
 	}
 
+	ao2_unlock(trunk);
+
 	if (!ast_strlen_zero(trunk->autocontext)) {
 		struct ast_context *context;
 		context = ast_context_find_or_create(NULL, NULL, trunk->autocontext, sla_registrar);
 		if (!context) {
 			ast_log(LOG_ERROR, "Failed to automatically find or create "
 				"context '%s' for SLA!\n", trunk->autocontext);
-			destroy_trunk(trunk);
 			return -1;
 		}
 		if (ast_add_extension2(context, 0 /* don't replace */, "s", 1,
 			NULL, NULL, slatrunk_app, ast_strdup(trunk->name), ast_free_ptr, sla_registrar)) {
 			ast_log(LOG_ERROR, "Failed to automatically create extension "
 				"for trunk '%s'!\n", trunk->name);
-			destroy_trunk(trunk);
 			return -1;
 		}
 	}
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	AST_RWLIST_INSERT_TAIL(&sla_trunks, trunk, entry);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	if (!existing_trunk) {
+		ao2_link(sla_trunks, trunk);
+	}
 
 	return 0;
 }
 
+/*!
+ * \internal
+ * \pre station is not locked
+ */
 static void sla_add_trunk_to_station(struct sla_station *station, struct ast_variable *var)
 {
-	struct sla_trunk *trunk;
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
+	struct sla_trunk_ref *trunk_ref = NULL;
 	struct sla_station_ref *station_ref;
 	char *trunk_name, *options, *cur;
+	int existing_trunk_ref = 0;
+	int existing_station_ref = 0;
 
 	options = ast_strdupa(var->value);
 	trunk_name = strsep(&options, ",");
-	
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (!strcasecmp(trunk->name, trunk_name))
-			break;
-	}
 
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	trunk = sla_find_trunk(trunk_name);
 	if (!trunk) {
 		ast_log(LOG_ERROR, "Trunk '%s' not found!\n", var->value);
 		return;
 	}
-	if (!(trunk_ref = create_trunk_ref(trunk)))
+
+	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
+		if (trunk_ref->trunk == trunk) {
+			trunk_ref->mark = 0;
+			existing_trunk_ref = 1;
+			break;
+		}
+	}
+
+	if (!trunk_ref && !(trunk_ref = create_trunk_ref(trunk))) {
 		return;
+	}
+
 	trunk_ref->state = SLA_TRUNK_STATE_IDLE;
 
 	while ((cur = strsep(&options, ","))) {
@@ -7247,41 +7384,73 @@
 		}
 	}
 
-	if (!(station_ref = sla_create_station_ref(station))) {
-		ast_free(trunk_ref);
+	AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
+		if (station_ref->station == station) {
+			station_ref->mark = 0;
+			existing_station_ref = 1;
+			break;
+		}
+	}
+
+	if (!station_ref && !(station_ref = sla_create_station_ref(station))) {
+		if (!existing_trunk_ref) {
+			ao2_ref(trunk_ref, -1);
+		} else {
+			trunk_ref->mark = 1;
+		}
 		return;
 	}
-	ast_atomic_fetchadd_int((int *) &trunk->num_stations, 1);
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	AST_LIST_INSERT_TAIL(&trunk->stations, station_ref, entry);
-	AST_RWLIST_UNLOCK(&sla_trunks);
-	AST_LIST_INSERT_TAIL(&station->trunks, trunk_ref, entry);
+
+	if (!existing_station_ref) {
+		ao2_lock(trunk);
+		AST_LIST_INSERT_TAIL(&trunk->stations, station_ref, entry);
+		ast_atomic_fetchadd_int((int *) &trunk->num_stations, 1);
+		ao2_unlock(trunk);
+	}
+
+	if (!existing_trunk_ref) {
+		ao2_lock(station);
+		AST_LIST_INSERT_TAIL(&station->trunks, trunk_ref, entry);
+		ao2_unlock(station);
+	}
 }
 
 static int sla_build_station(struct ast_config *cfg, const char *cat)
 {
-	struct sla_station *station;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
 	struct ast_variable *var;
 	const char *dev;
+	int existing_station = 0;
 
 	if (!(dev = ast_variable_retrieve(cfg, cat, "device"))) {
 		ast_log(LOG_ERROR, "SLA Station '%s' defined with no device!\n", cat);
 		return -1;
 	}
 
-	if (!(station = ast_calloc_with_stringfields(1, struct sla_station, 32))) {
+	if ((station = sla_find_station(cat))) {
+		station->mark = 0;
+		existing_station = 1;
+	} else if ((station = ao2_alloc(sizeof(*station), sla_station_destructor))) {
+		if (ast_string_field_init(station, 32)) {
+			return -1;
+		}
+		ast_string_field_set(station, name, cat);
+	} else {
 		return -1;
 	}
 
-	ast_string_field_set(station, name, cat);
+	ao2_lock(station);
+
 	ast_string_field_set(station, device, dev);
 
 	for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
-		if (!strcasecmp(var->name, "trunk"))
+		if (!strcasecmp(var->name, "trunk")) {
+			ao2_unlock(station);
 			sla_add_trunk_to_station(station, var);
-		else if (!strcasecmp(var->name, "autocontext"))
+			ao2_lock(station);
+		} else if (!strcasecmp(var->name, "autocontext")) {
 			ast_string_field_set(station, autocontext, var->value);
-		else if (!strcasecmp(var->name, "ringtimeout")) {
+		} else if (!strcasecmp(var->name, "ringtimeout")) {
 			if (sscanf(var->value, "%30u", &station->ring_timeout) != 1) {
 				ast_log(LOG_WARNING, "Invalid ringtimeout '%s' specified for station '%s'\n",
 					var->value, station->name);
@@ -7309,6 +7478,8 @@
 		}
 	}
 
+	ao2_unlock(station);
+
 	if (!ast_strlen_zero(station->autocontext)) {
 		struct ast_context *context;
 		struct sla_trunk_ref *trunk_ref;
@@ -7316,7 +7487,6 @@
 		if (!context) {
 			ast_log(LOG_ERROR, "Failed to automatically find or create "
 				"context '%s' for SLA!\n", station->autocontext);
-			destroy_station(station);
 			return -1;
 		}
 		/* The extension for when the handset goes off-hook.
@@ -7325,10 +7495,8 @@
 			NULL, NULL, slastation_app, ast_strdup(station->name), ast_free_ptr, sla_registrar)) {
 			ast_log(LOG_ERROR, "Failed to automatically create extension "
 				"for trunk '%s'!\n", station->name);
-			destroy_station(station);
 			return -1;
 		}
-		AST_RWLIST_RDLOCK(&sla_trunks);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			char exten[AST_MAX_EXTENSION];
 			char hint[AST_MAX_APP];
@@ -7340,7 +7508,6 @@
 				NULL, NULL, slastation_app, ast_strdup(exten), ast_free_ptr, sla_registrar)) {
 				ast_log(LOG_ERROR, "Failed to automatically create extension "
 					"for trunk '%s'!\n", station->name);
-				destroy_station(station);
 				return -1;
 			}
 			/* Hint for this line button 
@@ -7349,20 +7516,115 @@
 				NULL, NULL, hint, NULL, NULL, sla_registrar)) {
 				ast_log(LOG_ERROR, "Failed to automatically create hint "
 					"for trunk '%s'!\n", station->name);
-				destroy_station(station);
 				return -1;
 			}
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 	}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
-	AST_RWLIST_INSERT_TAIL(&sla_stations, station, entry);
-	AST_RWLIST_UNLOCK(&sla_stations);
+	if (!existing_station) {
+		ao2_link(sla_stations, station);
+	}
+
+	return 0;
+}
+
+static int sla_trunk_mark(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj;
+	struct sla_station_ref *station_ref;
+
+	ao2_lock(trunk);
+
+	trunk->mark = 1;
+
+	AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
+		station_ref->mark = 1;
+	}
+
+	ao2_unlock(trunk);
 
 	return 0;
 }
 
+static int sla_station_mark(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj;
+	struct sla_trunk_ref *trunk_ref;
+
+	ao2_lock(station);
+
+	station->mark = 1;
+
+	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
+		trunk_ref->mark = 1;
+	}
+
+	ao2_unlock(station);
+
+	return 0;
+}
+
+static int sla_trunk_is_marked(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj;
+
+	ao2_lock(trunk);
+
+	if (trunk->mark) {
+		/* Only remove all of the station references if the trunk itself is going away */
+		sla_trunk_release_refs(trunk, NULL, 0);
+	} else {
+		struct sla_station_ref *station_ref;
+
+		/* Otherwise only remove references to stations no longer in the config */
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&trunk->stations, station_ref, entry) {
+			if (!station_ref->mark) {
+				continue;
+			}
+			AST_LIST_REMOVE_CURRENT(entry);
+			ao2_ref(station_ref, -1);
+		}
+		AST_LIST_TRAVERSE_SAFE_END
+	}
+
+	ao2_unlock(trunk);
+
+	return trunk->mark ? CMP_MATCH : 0;
+}
+
+static int sla_station_is_marked(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj;
+
+	ao2_lock(station);
+
+	if (station->mark) {
+		/* Only remove all of the trunk references if the station itself is going away */
+		sla_station_release_refs(station, NULL, 0);
+	} else {
+		struct sla_trunk_ref *trunk_ref;
+
+		/* Otherwise only remove references to trunks no longer in the config */
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&station->trunks, trunk_ref, entry) {
+			if (!trunk_ref->mark) {
+				continue;
+			}
+			AST_LIST_REMOVE_CURRENT(entry);
+			ao2_ref(trunk_ref, -1);
+		}
+		AST_LIST_TRAVERSE_SAFE_END
+	}
+
+	ao2_unlock(station);
+
+	return station->mark ? CMP_MATCH : 0;
+}
+
+static int sla_in_use(void)
+{
+	return ao2_container_count(sla_trunks) || ao2_container_count(sla_stations);
+}
+
 static int sla_load_config(int reload)
 {
 	struct ast_config *cfg;
@@ -7374,6 +7636,8 @@
 	if (!reload) {
 		ast_mutex_init(&sla.lock);
 		ast_cond_init(&sla.cond, NULL);
+		sla_trunks = ao2_container_alloc(1, sla_trunk_hash, sla_trunk_cmp);
+		sla_stations = ao2_container_alloc(1, sla_station_hash, sla_station_cmp);
 	}
 
 	if (!(cfg = ast_config_load(SLA_CONFIG_FILE, config_flags))) {
@@ -7386,21 +7650,8 @@
 	}
 
 	if (reload) {
-		struct sla_station *station;
-		struct sla_trunk *trunk;
-
-		/* We need to actually delete the previous versions of trunks and stations now */
-		AST_RWLIST_TRAVERSE_SAFE_BEGIN(&sla_stations, station, entry) {
-			AST_RWLIST_REMOVE_CURRENT(entry);
-			ast_free(station);
-		}
-		AST_RWLIST_TRAVERSE_SAFE_END;
-
-		AST_RWLIST_TRAVERSE_SAFE_BEGIN(&sla_trunks, trunk, entry) {
-			AST_RWLIST_REMOVE_CURRENT(entry);
-			ast_free(trunk);
-		}
-		AST_RWLIST_TRAVERSE_SAFE_END;
+		ao2_callback(sla_trunks, 0, sla_trunk_mark, NULL);
+		ao2_callback(sla_stations, 0, sla_station_mark, NULL);
 	}
 
 	if ((val = ast_variable_retrieve(cfg, "general", "attemptcallerid")))
@@ -7427,9 +7678,13 @@
 
 	ast_config_destroy(cfg);
 
-	/* Even if we don't have any stations, we may after a reload and we need to
-	 * be able to process the SLA_EVENT_RELOAD event in that case */
-	if (sla.thread == AST_PTHREADT_NULL && (!AST_LIST_EMPTY(&sla_stations) || !AST_LIST_EMPTY(&sla_trunks))) {
+	if (reload) {
+		ao2_callback(sla_trunks, OBJ_NODATA | OBJ_UNLINK | OBJ_MULTIPLE, sla_trunk_is_marked, NULL);
+		ao2_callback(sla_stations, OBJ_NODATA | OBJ_UNLINK | OBJ_MULTIPLE, sla_station_is_marked, NULL);
+	}
+
+	/* Start SLA event processing thread once SLA has been configured. */
+	if (sla.thread == AST_PTHREADT_NULL && sla_in_use()) {
 		ast_pthread_create(&sla.thread, NULL, sla_thread, NULL);
 	}
 
@@ -7514,15 +7769,7 @@
 static int load_config(int reload)
 {
 	load_config_meetme();
-
-	if (reload && sla.thread != AST_PTHREADT_NULL) {
-		sla_queue_event(SLA_EVENT_RELOAD);
-		ast_log(LOG_NOTICE, "A reload of the SLA configuration has been requested "
-			"and will be completed when the system is idle.\n");
-		return 0;
-	}
-	
-	return sla_load_config(0);
+	return sla_load_config(reload);
 }
 
 #define MEETME_DATA_EXPORT(MEMBER)					\
@@ -7735,8 +7982,6 @@
 	return res;
 }
 
-
-
 static int load_module(void)
 {
 	int res = 0;
--- apps/app_mixmonitor.c
+++ apps/app_mixmonitor.c
@@ -39,7 +39,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 383631 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 393630 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_MONITOR_DIR */
 #include "asterisk/stringfields.h"
@@ -740,6 +740,8 @@
 	}
 
 	mixmonitor_free(mixmonitor);
+
+	ast_module_unref(ast_module_info->self);
 	return NULL;
 }
 
@@ -779,7 +781,7 @@
 	return 0;
 }
 
-static void launch_monitor_thread(struct ast_channel *chan, const char *filename,
+static int launch_monitor_thread(struct ast_channel *chan, const char *filename,
 				  unsigned int flags, int readvol, int writevol,
 				  const char *post_process, const char *filename_write,
 				  char *filename_read, const char *uid_channel_var,
@@ -806,33 +808,33 @@
 
 	/* Pre-allocate mixmonitor structure and spy */
 	if (!(mixmonitor = ast_calloc(1, sizeof(*mixmonitor)))) {
-		return;
+		return -1;
 	}
 
 	/* Now that the struct has been calloced, go ahead and initialize the string fields. */
 	if (ast_string_field_init(mixmonitor, 512)) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* Setup the actual spy before creating our thread */
 	if (ast_audiohook_init(&mixmonitor->audiohook, AST_AUDIOHOOK_TYPE_SPY, mixmonitor_spy_type, 0)) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* Copy over flags and channel name */
 	mixmonitor->flags = flags;
 	if (!(mixmonitor->autochan = ast_autochan_setup(chan))) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	if (setup_mixmonitor_ds(mixmonitor, chan, &datastore_id)) {
 		ast_autochan_destroy(mixmonitor->autochan);
 		mixmonitor_free(mixmonitor);
 		ast_free(datastore_id);
-		return;
+		return -1;
 	}
 
 	if (!ast_strlen_zero(uid_channel_var)) {
@@ -901,13 +903,13 @@
 			mixmonitor_spy_type, ast_channel_name(chan));
 		ast_audiohook_destroy(&mixmonitor->audiohook);
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* reference be released at mixmonitor destruction */
 	mixmonitor->callid = ast_read_threadstorage_callid();
 
-	ast_pthread_create_detached_background(&thread, NULL, mixmonitor_thread, mixmonitor);
+	return ast_pthread_create_detached_background(&thread, NULL, mixmonitor_thread, mixmonitor);
 }
 
 /* a note on filename_parse: creates directory structure and assigns absolute path from relative paths for filenames */
@@ -1028,7 +1030,10 @@
 	}
 
 	pbx_builtin_setvar_helper(chan, "MIXMONITOR_FILENAME", args.filename);
-	launch_monitor_thread(chan,
+
+	/* If launch_monitor_thread works, the module reference must not be released until it is finished. */
+	ast_module_ref(ast_module_info->self);
+	if (launch_monitor_thread(chan,
 			args.filename,
 			flags.flags,
 			readvol,
@@ -1037,7 +1042,9 @@
 			filename_write,
 			filename_read,
 			uid_channel_var,
-			recipients);
+			recipients)) {
+		ast_module_unref(ast_module_info->self);
+	}
 
 	return 0;
 }
@@ -1324,6 +1331,7 @@
 	res = stop_mixmonitor_full(c, mixmonitor_id);
 
 	if (res) {
+		ast_channel_unref(c);
 		astman_send_error(s, m, "Could not stop monitoring channel");
 		return AMI_SUCCESS;
 	}
--- apps/app_playback.c
+++ apps/app_playback.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 381217 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/file.h"
 #include "asterisk/pbx.h"
@@ -212,6 +212,10 @@
 		s = x + 1;
 	ast_debug(2, "value is <%s>\n", s);
 	n = ast_var_assign("SAY", s);
+	if (!n) {
+		ast_log(LOG_ERROR, "Memory allocation error in do_say\n");
+		return -1;
+	}
 	AST_LIST_INSERT_HEAD(&head, n, entries);
 
 	/* scan the body, one piece at a time */
--- apps/app_queue.c
+++ apps/app_queue.c
@@ -63,7 +63,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391241 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396948 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -402,7 +402,7 @@
 	</application>
 	<application name="UnpauseQueueMember" language="en_US">
 		<synopsis>
-			Unpauses a queue member.		
+			Unpauses a queue member.
 		</synopsis>
 		<syntax>
 			<parameter name="queuename" />
@@ -1083,8 +1083,8 @@
  *  q_next links ALL defined callattempt structures into a linked list. call_next is
  *  a link which allows for a subset of the callattempts to be traversed. This subset
  *  is used in wait_for_answer so that irrelevant callattempts are not traversed. This
- *  also is helpful so that queue logs are always accurate in the case where a call to 
- *  a member times out, especially if using the ringall strategy. 
+ *  also is helpful so that queue logs are always accurate in the case where a call to
+ *  a member times out, especially if using the ringall strategy.
 */
 
 struct callattempt {
@@ -1292,7 +1292,7 @@
 	int rrpos;                          /*!< Round Robin - position */
 	int memberdelay;                    /*!< Seconds to delay connecting member to caller */
 	int autofill;                       /*!< Ignore the head call status and ring an available agent */
-	
+
 	struct ao2_container *members;             /*!< Head of the list of members */
 	struct queue_ent *head;             /*!< Head of the list of callers */
 	AST_LIST_ENTRY(call_queue) list;    /*!< Next call queue */
@@ -1504,8 +1504,8 @@
 			q->name, q->maxlen, int2strat(q->strategy), q->count, q->holdtime, q->talktime, q->callscompleted, q->callsabandoned,  q->servicelevel, sl);
 
 		ao2_unlock(q);
-	
-		pbx_builtin_setvar_multiple(chan, interfacevar); 
+
+		pbx_builtin_setvar_multiple(chan, interfacevar);
 	} else {
 		ao2_unlock(q);
 	}
@@ -1709,7 +1709,7 @@
  * \retval 1 if the member is available
  * \retval 0 if the member is not available
  */
-static int is_member_available(struct member *mem)
+static int is_member_available(struct call_queue *q, struct member *mem)
 {
 	int available = 0;
 
@@ -1734,6 +1734,10 @@
 			break;
 	}
 
+	/* Let wrapuptimes override device state availability */
+	if (mem->lastcall && q->wrapuptime && (time(NULL) - q->wrapuptime < mem->lastcall)) {
+		available = 0;
+	}
 	return available;
 }
 
@@ -1774,7 +1778,7 @@
 
 			/* check every member until we find one NOT_INUSE */
 			if (!avail) {
-				avail = is_member_available(m);
+				avail = is_member_available(q, m);
 			}
 			if (avail && found_member) {
 				/* early exit as we've found an available member and the member of interest */
@@ -1959,7 +1963,7 @@
 		return 0;
 	} else if (c > 96) {
 		return c - 64;
-	} 
+	}
 	return c - 32;
 }
 
@@ -2123,7 +2127,7 @@
 	}
 
 	contentdup = ast_strdupa(content);
-	
+
 	if (!(maxstr = strchr(contentdup, ','))) {
 		ast_log(LOG_WARNING, "Improperly formatted penaltychange rule at line %d. Ignoring.\n", linenum);
 		ast_free(rule);
@@ -2144,7 +2148,7 @@
 	if ((minstr = strchr(maxstr,','))) {
 		*minstr++ = '\0';
 	}
-	
+
 	/* The last check will evaluate true if either no penalty change is indicated for a given rule
 	 * OR if a min penalty change is indicated but no max penalty change is */
 	if (*maxstr == '+' || *maxstr == '-' || *maxstr == '\0') {
@@ -2176,7 +2180,7 @@
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
-	
+
 		if (!inserted) {
 			AST_LIST_INSERT_TAIL(&rl_iter->rules, rule, list);
 			inserted = 1;
@@ -2229,7 +2233,7 @@
 }
 
 /*! \brief Configure a queue parameter.
- * 
+ *
  * The failunknown flag is set for config files (and static realtime) to show
  * errors for unknown parameters. It is cleared for dynamic realtime to allow
  *  extra fields in the tables.
@@ -2238,7 +2242,7 @@
 */
 static void queue_set_param(struct call_queue *q, const char *param, const char *val, int linenum, int failunknown)
 {
-	if (!strcasecmp(param, "musicclass") || 
+	if (!strcasecmp(param, "musicclass") ||
 		!strcasecmp(param, "music") || !strcasecmp(param, "musiconhold")) {
 		ast_string_field_set(q, moh, val);
 	} else if (!strcasecmp(param, "announce")) {
@@ -2645,7 +2649,7 @@
 				ao2_unlock(q);
 				queue_t_unref(q, "Queue is dead; can't return it");
 				return NULL;
-			} 
+			}
 			ast_log(LOG_WARNING, "Static queue '%s' already exists. Not loading from realtime\n", q->name);
 			ao2_unlock(q);
 			return q;
@@ -3246,7 +3250,7 @@
 }
 
 /*! \brief Caller leaving queue.
- * 
+ *
  * Search the queue to find the leaving client, if found remove from queue
  * create manager event, move others up the queue.
 */
@@ -3384,7 +3388,7 @@
 	mem_iter = ao2_iterator_init(q->members, 0);
 	while ((mem = ao2_iterator_next(&mem_iter))) {
 
-		avl += is_member_available(mem);
+		avl += is_member_available(q, mem);
 		ao2_ref(mem, -1);
 
 		/* If autofill is not enabled or if the queue's strategy is ringall, then
@@ -3596,11 +3600,11 @@
 	return 1;
 }
 
-/*! 
+/*!
  * \brief Part 2 of ring_one
  *
- * Does error checking before attempting to request a channel and call a member. 
- * This function is only called from ring_one(). 
+ * Does error checking before attempting to request a channel and call a member.
+ * This function is only called from ring_one().
  * Failure can occur if:
  * - Agent on call
  * - Agent is paused
@@ -3675,7 +3679,7 @@
 		} else if (!ast_strlen_zero(ast_channel_dialed(qe->chan)->number.str)) {
 			ast_set_callerid(tmp->chan, ast_channel_dialed(qe->chan)->number.str, NULL, NULL);
 		} else if (!ast_strlen_zero(S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)))) {
-			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL); 
+			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL);
 		}
 		tmp->dial_callerid_absent = 1;
 	}
@@ -3807,7 +3811,7 @@
 	return best;
 }
 
-/*! 
+/*!
  * \brief Place a call to a queue member.
  *
  * Once metrics have been calculated for each member, this function is used
@@ -3841,7 +3845,7 @@
 			ast_debug(1, "Trying '%s' with metric %d\n", best->interface, best->metric);
 			ret = ring_entry(qe, best, busies);
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			ast_debug(1, "Queue timed out while ringing members.\n");
@@ -3923,14 +3927,14 @@
 	}
 
 	ast_verb(3, "Playing periodic announcement\n");
-	
+
 	if (qe->parent->randomperiodicannounce && qe->parent->numperiodicannounce) {
 		qe->last_periodic_announce_sound = ((unsigned long) ast_random()) % qe->parent->numperiodicannounce;
-	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce || 
+	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce ||
 		ast_str_strlen(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]) == 0) {
 		qe->last_periodic_announce_sound = 0;
 	}
-	
+
 	/* play the announcement */
 	res = play_file(qe->chan, ast_str_buffer(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]));
 
@@ -3958,7 +3962,7 @@
 	if (!qe->parent->randomperiodicannounce) {
 		qe->last_periodic_announce_sound++;
 	}
-	
+
 	return res;
 }
 
@@ -4601,7 +4605,7 @@
  	if (qe->parent->periodicannouncefrequency && qe->parent->announce_to_first_user) {
  		say_periodic_announcement(qe, ringing);
  	}
- 
+
 	if (!*to) {
 		for (o = start; o; o = o->call_next) {
 			rna(orig, qe, o->interface, o->member->membername, 1);
@@ -4619,7 +4623,7 @@
 	return peer;
 }
 
-/*! 
+/*!
  * \brief Check if we should start attempting to call queue members.
  *
  * A simple process, really. Count the number of members who are available
@@ -4649,11 +4653,11 @@
 		if (!ch->pending) {
 			idx++;
 		}
-		ch = ch->next;			
+		ch = ch->next;
 	}
 
 	ao2_unlock(qe->parent);
-	/* If the queue entry is within avl [the number of available members] calls from the top ... 
+	/* If the queue entry is within avl [the number of available members] calls from the top ...
 	 * Autofill and position check added to support autofill=no (as only calls
 	 * from the front of the queue are valid when autofill is disabled)
 	 */
@@ -4678,7 +4682,7 @@
 {
 	int max_penalty = qe->pr->max_relative ? qe->max_penalty + qe->pr->max_value : qe->pr->max_value;
 	int min_penalty = qe->pr->min_relative ? qe->min_penalty + qe->pr->min_value : qe->pr->min_value;
-	char max_penalty_str[20], min_penalty_str[20]; 
+	char max_penalty_str[20], min_penalty_str[20];
 	/* a relative change to the penalty could put it below 0 */
 	if (max_penalty < 0) {
 		max_penalty = 0;
@@ -4753,7 +4757,7 @@
 		if (qe->parent->periodicannouncefrequency &&
 			(res = say_periodic_announcement(qe,ringing)))
 			break;
-		
+
 		/* see if we need to move to the next penalty level for this queue */
 		while (qe->pr && ((time(NULL) - qe->start) >= qe->pr->time)) {
 			update_qe_rule(qe);
@@ -4764,7 +4768,7 @@
 			*reason = QUEUE_TIMEOUT;
 			break;
 		}
-		
+
 		/* Wait a second before checking again */
 		if ((res = ast_waitfordigit(qe->chan, RECHECK * 1000))) {
 			if (res > 0 && !valid_exit(qe, res)) {
@@ -4773,7 +4777,7 @@
 				break;
 			}
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			*reason = QUEUE_TIMEOUT;
@@ -4816,7 +4820,7 @@
 		member->calls++;
 		member->lastqueue = q;
 		ao2_unlock(q);
-	}	
+	}
 	ao2_lock(q);
 	q->callscompleted++;
 	if (callcompletedinsl) {
@@ -5024,7 +5028,7 @@
 				(long) (time(NULL) - callstart), qe->opos);
 
 	update_queue(qe->parent, member, callcompletedinsl, (time(NULL) - callstart));
-	
+
 	/* No need to lock the channels because they are already locked in ast_do_masquerade */
 	if ((datastore = ast_channel_datastore_find(old_chan, &queue_transfer_info, NULL))) {
 		ast_channel_datastore_remove(old_chan, datastore);
@@ -5123,7 +5127,7 @@
  * \param[in] qe the queue_ent structure which corresponds to the caller attempting to reach members
  * \param[in] opts the options passed as the third parameter to the Queue() application
  * \param[in] opt_args the options passed as the third parameter to the Queue() application
- * \param[in] announceoverride filename to play to user when waiting 
+ * \param[in] announceoverride filename to play to user when waiting
  * \param[in] url the url passed as the fourth parameter to the Queue() application
  * \param[in,out] tries the number of times we have tried calling queue members
  * \param[out] noption set if the call to Queue() has the 'n' option set.
@@ -5223,7 +5227,7 @@
 		ast_set_flag(&(bridge_config.features_caller), AST_FEATURE_PARKCALL);
 	}
 	if (ast_test_flag(&opts, OPT_NO_RETRY)) {
-		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR 
+		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR
 			|| qe->parent->strategy == QUEUE_STRATEGY_RRORDERED) {
 			(*tries)++;
 		} else {
@@ -5304,7 +5308,7 @@
 		AST_LIST_LOCK(dialed_interfaces);
 		AST_LIST_TRAVERSE(dialed_interfaces, di, list) {
 			if (!strcasecmp(cur->interface, di->interface)) {
-				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n", 
+				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n",
 					di->interface);
 				break;
 			}
@@ -5359,7 +5363,7 @@
 			   XXX If we're forcibly removed, these outgoing calls won't get
 			   hung up XXX */
 			tmp->q_next = outgoing;
-			outgoing = tmp;		
+			outgoing = tmp;
 			/* If this line is up, don't try anybody else */
 			if (outgoing->chan && (ast_channel_state(outgoing->chan) == AST_STATE_UP))
 				break;
@@ -5583,7 +5587,7 @@
 		 	pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-		
+
 		/* if setqueueentryvar is defined, make queue entry (i.e. the caller) variables available to the channel */
 		/* use  pbx_builtin_setvar to set a load of variables with one call */
 		if (qe->parent->setqueueentryvar) {
@@ -5592,7 +5596,7 @@
 			pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-	
+
 		ao2_unlock(qe->parent);
 
 		/* try to set queue variables if configured to do so*/
@@ -5636,7 +5640,7 @@
 				}
 			} else {
 				mixmonapp = pbx_findapp("MixMonitor");
-				
+
 				if (mixmonapp) {
 					ast_debug(1, "Starting MixMonitor as requested.\n");
 					if (!monitorfilename) {
@@ -5703,7 +5707,7 @@
 
 						pbx_substitute_variables_helper(qe->chan, meid2, meid, sizeof(meid) - 1);
 					}
-	
+
 					snprintf(tmpid2, sizeof(tmpid2), "%s.%s", tmpid, qe->parent->monfmt);
 
 					if (!ast_strlen_zero(monitor_exec)) {
@@ -5711,7 +5715,7 @@
 					} else {
 						snprintf(mixmonargs, sizeof(mixmonargs), "%s,b%s", tmpid2, monitor_options);
 					}
-					
+
 					ast_debug(1, "Arguments being passed to MixMonitor: %s\n", mixmonargs);
 					/* We purposely lock the CDR so that pbx_exec does not update the application data */
 					if (ast_channel_cdr(qe->chan)) {
@@ -5727,12 +5731,12 @@
 			}
 		}
 		/* Drop out of the queue at this point, to prepare for next caller */
-		leave_queue(qe);			
+		leave_queue(qe);
 		if (!ast_strlen_zero(url) && ast_channel_supports_html(peer)) {
 			ast_debug(1, "app_queue: sendurl=%s.\n", url);
 			ast_channel_sendurl(peer, url);
 		}
-		
+
 		/* run a macro for this connection if defined. The macro simply returns, no action is taken on the result */
 		/* use macro from dialplan if passed as a option, otherwise use the default queue macro */
 		if (!ast_strlen_zero(macro)) {
@@ -5869,7 +5873,7 @@
 					qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		ast_copy_string(oldcontext, ast_channel_context(qe->chan), sizeof(oldcontext));
 		ast_copy_string(oldexten, ast_channel_exten(qe->chan), sizeof(oldexten));
-	
+
 		if ((queue_end_bridge = ao2_alloc(sizeof(*queue_end_bridge), NULL))) {
 			queue_end_bridge->q = qe->parent;
 			queue_end_bridge->chan = qe->chan;
@@ -5910,7 +5914,7 @@
 					(long) (callstart - qe->start), (long) (time(NULL) - callstart), qe->opos);
 				send_agent_complete(qe, queuename, peer, member, callstart, vars, sizeof(vars), AGENT);
 			}
-			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {	
+			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {
 				ast_channel_datastore_remove(qe->chan, tds);
 			}
 			ast_channel_unlock(qe->chan);
@@ -6038,7 +6042,7 @@
 	ast_free(value);
 }
 
-/*! \brief Remove member from queue 
+/*! \brief Remove member from queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY removed member from queue
@@ -6107,7 +6111,7 @@
 	return res;
 }
 
-/*! \brief Add member to queue 
+/*! \brief Add member to queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY added member from queue
@@ -6169,7 +6173,7 @@
 				new_member->penalty, new_member->calls, (int) new_member->lastcall,
 				new_member->status, new_member->paused);
 
-			if (is_member_available(new_member)) {
+			if (is_member_available(q, new_member)) {
 				ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 			}
 
@@ -6235,7 +6239,7 @@
 					dump_queue_members(q);
 				}
 
-				if (is_member_available(mem)) {
+				if (is_member_available(q, mem)) {
 					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 				} else if (!num_available_members(q)) {
 					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
@@ -6587,7 +6591,7 @@
 				ast_log(LOG_WARNING, "Error converting penalty: %s: Out of range.\n", penalty_tok);
 				break;
 			}
-			
+
 			if (!paused_tok) {
 				ast_log(LOG_WARNING, "Error parsing persistent member string for '%s' (paused)\n", queue_name);
 				break;
@@ -6599,7 +6603,7 @@
 			}
 
 			ast_debug(1, "Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d\n", queue_name, interface, membername, penalty, paused);
-			
+
 			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface) == RES_OUTOFMEMORY) {
 				ast_log(LOG_ERROR, "Out of Memory when reloading persistent queue member\n");
 				break;
@@ -6854,7 +6858,7 @@
 		return -1;
 	}
 
-	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event, 
+	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event,
 		"%s", args.params ? args.params : "");
 
 	return 0;
@@ -6892,14 +6896,14 @@
 
 /*!\brief The starting point for all queue calls
  *
- * The process involved here is to 
+ * The process involved here is to
  * 1. Parse the options specified in the call to Queue()
  * 2. Join the queue
  * 3. Wait in a loop until it is our turn to try calling a queue member
  * 4. Attempt to call a queue member
  * 5. If 4. did not result in a bridged call, then check for between
  *    call options such as periodic announcements etc.
- * 6. Try 4 again unless some condition (such as an expiration time) causes us to 
+ * 6. Try 4 again unless some condition (such as an expiration time) causes us to
  *    exit the queue.
  */
 static int queue_exec(struct ast_channel *chan, const char *data)
@@ -7084,7 +7088,7 @@
 			record_abandoned(&qe);
 			reason = QUEUE_TIMEOUT;
 			res = 0;
-			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld", 
+			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld",
 				qe.pos, qe.opos, (long) time(NULL) - qe.start);
 			break;
 		}
@@ -7103,7 +7107,7 @@
 				goto stop;
 			}
 		}
-	
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7145,7 +7149,7 @@
 			break;
 		}
 
-		
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7194,12 +7198,12 @@
 
 	/* Don't allow return code > 0 */
 	if (res >= 0) {
-		res = 0;	
+		res = 0;
 		if (ringing) {
 			ast_indicate(chan, -1);
 		} else {
 			ast_moh_stop(chan);
-		}			
+		}
 		ast_stopstream(chan);
 	}
 
@@ -7374,6 +7378,9 @@
 			   ((m = interface_exists(q, args.interface)))) {
 			count = m->ringinuse;
 			ao2_ref(m, -1);
+		} else if (!ast_strlen_zero(args.interface)) {
+			ast_log(LOG_ERROR, "Queue member interface %s not in queue %s\n",
+				args.interface, args.queuename);
 		} else {
 			ast_log(LOG_ERROR, "Unknown option %s provided to %s, valid values are: "
 				"logged, free, ready, count, penalty, paused, ringinuse\n", args.option, cmd);
@@ -7488,7 +7495,7 @@
 		ast_log(LOG_ERROR, "%s requires an argument: queuename\n", cmd);
 		return -1;
 	}
-	
+
 	if ((q = find_load_queue_rt_friendly(data))) {
 		ao2_lock(q);
 		mem_iter = ao2_iterator_init(q->members, 0);
@@ -7622,7 +7629,7 @@
 	}
 
 	penalty = get_member_penalty (args.queuename, args.interface);
-	
+
 	if (penalty >= 0) { /* remember that buf is already '\0' */
 		snprintf (buf, len, "%d", penalty);
 	}
@@ -7718,7 +7725,7 @@
 	char *rulecat = NULL;
 	struct ast_variable *rulevar = NULL;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
-	
+
 	if (!(cfg = ast_config_load("queuerules.conf", config_flags))) {
 		ast_log(LOG_NOTICE, "No queuerules.conf file found, queues will not follow penalty rules\n");
 		return AST_MODULE_LOAD_SUCCESS;
@@ -7919,7 +7926,7 @@
  *
  * Once we have isolated a queue within reload_queues, we call this. This will either
  * reload information for the queue or if we're just reloading member information, we'll just
- * reload that without touching other settings within the queue 
+ * reload that without touching other settings within the queue
  *
  * \param cfg The configuration which we are reading
  * \param mask Tells us what information we need to reload
@@ -7955,7 +7962,7 @@
 	} else {
 		new = 0;
 	}
-	
+
 	if (!new) {
 		ao2_lock(q);
 		prev_weight = q->weight ? 1 : 0;
@@ -8074,7 +8081,7 @@
  * \param mask Gives flags telling us what information to actually reload
  * \param queuename If set to a non-zero string, then only reload information from
  * that particular queue. Otherwise inspect all queues
- * \retval -1 Failure occurred 
+ * \retval -1 Failure occurred
  * \retval 0 All clear!
  */
 static int reload_queues(int reload, struct ast_flags *mask, const char *queuename)
@@ -8198,9 +8205,9 @@
 	}
 }
 
-/*! 
- * \brief Show queue(s) status and statistics 
- * 
+/*!
+ * \brief Show queue(s) status and statistics
+ *
  * List the queues strategy, calls processed, members logged in,
  * other queue statistics such as avg hold time.
 */
@@ -8348,7 +8355,7 @@
 	return CLI_SUCCESS;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param list Space delimited list of words
@@ -8405,11 +8412,11 @@
 		/* terminating conditions satisfied, word at beginning or separated by ' ' */
 		return 1;
 	}
-	
+
 	return 0;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param line The line as typed not including the current word being completed
@@ -8475,7 +8482,7 @@
 			"       Provides summary information on a specified queue.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return complete_queue_show(a->line, a->word, a->pos, a->n);	
+		return complete_queue_show(a->line, a->word, a->pos, a->n);
 	}
 
 	return __queues_show(NULL, a->fd, a->argc, a->argv);
@@ -8585,7 +8592,7 @@
 				"Queue: %s\r\n"
 				"LoggedIn: %d\r\n"
 				"Available: %d\r\n"
-				"Callers: %d\r\n" 
+				"Callers: %d\r\n"
 				"HoldTime: %d\r\n"
 				"TalkTime: %d\r\n"
 				"LongestHoldTime: %d\r\n"
@@ -8895,7 +8902,7 @@
 {
 	const char *queuename = NULL;
 	struct ast_flags mask = {QUEUE_RESET_STATS,};
-	
+
 	queuename = astman_get_header(m, "Queue");
 
 	if (!reload_handler(1, &mask, queuename)) {
@@ -8985,7 +8992,7 @@
 		astman_send_error(s, m, "Need 'Interface' and 'Penalty' parameters.");
 		return 0;
 	}
- 
+
 	penalty = atoi(penalty_s);
 
 	if (set_member_value((char *)queuename, (char *)interface, MEMBER_PENALTY, penalty)) {
@@ -9207,7 +9214,7 @@
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue {pause|unpause} member";
-		e->usage = 
+		e->usage =
 			"Usage: queue {pause|unpause} member <member> [queue <queue> [reason <reason>]]\n"
 			"	Pause or unpause a queue member. Not specifying a particular queue\n"
 			"	will pause or unpause a member across all queues to which the member\n"
@@ -9342,7 +9349,7 @@
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue set penalty";
-		e->usage = 
+		e->usage =
 		"Usage: queue set penalty <penalty> on <interface> [in <queue>]\n"
 		"	Set a member's penalty in the queue specified. If no queue is specified\n"
 		"	then that interface's penalty is set in all queues to which that interface is a member\n";
@@ -9375,7 +9382,7 @@
 	}
 }
 
-static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state) 
+static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state)
 {
 	int which = 0;
 	struct rule_list *rl_iter;
@@ -9429,7 +9436,7 @@
 		}
 	}
 	AST_LIST_UNLOCK(&rule_lists);
-	return CLI_SUCCESS; 
+	return CLI_SUCCESS;
 }
 
 static char *handle_queue_reset(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
@@ -9535,7 +9542,7 @@
 	return CLI_SUCCESS;
 }
 
-static const char qpm_cmd_usage[] = 
+static const char qpm_cmd_usage[] =
 "Usage: queue pause member <channel> in <queue> reason <reason>\n";
 
 static const char qum_cmd_usage[] =
--- apps/app_stack.c
+++ apps/app_stack.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
  
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 371592 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/pbx.h"
 #include "asterisk/module.h"
@@ -245,8 +245,9 @@
 	}
 
 	if (!found) {
-		variables = ast_var_assign(var, "");
-		AST_LIST_INSERT_HEAD(&frame->varshead, variables, entries);
+		if ((variables = ast_var_assign(var, ""))) {
+			AST_LIST_INSERT_HEAD(&frame->varshead, variables, entries);
+		}
 		pbx_builtin_pushvar_helper(chan, var, value);
 	} else {
 		pbx_builtin_setvar_helper(chan, var, value);
--- apps/confbridge/conf_config_parser.c
+++ apps/confbridge/conf_config_parser.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 382066 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
 #include "asterisk/logger.h"
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -1320,12 +1320,10 @@
 	return 0;
 }
 
-int conf_load_config(int reload)
+int conf_load_config(void)
 {
-	if (!reload) {
-		if (aco_info_init(&cfg_info)) {
-			return -1;
-		}
+	if (aco_info_init(&cfg_info)) {
+		return -1;
 	}
 
 	/* User options */
@@ -1373,23 +1371,29 @@
 	/* Menu options */
 	aco_option_register_custom(&cfg_info, "^[0-9A-D*#]+$", ACO_REGEX, menu_types, NULL, menu_option_handler, 0);
 
-	if (aco_process_config(&cfg_info, reload) == ACO_PROCESS_ERROR) {
+	if (aco_process_config(&cfg_info, 0) == ACO_PROCESS_ERROR) {
 		goto error;
 	}
 
-	if (!reload && ast_cli_register_multiple(cli_confbridge_parser, ARRAY_LEN(cli_confbridge_parser))) {
+	if (ast_cli_register_multiple(cli_confbridge_parser, ARRAY_LEN(cli_confbridge_parser))) {
 		goto error;
 	}
 
 	return 0;
 error:
-	/* On a reload, just keep the config we already have in place. */
-	if (!reload) {
-		conf_destroy_config();
-	}
+	conf_destroy_config();
 	return -1;
 }
 
+int conf_reload_config(void)
+{
+	if (aco_process_config(&cfg_info, 1) == ACO_PROCESS_ERROR) {
+		/* On a reload, just keep the config we already have in place. */
+		return -1;
+	}
+	return 0;
+}
+
 static void conf_user_profile_copy(struct user_profile *dst, struct user_profile *src)
 {
 	*dst = *src;
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -244,7 +244,10 @@
 };
 
 /*! \brief load confbridge.conf file */
-int conf_load_config(int reload);
+int conf_load_config(void);
+
+/*! \brief reload confbridge.conf file */
+int conf_reload_config(void);
 
 /*! \brief destroy the information loaded from the confbridge.conf file*/
 void conf_destroy_config(void);
--- channels/chan_dahdi.c
+++ channels/chan_dahdi.c
@@ -49,7 +49,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387298 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394173 $")
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <pthread.h>
@@ -566,14 +566,6 @@
 #endif	/* defined(HAVE_SS7) */
 
 #ifdef HAVE_OPENR2
-struct dahdi_mfcr2 {
-	pthread_t r2master;		       /*!< Thread of master */
-	openr2_context_t *protocol_context;    /*!< OpenR2 context handle */
-	struct dahdi_pvt *pvts[SIG_MFCR2_MAX_CHANNELS];     /*!< Member channel pvt structs */
-	int numchans;                          /*!< Number of channels in this R2 block */
-	int monitored_count;                   /*!< Number of channels being monitored */
-};
-
 struct dahdi_mfcr2_conf {
 	openr2_variant_t variant;
 	int mfback_timeout;
@@ -608,6 +600,15 @@
 	openr2_calling_party_category_t category;
 };
 
+/* MFC-R2 pseudo-link structure */
+struct dahdi_mfcr2 {
+	pthread_t r2master;		       /*!< Thread of master */
+	openr2_context_t *protocol_context;    /*!< OpenR2 context handle */
+	struct dahdi_pvt *pvts[SIG_MFCR2_MAX_CHANNELS];     /*!< Member channel pvt structs */
+	int numchans;                          /*!< Number of channels in this R2 block */
+	struct dahdi_mfcr2_conf conf;         /*!< Configuration used to setup this pseudo-link */
+};
+
 /* malloc'd array of malloc'd r2links */
 static struct dahdi_mfcr2 **r2links;
 /* how many r2links have been malloc'd */
@@ -12428,14 +12429,20 @@
 	r2links_count = 0;
 }
 
-#define R2_LINK_CAPACITY 10
-static struct dahdi_mfcr2 *dahdi_r2_get_link(void)
+/* This is an artificial convenient capacity, to keep at most a full E1 of channels in a single thread */
+#define R2_LINK_CAPACITY 30
+static struct dahdi_mfcr2 *dahdi_r2_get_link(const struct dahdi_chan_conf *conf)
 {
 	struct dahdi_mfcr2 *new_r2link = NULL;
 	struct dahdi_mfcr2 **new_r2links = NULL;
-	/* this function is called just when starting up and no monitor threads have been launched,
-	   no need to lock monitored_count member */
-	if (!r2links_count || (r2links[r2links_count - 1]->monitored_count == R2_LINK_CAPACITY)) {
+
+	/* Only create a new R2 link if 
+	   1. This is the first link requested
+	   2. Configuration changed 
+	   3. We got more channels than supported per link */
+	if (!r2links_count ||
+	    memcmp(&conf->mfcr2, &r2links[r2links_count - 1]->conf, sizeof(conf->mfcr2)) ||
+	   (r2links[r2links_count - 1]->numchans == R2_LINK_CAPACITY)) {
 		new_r2link = ast_calloc(1, sizeof(**r2links));
 		if (!new_r2link) {
 			ast_log(LOG_ERROR, "Cannot allocate R2 link!\n");
@@ -12507,7 +12514,8 @@
 			ast_log(LOG_ERROR, "Failed to configure r2context from advanced configuration file %s\n", conf->mfcr2.r2proto_file);
 		}
 	}
-	r2_link->monitored_count = 0;
+	/* Save the configuration used to setup this link */
+	memcpy(&r2_link->conf, conf, sizeof(r2_link->conf));
 	return 0;
 }
 #endif
@@ -12738,7 +12746,7 @@
 #ifdef HAVE_OPENR2
 			if (chan_sig == SIG_MFCR2) {
 				struct dahdi_mfcr2 *r2_link;
-				r2_link = dahdi_r2_get_link();
+				r2_link = dahdi_r2_get_link(conf);
 				if (!r2_link) {
 					ast_log(LOG_WARNING, "Cannot get another R2 DAHDI context!\n");
 					destroy_dahdi_pvt(tmp);
@@ -12780,7 +12788,6 @@
 				tmp->mfcr2call = 0;
 				tmp->mfcr2_dnis_index = 0;
 				tmp->mfcr2_ani_index = 0;
-				r2_link->monitored_count++;
 			}
 #endif
 #ifdef HAVE_PRI
@@ -15452,6 +15459,7 @@
 	dahdi_softhangup_all();
 	ast_verb(4, "Final softhangup of all DAHDI channels complete.\n");
 	destroy_all_channels();
+	memset(round_robin, 0, sizeof(round_robin));
 	ast_debug(1, "Channels destroyed. Now re-reading config. %d active channels remaining.\n", ast_active_channels());
 
 	ast_mutex_unlock(&monlock);
--- channels/chan_iax2.c
+++ channels/chan_iax2.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394181 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391334 $")
 
 #include <sys/mman.h>
 #include <dirent.h>
--- channels/chan_motif.c
+++ channels/chan_motif.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377462 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include <sys/socket.h>
 #include <fcntl.h>
@@ -2555,9 +2555,9 @@
 	aco_option_register_custom(&cfg_info, "connection", ACO_EXACT, endpoint_options, NULL, custom_connection_handler, 0);
 	aco_option_register_custom(&cfg_info, "transport", ACO_EXACT, endpoint_options, NULL, custom_transport_handler, 0);
 	aco_option_register(&cfg_info, "maxicecandidates", ACO_EXACT, endpoint_options, DEFAULT_MAX_ICE_CANDIDATES, OPT_UINT_T, PARSE_DEFAULT,
-			    FLDSET(struct jingle_endpoint, maxicecandidates));
+			    FLDSET(struct jingle_endpoint, maxicecandidates), DEFAULT_MAX_ICE_CANDIDATES);
 	aco_option_register(&cfg_info, "maxpayloads", ACO_EXACT, endpoint_options, DEFAULT_MAX_PAYLOADS, OPT_UINT_T, PARSE_DEFAULT,
-			    FLDSET(struct jingle_endpoint, maxpayloads));
+			    FLDSET(struct jingle_endpoint, maxpayloads), DEFAULT_MAX_PAYLOADS);
 
 	ast_format_cap_add_all_by_type(jingle_tech.capabilities, AST_FORMAT_TYPE_AUDIO);
 
@@ -2608,6 +2608,8 @@
 static int unload_module(void)
 {
 	ast_channel_unregister(&jingle_tech);
+	ast_format_cap_destroy(jingle_tech.capabilities);
+	jingle_tech.capabilities = NULL;
 	ast_rtp_glue_unregister(&jingle_rtp_glue);
 	ast_sched_context_destroy(sched);
 	aco_info_destroy(&cfg_info);
--- channels/chan_sip.c
+++ channels/chan_sip.c
@@ -210,7 +210,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388601 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397254 $")
 
 #include <signal.h>
 #include <sys/signal.h>
@@ -15159,6 +15159,8 @@
 			append_history(p, "RegistryInit", "Account: %s@%s", r->username, r->hostname);
 		}
 
+		p->socket.type = r->transport;
+
 		/* Use port number specified if no SRV record was found */
 		if (!ast_sockaddr_isnull(&r->us)) {
 			if (!ast_sockaddr_port(&r->us) && r->portno) {
@@ -16020,7 +16022,7 @@
 	if (ast_apply_acl(sip_cfg.contact_acl, &peer->addr, "SIP contact ACL: ") != AST_SENSE_ALLOW ||
 			ast_apply_acl(peer->contactacl, &peer->addr, "SIP contact ACL: ") != AST_SENSE_ALLOW) {
 		ast_log(LOG_WARNING, "Domain '%s' disallowed by contact ACL (violating IP %s)\n", hostport,
-			ast_sockaddr_stringify_addr(&testsa));
+				ast_sockaddr_stringify_addr(&peer->addr));
 		ast_string_field_set(peer, fullcontact, "");
 		ast_string_field_set(pvt, our_contact, "");
 		return PARSE_REGISTER_DENIED;
@@ -18558,7 +18560,24 @@
 		ast_string_field_set(p, context, sip_cfg.messagecontext);
 	}
 
-	get_destination(p, NULL, NULL);
+	switch (get_destination(p, NULL, NULL)) {
+	case SIP_GET_DEST_REFUSED:
+		/* Okay to send 403 since this is after auth processing */
+		transmit_response(p, "403 Forbidden", req);
+		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
+		return;
+	case SIP_GET_DEST_INVALID_URI:
+		transmit_response(p, "416 Unsupported URI Scheme", req);
+		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
+		return;
+	case SIP_GET_DEST_EXTEN_NOT_FOUND:
+	case SIP_GET_DEST_EXTEN_MATCHMORE:
+		transmit_response(p, "404 Not Found", req);
+		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
+		return;
+	case SIP_GET_DEST_EXTEN_FOUND:
+		break;
+	}
 
 	if (!(msg = ast_msg_alloc())) {
 		transmit_response(p, "500 Internal Server Error", req);
@@ -23013,8 +23032,8 @@
 					wait = ast_random() % 2000;
 				}
 				p->waitid = ast_sched_add(sched, wait, sip_reinvite_retry, dialog_ref(p, "passing dialog ptr into sched structure based on waitid for sip_reinvite_retry."));
-				ast_log(LOG_WARNING, "just did sched_add waitid(%d) for sip_reinvite_retry for dialog %s in handle_response_invite\n", p->waitid, p->callid);
-				ast_debug(2, "Reinvite race. Waiting %d secs before retry\n", wait);
+				ast_debug(2, "Reinvite race. Scheduled sip_reinvite_retry in %d secs in handle_response_invite (waitid %d, dialog '%s')\n",
+						wait, p->waitid, p->callid);
 			}
 		}
 		break;
@@ -26830,6 +26849,21 @@
 
 			sender = ast_strdupa(from);
 			ast_callerid_parse(sender, &name, &location);
+			if (ast_strlen_zero(location)) {
+				/* This can occur if either
+				 *  1) A name-addr style From header does not close the angle brackets
+				 *  properly.
+				 *  2) The From header is not in name-addr style and the content of the
+				 *  From contains characters other than 0-9, *, #, or +.
+				 *
+				 *  In both cases, ast_callerid_parse() should have parsed the From header
+				 *  as a name rather than a number. So we just need to set the location
+				 *  to what was parsed as a name, and set the name NULL since there was
+				 *  no name present.
+				 */
+				location = name;
+				name = NULL;
+			}
 			ast_string_field_set(pvt, fromname, name);
 			if (strchr(location, ':')) { /* Must be a URI */
 				parse_uri(location, "sip:,sips:", &user, NULL, &domain, NULL);
@@ -28349,9 +28383,7 @@
 
 	copy_socket_data(&p->socket, &req->socket);
 
-	if (ast_sockaddr_isnull(&p->recv)) { /* This may already be set before getting here */
-		ast_sockaddr_copy(&p->recv, addr);
-	}
+	ast_sockaddr_copy(&p->recv, addr);
 
 	/* if we have an owner, then this request has been authenticated */
 	if (p->owner) {
--- channels/chan_unistim.c
+++ channels/chan_unistim.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 389661 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396377 $")
 
 #include <sys/stat.h>
 #include <signal.h>
@@ -2903,7 +2903,11 @@
 			send_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext("Enter the number to dial", pte));
 			send_text(TEXT_LINE1, TEXT_NORMAL, pte, ustmtext("and press Call", pte));
 		}
-		send_text_status(pte, ustmtext("Call   Redial BackSp Erase", pte));
+		if (ast_strlen_zero(pte->device->redial_number)) {
+			send_text_status(pte, ustmtext("Call          BackSp Erase", pte));
+		} else {
+			send_text_status(pte, ustmtext("Call   Redial BackSp Erase", pte));
+		}
 	}
 
 	pte->device->size_phone_number = 0;
@@ -3298,6 +3302,8 @@
 static void key_call(struct unistimsession *pte, char keycode)
 {
 	struct unistim_subchannel *sub = get_sub(pte->device, SUB_REAL);
+	struct unistim_subchannel *sub_3way = get_sub(pte->device, SUB_THREEWAY);
+
 	if ((keycode >= KEY_0) && (keycode <= KEY_SHARP)) {
 		if (keycode == KEY_SHARP) {
 			keycode = '#';
@@ -3312,23 +3318,21 @@
 	switch (keycode) {
 	case KEY_FUNC1:
 		if (ast_channel_state(sub->owner) == AST_STATE_UP) {
-			if (get_sub(pte->device, SUB_THREEWAY)) {
+			if (sub_3way) {
 				close_call(pte);
 			}
 		}
 		break;
 	case KEY_FUNC2:
-		if (ast_channel_state(sub->owner) == AST_STATE_UP) {
-			if (get_sub(pte->device, SUB_THREEWAY)) {
-				transfer_cancel_step2(pte);
-			} else {
-				transfer_call_step1(pte);
-			}
+		if (sub_3way) {
+			transfer_cancel_step2(pte);
+		} else if (ast_channel_state(sub->owner) == AST_STATE_UP) {
+			transfer_call_step1(pte);
 		}
 		break;
 	case KEY_HANGUP:
 	case KEY_FUNC4:
-		if (!get_sub(pte->device, SUB_THREEWAY)) {
+		if (!sub_3way) {
 			close_call(pte);
 		}
 		break;
@@ -4010,13 +4014,24 @@
 			send_text(TEXT_LINE1, TEXT_NORMAL, pte, pte->device->call_forward);
 		}
 		send_icon(TEXT_LINE0, FAV_ICON_REFLECT + FAV_BLINK_SLOW, pte);
-		send_text_status(pte, ustmtext("Dial   Redial NoFwd  ", pte));
+		if (ast_strlen_zero(pte->device->redial_number)) {
+			send_text_status(pte, ustmtext("Dial          NoFwd  ", pte));
+		} else {
+			send_text_status(pte, ustmtext("Dial   Redial NoFwd  ", pte));
+		}
 	} else {
-		if ((pte->device->extension == EXTENSION_ASK) ||
-			(pte->device->extension == EXTENSION_TN)) {
-			send_text_status(pte, ustmtext("Dial   Redial Fwd    Unregis", pte));
+		if ((pte->device->extension == EXTENSION_ASK) || (pte->device->extension == EXTENSION_TN)) {
+			if (ast_strlen_zero(pte->device->redial_number)) {
+				send_text_status(pte, ustmtext("Dial          Fwd    Unregis", pte));
+			} else {
+				send_text_status(pte, ustmtext("Dial   Redial Fwd    Unregis", pte));
+			}
 		} else {
-			send_text_status(pte, ustmtext("Dial   Redial Fwd    Pickup", pte));
+			if (ast_strlen_zero(pte->device->redial_number)) {
+				send_text_status(pte, ustmtext("Dial          Fwd    Pickup", pte));
+			} else {
+				send_text_status(pte, ustmtext("Dial   Redial Fwd    Pickup", pte));
+			}
 		}
 		send_text(TEXT_LINE1, TEXT_NORMAL, pte, pte->device->maintext1);
 		if (pte->device->missed_call == 0) {
@@ -4777,7 +4792,7 @@
 	struct unistim_line *l;
 	struct unistim_device *d;
 	struct unistimsession *s;
-	int i;
+	int i,end_call = 1;
 
 	s = channel_to_session(ast);
 	sub = ast_channel_tech_pvt(ast);
@@ -4792,8 +4807,8 @@
 		ast_verb(0, "unistim_hangup(%s) on %s@%s (STATE_%s)\n", ast_channel_name(ast), l->name, l->parent->name, ptestate_tostr(s->state));
 	}
 	sub_trans = get_sub(d, SUB_THREEWAY);
-	if (sub_trans && (sub_trans->owner) && (sub->subtype == SUB_REAL) &&
-		(sub->alreadygone == 0)) {
+	sub_real = get_sub(d, SUB_REAL);
+	if (sub_trans && (sub_trans->owner) && (sub->subtype == SUB_REAL)) { /* 3rd party busy or congested and transfer_cancel_step2 does not called */
 		if (unistimdebug) {
 			ast_verb(0, "Threeway call disconnected, switching to real call\n");
 		}
@@ -4803,16 +4818,13 @@
 		sub_trans->moh = 0;
 		sub_trans->subtype = SUB_REAL;
 		swap_subs(sub_trans, sub);
-
 		send_text_status(s, ustmtext("       Transf        Hangup", s));
 		send_callerid_screen(s, sub_trans);
 		unistim_hangup_clean(ast, sub);
 		unistim_unalloc_sub(d, sub);
 		return 0;
 	}
-	sub_real = get_sub(d, SUB_REAL);
-	if (sub_real && (sub_real->owner) && (sub->subtype == SUB_THREEWAY) &&
-		(sub->alreadygone == 0)) {
+	if (sub_real && (sub_real->owner) && (sub->subtype == SUB_THREEWAY)) { /* 3way call cancelled by softkey pressed */
 		if (unistimdebug) {
 			ast_verb(0, "Real call disconnected, stay in call\n");
 		}
@@ -4822,10 +4834,8 @@
 		unistim_unalloc_sub(d, sub);
 		return 0;
 	}
-
 	if (sub->subtype == SUB_REAL) {
 		sub_stop_silence(s, sub);
-		send_end_call(s); /* Send end call packet only if ending active call, in other way sound should be loosed */
 	} else if (sub->subtype == SUB_RING) {
 		send_no_ring(s);
 		for (i = 0; i < FAVNUM; i++) {
@@ -4836,9 +4846,16 @@
 			if (is_key_line(d, i) && !strcmp(l->name, d->sline[i]->name)) {
 				send_favorite_short(i, FAV_LINE_ICON, s);
 				d->ssub[i] = NULL;
+				continue;
+			}
+			if (d->ssub[i] != NULL) { /* Found other subchannel active other then hangup'ed one */
+				end_call = 0;
 			}
 		}
 	}
+	if (end_call) {
+		send_end_call(s); /* Send end call packet only if ending active call, in other way sound should be loosed */
+	}
 	sub->moh = 0;
 	if (sub->softkey >= 0) {
 		send_favorite_short(sub->softkey, FAV_LINE_ICON, s);
@@ -6132,7 +6149,7 @@
 			return 0;
 		}
 		if (d->softkeyicon[p] != 0) {
-			ast_log(LOG_WARNING, "Invalid position %d for bookmark : already used\n:", p);
+			ast_log(LOG_WARNING, "Invalid position %d for bookmark : already used:\n", p);
 			return 0;
 		}
 		memmove(line, line + 2, sizeof(line) - 2);
--- channels/sig_pri.c
+++ channels/sig_pri.c
@@ -9286,7 +9286,7 @@
 			info_str = pri_dump_info_str(pri->pri);
 			if (info_str) {
 				ast_cli(fd, "%s", info_str);
-				free(info_str);
+				ast_std_free(info_str);
 			}
 #else
 			pri_dump_info(pri->pri);
--- channels/sip/dialplan_functions.c
+++ channels/sip/dialplan_functions.c
@@ -25,7 +25,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 369013 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397133 $")
 
 #include <math.h>
 
@@ -353,7 +353,7 @@
 		goto done;
 	}
 	ast_channel_tech_set(chan, &sip_tech);
-	ast_channel_tech_pvt_set(chan, p);
+	ast_channel_tech_pvt_set(chan, dialog_ref(p, "Give the owner channel a reference to the dialog"));
 	p->owner = chan;
 
 	varstr = ast_str_create(16);
@@ -397,8 +397,9 @@
 	ast_free(varstr);
 	ast_free(buffer);
 
-	/* This unref will take care of destroying the channel, RTP instance, and SIP pvt */
+	/* This unlink and unref will take care of destroying the channel, RTP instance, and SIP pvt */
 	if (p) {
+		dialog_unlink_all(p);
 		dialog_unref(p, "Destroy test object");
 	}
 	ast_rtp_engine_unregister(&test_engine);
--- configs/h323.conf.sample
+++ configs/h323.conf.sample
@@ -29,6 +29,8 @@
 ;allow=gsm		; Always allow GSM, it's cool :)
 ;allow=ulaw		; see https://wiki.asterisk.org/wiki/display/AST/RTP+Packetization
 			; for framing options
+;autoframing=yes	; Set packetization based on the remote endpoint's (ptime)
+			; preferences. Defaults to no.
 ;
 ; User-Input Mode (DTMF)
 ;
--- configs/iax.conf.sample
+++ configs/iax.conf.sample
@@ -607,6 +607,15 @@
 ; IPs can also optionally be given but are not required.  Caller*ID can be
 ; suggested to the other side as well if it is for example a phone instead of
 ; another PBX.
+;connectedline=yes ; Set how connected line information is handled for this
+;                  ; peer. If set to "yes", both sending and receiving
+;                  ; connected line information will be enabled. If set to
+;                  ; "send", this peer will send connected line information
+;                  ; but will not process connected line updates. If set to
+;                  ; "receive", connected line updates will be processed
+;                  ; but not sent. If set to "no", connected line updates
+;                  ; will be disabled. Default is "no".
+
 
 ;[dynamichost]
 ;host=dynamic
--- configs/indications.conf.sample
+++ configs/indications.conf.sample
@@ -434,7 +434,7 @@
 ringcadence = 2000,4000
 dial = 425
 busy = 425/500,0/500
-ring = 425/400,0/200
+ring = 425/400,0/200,425/400,0/2000
 congestion = 425/500,0/500
 
 [nl]
--- configs/sip.conf.sample
+++ configs/sip.conf.sample
@@ -310,6 +310,8 @@
 ;allow=ulaw                     ; Allow codecs in order of preference
 ;allow=ilbc                     ; see https://wiki.asterisk.org/wiki/display/AST/RTP+Packetization
 				; for framing options
+;autoframing=yes		; Set packetization based on the remote endpoint's (ptime)
+				; preferences. Defaults to no.
 ;
 ; This option specifies a preference for which music on hold class this channel
 ; should listen to when put on hold if the music class has not been set on the
@@ -1192,6 +1194,7 @@
 ; language
 ; allow
 ; disallow
+; autoframing
 ; insecure
 ; trustrpid
 ; progressinband
--- configs/sla.conf.sample
+++ configs/sla.conf.sample
@@ -15,6 +15,17 @@
 ; -------------------------------------
 
 
+; ********************************
+; **** Configuration Ordering ****
+; ********************************
+
+; Note that SLA configuration processing assumes that *all* trunk declarations are
+; listed in the configuration file before any stations.
+
+; ********************************
+; ********************************
+
+
 ; ---- Trunk Declarations -------------
 ;
 ;[line1]                    ; Provide a name for this trunk.
--- contrib/realtime/postgresql/realtime.sql
+++ contrib/realtime/postgresql/realtime.sql
@@ -136,6 +136,23 @@
 PRIMARY KEY (queue_name, interface)
 ) WITHOUT OIDS;
 
+drop table queue_log;
+CREATE TABLE "queue_log" (
+"id" SERIAL,
+"time" TIMESTAMP WITHOUT TIME ZONE DEFAULT now() NOT NULL,
+"callid" character varying(50) NOT NULL,
+"queuename" character varying(50) NOT NULL,
+"agent" character varying(50) NOT NULL,
+"event" character varying(20) NOT NULL,
+"data1" character varying(50) NOT NULL,
+"data2" character varying(50) NOT NULL,
+"data3" character varying(50) NOT NULL,
+"data4" character varying(50) NOT NULL,
+"data5" character varying(50) NOT NULL,
+CONSTRAINT queue_log_pkey PRIMARY KEY (id)
+) WITHOUT OIDS;
+
+GRANT ALL ON TABLE queue_log TO asterisk;
 GRANT ALL ON TABLE cdr TO asterisk;
 GRANT ALL ON TABLE extensions_conf TO asterisk;
 GRANT ALL ON TABLE sip_conf TO asterisk;
--- default.exports
+++ default.exports
@@ -1,4 +1,8 @@
 {
+	global:
+		/* See main/asterisk.exports.in for an explanation why this is
+		 * needed. */
+		_IO_stdin_used;
 	local:
 		*;
 };
--- funcs/func_channel.c
+++ funcs/func_channel.c
@@ -20,7 +20,7 @@
  *
  * \author Kevin P. Fleming <kpfleming@digium.com>
  * \author Ben Winslow
- * 
+ *
  * \ingroup functions
  */
 
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 384641 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394981 $")
 
 #include <regex.h>
 #include <ctype.h>
@@ -253,16 +253,35 @@
 						<para>     <literal>audio</literal>             Get audio destination</para>
 						<para>     <literal>video</literal>             Get video destination</para>
 						<para>     <literal>text</literal>              Get text destination</para>
+						<para>   Defaults to <literal>audio</literal> if unspecified.</para>
+					</enum>
+					<enum name="rtpsource">
+						<para>R/O Get source RTP destination information.</para>
+						<para>   This option takes one additional argument:</para>
+						<para>    Argument 1:</para>
+						<para>     <literal>audio</literal>             Get audio destination</para>
+						<para>     <literal>video</literal>             Get video destination</para>
+						<para>     <literal>text</literal>              Get text destination</para>
+						<para>   Defaults to <literal>audio</literal> if unspecified.</para>
 					</enum>
 				</enumlist>
 				<para><emphasis>chan_iax2</emphasis> provides the following additional options:</para>
 				<enumlist>
+					<enum name="osptoken">
+						<para>R/O Get the peer's osptoken.</para>
+					</enum>
 					<enum name="peerip">
 						<para>R/O Get the peer's ip address.</para>
 					</enum>
 					<enum name="peername">
 						<para>R/O Get the peer's username.</para>
 					</enum>
+					<enum name="secure_signaling">
+						<para>R/O Get the if the IAX channel is secured.</para>
+					</enum>
+					<enum name="secure_media">
+						<para>R/O Get the if the IAX channel is secured.</para>
+					</enum>
 				</enumlist>
 				<para><emphasis>chan_dahdi</emphasis> provides the following additional options:</para>
 				<enumlist>
@@ -320,17 +339,35 @@
 				<para><emphasis>chan_ooh323</emphasis> provides the following additional options:</para>
 				<enumlist>
 					<enum name="faxdetect">
-						<para>Fax Detect [R/W]</para>
+						<para>R/W Fax Detect</para>
 						<para>Returns 0 or 1</para>
 						<para>Write yes or no</para>
 					</enum>
 					<enum name="t38support">
-						<para>t38support [R/W]</para>
+						<para>R/W t38support</para>
 						<para>Returns 0 or 1</para>
 						<para>Write yes or no</para>
 					</enum>
-					<enum name="h323id">
-						<para>Returns h323id [R]</para>
+					<enum name="h323id_url">
+						<para>R/0 Returns caller URL</para>
+ 					</enum>
+					<enum name="caller_h323id">
+						<para>R/0 Returns caller h323id</para>
+					</enum>
+					<enum name="caller_dialeddigits">
+						<para>R/0 Returns caller dialed digits</para>
+					</enum>
+					<enum name="caller_email">
+						<para>R/0 Returns caller email</para>
+					</enum>
+					<enum name="callee_email">
+						<para>R/0 Returns callee email</para>
+					</enum>
+					<enum name="callee_dialeddigits">
+						<para>R/0 Returns callee dialed digits</para>
+					</enum>
+					<enum name="caller_url">
+						<para>R/0 Returns caller URL</para>
 					</enum>
 				</enumlist>
 			</parameter>
@@ -538,7 +575,7 @@
 #ifdef CHANNEL_TRACE
 	else if (!strcasecmp(data, "trace")) {
 		ast_channel_lock(chan);
-		if (ast_true(value)) 
+		if (ast_true(value))
 			ret = ast_channel_trace_enable(chan);
 		else if (ast_false(value))
 			ret = ast_channel_trace_disable(chan);
@@ -553,7 +590,7 @@
 		struct ast_tone_zone *new_zone;
 		if (!(new_zone = ast_get_indication_zone(value))) {
 			ast_log(LOG_ERROR, "Unknown country code '%s' for tonezone. Check indications.conf for available country codes.\n", value);
-			ret = -1;	
+			ret = -1;
 		} else {
 			ast_channel_lock(chan);
 			if (ast_channel_zone(chan)) {
--- funcs/func_global.c
+++ funcs/func_global.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include <sys/stat.h>
 
@@ -253,15 +253,16 @@
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 
-	var = ast_var_assign(args.var, S_OR(value, ""));
-	AST_LIST_INSERT_HEAD(varshead, var, entries);
-	manager_event(EVENT_FLAG_DIALPLAN, "VarSet", 
-		"Channel: %s\r\n"
-		"Variable: SHARED(%s)\r\n"
-		"Value: %s\r\n"
-		"Uniqueid: %s\r\n", 
-		chan ? ast_channel_name(chan) : "none", args.var, value, 
-		chan ? ast_channel_uniqueid(chan) : "none");
+	if ((var = ast_var_assign(args.var, S_OR(value, "")))) {
+		AST_LIST_INSERT_HEAD(varshead, var, entries);
+		manager_event(EVENT_FLAG_DIALPLAN, "VarSet", 
+			"Channel: %s\r\n"
+			"Variable: SHARED(%s)\r\n"
+			"Value: %s\r\n"
+			"Uniqueid: %s\r\n", 
+			chan ? ast_channel_name(chan) : "none", args.var, value, 
+			chan ? ast_channel_uniqueid(chan) : "none");
+	}
 
 	ast_channel_unlock(chan);
 
--- funcs/func_strings.c
+++ funcs/func_strings.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396310 $")
 
 #include <regex.h>
 #include <ctype.h>
@@ -165,6 +165,10 @@
 			<para>Literally returns the given <replaceable>string</replaceable>.  The intent is to permit
 			other dialplan functions which take a variable name as an argument to be able to take a literal
 			string, instead.</para>
+			<note><para>The functions which take a variable name need to be passed var and not
+			${var}.  Similarly, use PASSTHRU() and not ${PASSTHRU()}.</para></note>
+			<para>Example: ${CHANNEL} contains SIP/321-1</para>
+			<para>         ${CUT(PASSTHRU(${CUT(CHANNEL,-,1)}),/,2)}) will return 321</para>
 		</description>
 	</function>
 	<function name="REGEX" language="en_US">
@@ -1694,6 +1698,12 @@
 
 	for (i = 0; i < ARRAY_LEN(test_args); i++) {
 		struct ast_var_t *var = ast_var_assign("FIELDS", test_args[i].fields);
+		if (!var) {
+			ast_test_status_update(test, "Out of memory\n");
+			res = AST_TEST_FAIL;
+			break;
+		}
+
 		AST_LIST_INSERT_HEAD(ast_channel_varshead(chan), var, entries);
 
 		snprintf(expression, sizeof(expression), "${FIELDNUM(%s,%s,%s)}", var->name, test_args[i].delim, test_args[i].field);
@@ -1796,6 +1806,13 @@
 		char tmp[512], tmp2[512] = "";
 
 		struct ast_var_t *var = ast_var_assign("test_string", test_strings[i][0]);
+		if (!var) {
+			ast_test_status_update(test, "Unable to allocate variable\n");
+			ast_free(str);
+			ast_channel_release(chan);
+			return AST_TEST_FAIL;
+		}
+			
 		AST_LIST_INSERT_HEAD(ast_channel_varshead(chan), var, entries);
 
 		if (test_strings[i][3]) {
--- include/asterisk/astmm.h
+++ include/asterisk/astmm.h
@@ -54,6 +54,12 @@
 #undef vasprintf
 #undef free
 
+void *ast_std_malloc(size_t size);
+void *ast_std_calloc(size_t nmemb, size_t size);
+void *ast_std_realloc(void *ptr, size_t size);
+void ast_std_free(void *ptr);
+void ast_free_ptr(void *ptr);
+
 void *__ast_calloc(size_t nmemb, size_t size, const char *file, int lineno, const char *func);
 void *__ast_calloc_cache(size_t nmemb, size_t size, const char *file, int lineno, const char *func);
 void *__ast_malloc(size_t size, const char *file, int lineno, const char *func);
--- include/asterisk/frame.h
+++ include/asterisk/frame.h
@@ -296,12 +296,16 @@
 };
 
 enum ast_control_t38_rate {
-	AST_T38_RATE_2400 = 0,
+	AST_T38_RATE_2400 = 1,
 	AST_T38_RATE_4800,
 	AST_T38_RATE_7200,
 	AST_T38_RATE_9600,
 	AST_T38_RATE_12000,
-	AST_T38_RATE_14400,
+	/* Set to 0 so it's taken as default when unspecified.
+	 * See ITU-T T.38 Implementors' Guide (11 May 2012),
+	 * Table H.2: if the T38MaxBitRate attribute is omitted
+	 * it should use a default of 14400. */
+	AST_T38_RATE_14400 = 0,
 };
 
 enum ast_control_t38_rate_management {
--- include/asterisk/lock.h
+++ include/asterisk/lock.h
@@ -289,22 +289,6 @@
 #endif /* HAVE_BKTR */
 #endif /* !defined(LOW_MEMORY) */
 
-#ifdef HAVE_BKTR
-static inline void __dump_backtrace(struct ast_bt *bt, int canlog)
-{
-	char **strings;
-
-	ssize_t i;
-
-	strings = backtrace_symbols(bt->addresses, bt->num_frames);
-
-	for (i = 0; i < bt->num_frames; i++)
-		__ast_mutex_logger("%s\n", strings[i]);
-
-	free(strings);
-}
-#endif
-
 /*!
  * \brief log info for the current lock with ast_log().
  *
--- include/asterisk/logger.h
+++ include/asterisk/logger.h
@@ -411,7 +411,7 @@
  * \param addresses A list of addresses, such as the ->addresses structure element of struct ast_bt.
  * \param num_frames Number of addresses in the addresses list
  * \retval NULL Unable to allocate memory
- * \return List of strings
+ * \return List of strings. Free the entire list with a single ast_std_free call.
  * \since 1.6.2.16
  */
 char **ast_bt_get_symbols(void **addresses, size_t num_frames);
--- include/asterisk/utils.h
+++ include/asterisk/utils.h
@@ -459,24 +459,20 @@
 long int ast_random(void);
 
 
+#ifndef __AST_DEBUG_MALLOC
+#define ast_std_malloc malloc
+#define ast_std_calloc calloc
+#define ast_std_realloc realloc
+#define ast_std_free free
+
 /*!
  * \brief free() wrapper
  *
  * ast_free_ptr should be used when a function pointer for free() needs to be passed
  * as the argument to a function. Otherwise, astmm will cause seg faults.
  */
-#ifdef __AST_DEBUG_MALLOC
-static void ast_free_ptr(void *ptr) attribute_unused;
-static void ast_free_ptr(void *ptr)
-{
-	ast_free(ptr);
-}
-#else
 #define ast_free free
 #define ast_free_ptr ast_free
-#endif
-
-#ifndef __AST_DEBUG_MALLOC
 
 #define MALLOC_FAILURE_MSG \
 	ast_log(LOG_ERROR, "Memory Allocation Failure in function %s at line %d of %s\n", func, lineno, file);
--- main/asterisk.c
+++ main/asterisk.c
@@ -1,7 +1,7 @@
 /*
  * Asterisk -- An open source telephony toolkit.
  *
- * Copyright (C) 1999 - 2012, Digium, Inc.
+ * Copyright (C) 1999 - 2013, Digium, Inc.
  *
  * Mark Spencer <markster@digium.com>
  *
@@ -39,7 +39,7 @@
  *
  * \section copyright Copyright and Author
  *
- * Copyright (C) 1999 - 2012, Digium, Inc.
+ * Copyright (C) 1999 - 2013, Digium, Inc.
  * Asterisk is a <a href="http://www.digium.com/en/company/view-policy.php?id=Trademark-Policy">registered trademark</a>
  * of <a href="http://www.digium.com">Digium, Inc</a>.
  *
@@ -65,7 +65,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 379790 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396746 $")
 
 #include "asterisk/_private.h"
 
@@ -173,7 +173,7 @@
 
 /*! \brief Welcome message when starting a CLI interface */
 #define WELCOME_MESSAGE \
-    ast_verbose("Asterisk %s, Copyright (C) 1999 - 2012 Digium, Inc. and others.\n" \
+    ast_verbose("Asterisk %s, Copyright (C) 1999 - 2013 Digium, Inc. and others.\n" \
                 "Created by Mark Spencer <markster@digium.com>\n" \
                 "Asterisk comes with ABSOLUTELY NO WARRANTY; type 'core show warranty' for details.\n" \
                 "This is free software, with components licensed under the GNU General Public\n" \
@@ -1977,6 +1977,11 @@
 	/* Called when readline data is available */
 	if (!ast_all_zeros(s))
 		ast_el_add_history(s);
+
+	while (isspace(*s)) {
+		s++;
+	}
+
 	/* The real handler for bang */
 	if (s[0] == '!') {
 		if (s[1])
@@ -3070,7 +3075,7 @@
 
 static int show_cli_help(void)
 {
-	printf("Asterisk %s, Copyright (C) 1999 - 2012, Digium, Inc. and others.\n", ast_get_version());
+	printf("Asterisk %s, Copyright (C) 1999 - 2013, Digium, Inc. and others.\n", ast_get_version());
 	printf("Usage: asterisk [OPTIONS]\n");
 	printf("Valid Options:\n");
 	printf("   -V              Display version number and exit\n");
--- main/asterisk.exports.in
+++ main/asterisk.exports.in
@@ -46,6 +46,25 @@
 		LINKER_SYMBOL_PREFIXres_srtp;
 		LINKER_SYMBOL_PREFIXres_srtp_policy;
 		LINKER_SYMBOL_PREFIXsecure_call_info;
+		/*
+
+		If _IO_stdin_used is not exported, stdout/stderr may not get
+		properly aligned. That causes breakage on some architectures.
+
+		http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634261#51
+		http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634261#94
+		http://lists.gnu.org/archive/html/bug-glibc/2001-12/msg00203.html
+
+		We export the symbol to get proper behaviour. Now printf
+		doesn't SIGBUS anymore on the SPARC.
+
+		Michael Karcher wrote on Jan 13, 2013:
+		> A build process that mangles the export of _IO_stdin_used is
+		> (as defined by the libc ABI, even if not explicitly written
+		> down) broken. [...]
+
+		*/
+		LINKER_SYMBOL_PREFIX_IO_stdin_used;
 	local:
 		*;
 };
--- main/astfd.c
+++ main/astfd.c
@@ -31,7 +31,7 @@
 
 #ifdef DEBUG_FD_LEAKS
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 369013 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397107 $")
 
 #include <stdio.h>
 #include <string.h>
@@ -274,8 +274,14 @@
 
 static struct ast_cli_entry cli_show_fd = AST_CLI_DEFINE(handle_show_fd, "Show open file descriptors");
 
+static void fd_shutdown(void)
+{
+	ast_cli_unregister(&cli_show_fd);
+}
+
 int ast_fd_init(void)
 {
+	ast_register_atexit(fd_shutdown);
 	return ast_cli_register(&cli_show_fd);
 }
 
--- main/astmm.c
+++ main/astmm.c
@@ -32,7 +32,7 @@
 
 #if defined(__AST_DEBUG_MALLOC)
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377401 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397528 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_LOG_DIR */
 #include <stddef.h>
@@ -157,6 +157,31 @@
 		}                                    \
 	} while (0)
 
+void *ast_std_malloc(size_t size)
+{
+	return malloc(size);
+}
+
+void *ast_std_calloc(size_t nmemb, size_t size)
+{
+	return calloc(nmemb, size);
+}
+
+void *ast_std_realloc(void *ptr, size_t size)
+{
+	return realloc(ptr, size);
+}
+
+void ast_std_free(void *ptr)
+{
+	free(ptr);
+}
+
+void ast_free_ptr(void *ptr)
+{
+	ast_free(ptr);
+}
+
 /*!
  * \internal
  *
--- main/astobj2.c
+++ main/astobj2.c
@@ -24,7 +24,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388700 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397528 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/astobj2.h"
@@ -123,7 +123,7 @@
 	for(i = 0; i < c; i++) {
 		ast_verbose("%d: %p %s\n", i, addresses[i], strings[i]);
 	}
-	free(strings);
+	ast_std_free(strings);
 }
 #endif
 
--- main/cdr.c
+++ main/cdr.c
@@ -37,7 +37,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 383840 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include <signal.h>
 
@@ -383,8 +383,7 @@
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
 
-		if (value) {
-			newvariable = ast_var_assign(name, value);
+		if (value && (newvariable = ast_var_assign(name, value))) {
 			AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 		}
 	}
@@ -408,8 +407,8 @@
 	AST_LIST_TRAVERSE(headpa,variables,entries) {
 		if (variables &&
 		    (var = ast_var_name(variables)) && (val = ast_var_value(variables)) &&
-		    !ast_strlen_zero(var) && !ast_strlen_zero(val)) {
-			newvariable = ast_var_assign(var, val);
+		    !ast_strlen_zero(var) && !ast_strlen_zero(val) &&
+		    (newvariable = ast_var_assign(var, val))) {
 			AST_LIST_INSERT_HEAD(headpb, newvariable, entries);
 			x++;
 		}
--- main/cel.c
+++ main/cel.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377883 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397034 $")
 
 #include "asterisk/_private.h"
 
@@ -310,7 +310,7 @@
 
 	config = ast_config_load2("cel.conf", "cel", config_flags);
 
-	if (config == CONFIG_STATUS_FILEMISSING) {
+	if (config == CONFIG_STATUS_FILEMISSING || config == CONFIG_STATUS_FILEUNCHANGED || config == CONFIG_STATUS_FILEINVALID) {
 		config = NULL;
 		goto return_cleanup;
 	}
--- main/cli.c
+++ main/cli.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 386051 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396746 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_MODULE_DIR */
@@ -2299,6 +2299,13 @@
 		return NULL;
 
 	cur = duplicate;
+
+	/* Remove leading spaces from the command */
+	while (isspace(*s)) {
+		cur++;
+		s++;
+	}
+
 	/* scan the original string copying into cur when needed */
 	for (; *s ; s++) {
 		if (x >= max - 1) {
--- main/config_options.c
+++ main/config_options.c
@@ -27,7 +27,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 374196 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include <regex.h>
 
@@ -153,14 +153,15 @@
 			return -1;
 		}
 		if (!ao2_link(type->internal->opts, opt)) {
-			while (--idx) {
+			do {
 				ao2_unlink(types[idx]->internal->opts, opt);
-			}
+			} while (--idx);
 			return -1;
 		}
-		/* The container should hold the only ref to opt */
-		ao2_ref(opt, -1);
 	}
+	/* The container(s) should hold the only ref to opt */
+	ao2_ref(opt, -1);
+
 	return 0;
 }
 
--- main/data.c
+++ main/data.c
@@ -28,7 +28,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377883 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396961 $")
 
 #include "asterisk/_private.h"
 
@@ -1631,7 +1631,7 @@
 {
 	struct data_filter *filter = obj, *globres;
 
-	AST_LIST_TRAVERSE(&(filter->glob_list), globres, list) {
+	while ((globres = AST_LIST_REMOVE_HEAD(&(filter->glob_list), list))) {
 		ao2_ref(globres, -1);
 	}
 
--- main/features.c
+++ main/features.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387038 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396884 $")
 
 #include "asterisk/_private.h"
 
@@ -3613,6 +3613,10 @@
 				res = AST_FEATURE_RETURN_SUCCESS; /* We found something */
 			} else if (operation == FEATURE_INTERPRET_DO) {
 				res = builtin_features[x].operation(chan, peer, config, code, sense, NULL);
+				ast_test_suite_event_notify("FEATURE_DETECTION",
+						"Result: success\r\n"
+						"Feature: %s",
+						builtin_features[x].sname);
 			}
 			if (feature) {
 				memcpy(feature, &builtin_features[x], sizeof(*feature));
@@ -3625,6 +3629,12 @@
 			}
 		}
 	}
+
+	if (operation == FEATURE_INTERPRET_CHECK && x == FEATURES_COUNT) {
+		ast_test_suite_event_notify("FEATURE_DETECTION",
+				"Result: fail");
+	}
+
 	ast_rwlock_unlock(&features_lock);
 
 	if (ast_strlen_zero(dynamic_features_buf) || feature_detected) {
--- main/format.c
+++ main/format.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377244 $");
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $");
 
 #include "asterisk/_private.h"
 #include "asterisk/format.h"
@@ -916,7 +916,7 @@
 
 static int format_list_add_custom(struct ast_format_list *new)
 {
-	struct ast_format_list *entry;
+	RAII_VAR(struct ast_format_list *, entry, NULL, ao2_cleanup);
 	if (!(entry = ao2_alloc(sizeof(*entry), NULL))) {
 		return -1;
 	}
--- main/http.c
+++ main/http.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 384119 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397309 $")
 
 #include <time.h>
 #include <sys/time.h>
@@ -666,7 +666,7 @@
 			prev = v;
 		}
 	}
-	
+
 done:
 	ast_free(buf);
 	return post_vars;
@@ -843,7 +843,7 @@
 	struct ast_variable *v, *cookies=NULL;
 
 	for (v = headers; v; v = v->next) {
-		if (!strncasecmp(v->name, "Cookie", 6)) {
+		if (!strcasecmp(v->name, "Cookie")) {
 			char *tmp = ast_strdupa(v->value);
 			if (cookies) {
 				ast_variables_destroy(cookies);
@@ -1024,7 +1024,7 @@
 	struct http_uri_redirect *redirect;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
 	uint32_t bindport = DEFAULT_PORT;
-	struct ast_sockaddr *addrs = NULL;
+	RAII_VAR(struct ast_sockaddr *, addrs, NULL, ast_free);
 	int num_addrs = 0;
 	int http_tls_was_enabled = 0;
 
@@ -1229,7 +1229,25 @@
 
 static void http_shutdown(void)
 {
+	struct http_uri_redirect *redirect;
 	ast_cli_unregister_multiple(cli_http, ARRAY_LEN(cli_http));
+
+	ast_tcptls_server_stop(&http_desc);
+	if (http_tls_cfg.enabled) {
+		ast_tcptls_server_stop(&https_desc);
+	}
+	ast_free(http_tls_cfg.certfile);
+	ast_free(http_tls_cfg.pvtfile);
+	ast_free(http_tls_cfg.cipher);
+
+	ast_http_uri_unlink(&statusuri);
+	ast_http_uri_unlink(&staticuri);
+
+	AST_RWLIST_WRLOCK(&uri_redirects);
+	while ((redirect = AST_RWLIST_REMOVE_HEAD(&uri_redirects, entry))) {
+		ast_free(redirect);
+	}
+	AST_RWLIST_UNLOCK(&uri_redirects);
 }
 
 int ast_http_init(void)
--- main/loader.c
+++ main/loader.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 378094 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_MODULE_DIR */
@@ -1035,6 +1035,8 @@
 			break;
 		case AST_MODULE_LOAD_PRIORITY:
 			AST_LIST_REMOVE_CURRENT(entry);
+			ast_free(order->resource);
+			ast_free(order);
 			break;
 		}
 	}
--- main/lock.c
+++ main/lock.c
@@ -27,8 +27,9 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388839 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397528 $")
 
+#include "asterisk/utils.h"
 #include "asterisk/lock.h"
 
 /* Allow direct use of pthread_mutex_* / pthread_cond_* */
@@ -45,6 +46,22 @@
 #undef pthread_cond_wait
 #undef pthread_cond_timedwait
 
+#if defined(DEBUG_THREADS) && defined(HAVE_BKTR)
+static void __dump_backtrace(struct ast_bt *bt, int canlog)
+{
+	char **strings;
+	ssize_t i;
+
+	strings = backtrace_symbols(bt->addresses, bt->num_frames);
+
+	for (i = 0; i < bt->num_frames; i++) {
+		__ast_mutex_logger("%s\n", strings[i]);
+	}
+
+	ast_std_free(strings);
+}
+#endif	/* defined(DEBUG_THREADS) && defined(HAVE_BKTR) */
+
 int __ast_pthread_mutex_init(int tracking, const char *filename, int lineno, const char *func,
 						const char *mutex_name, ast_mutex_t *t)
 {
--- main/logger.c
+++ main/logger.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 389677 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397528 $")
 
 /* When we include logger.h again it will trample on some stuff in syslog.h, but
  * nothing we care about in here. */
@@ -1593,7 +1593,7 @@
 
 char **ast_bt_get_symbols(void **addresses, size_t num_frames)
 {
-	char **strings = NULL;
+	char **strings;
 #if defined(BETTER_BACKTRACES)
 	int stackfr;
 	bfd *bfdobj;           /* bfd.h */
@@ -1613,9 +1613,12 @@
 
 #if defined(BETTER_BACKTRACES)
 	strings_size = num_frames * sizeof(*strings);
-	eachlen = ast_calloc(num_frames, sizeof(*eachlen));
 
-	if (!(strings = ast_calloc(num_frames, sizeof(*strings)))) {
+	eachlen = ast_calloc(num_frames, sizeof(*eachlen));
+	strings = ast_std_calloc(num_frames, sizeof(*strings));
+	if (!eachlen || !strings) {
+		ast_free(eachlen);
+		ast_std_free(strings);
 		return NULL;
 	}
 
@@ -1630,6 +1633,7 @@
 
 		if (strcmp(dli.dli_fname, "asterisk") == 0) {
 			char asteriskpath[256];
+
 			if (!(dli.dli_fname = ast_utils_which("asterisk", asteriskpath, sizeof(asteriskpath)))) {
 				/* This will fail to find symbols */
 				ast_debug(1, "Failed to find asterisk binary for debug symbols.\n");
@@ -1638,11 +1642,11 @@
 		}
 
 		lastslash = strrchr(dli.dli_fname, '/');
-		if (	(bfdobj = bfd_openr(dli.dli_fname, NULL)) &&
-				bfd_check_format(bfdobj, bfd_object) &&
-				(allocsize = bfd_get_symtab_upper_bound(bfdobj)) > 0 &&
-				(syms = ast_malloc(allocsize)) &&
-				(symbolcount = bfd_canonicalize_symtab(bfdobj, syms))) {
+		if ((bfdobj = bfd_openr(dli.dli_fname, NULL)) &&
+			bfd_check_format(bfdobj, bfd_object) &&
+			(allocsize = bfd_get_symtab_upper_bound(bfdobj)) > 0 &&
+			(syms = ast_malloc(allocsize)) &&
+			(symbolcount = bfd_canonicalize_symtab(bfdobj, syms))) {
 
 			if (bfdobj->flags & DYNAMIC) {
 				offset = addresses[stackfr] - dli.dli_fbase;
@@ -1651,9 +1655,9 @@
 			}
 
 			for (section = bfdobj->sections; section; section = section->next) {
-				if (	!bfd_get_section_flags(bfdobj, section) & SEC_ALLOC ||
-						section->vma > offset ||
-						section->size + section->vma < offset) {
+				if (!bfd_get_section_flags(bfdobj, section) & SEC_ALLOC ||
+					section->vma > offset ||
+					section->size + section->vma < offset) {
 					continue;
 				}
 
@@ -1668,7 +1672,9 @@
 				found++;
 				if ((lastslash = strrchr(file, '/'))) {
 					const char *prevslash;
-					for (prevslash = lastslash - 1; *prevslash != '/' && prevslash >= file; prevslash--);
+
+					for (prevslash = lastslash - 1; *prevslash != '/' && prevslash >= file; prevslash--) {
+					}
 					if (prevslash >= file) {
 						lastslash = prevslash;
 					}
@@ -1690,9 +1696,7 @@
 		}
 		if (bfdobj) {
 			bfd_close(bfdobj);
-			if (syms) {
-				ast_free(syms);
-			}
+			ast_free(syms);
 		}
 
 		/* Default output, if we cannot find the information within BFD */
@@ -1712,27 +1716,31 @@
 
 		if (!ast_strlen_zero(msg)) {
 			char **tmp;
-			eachlen[stackfr] = strlen(msg);
-			if (!(tmp = ast_realloc(strings, strings_size + eachlen[stackfr] + 1))) {
-				ast_free(strings);
+
+			eachlen[stackfr] = strlen(msg) + 1;
+			if (!(tmp = ast_std_realloc(strings, strings_size + eachlen[stackfr]))) {
+				ast_std_free(strings);
 				strings = NULL;
 				break; /* out of stack frame iteration */
 			}
 			strings = tmp;
 			strings[stackfr] = (char *) strings + strings_size;
-			ast_copy_string(strings[stackfr], msg, eachlen[stackfr] + 1);
-			strings_size += eachlen[stackfr] + 1;
+			strcpy(strings[stackfr], msg);/* Safe since we just allocated the room. */
+			strings_size += eachlen[stackfr];
 		}
 	}
 
 	if (strings) {
-		/* Recalculate the offset pointers */
+		/* Recalculate the offset pointers because of the reallocs. */
 		strings[0] = (char *) strings + num_frames * sizeof(*strings);
 		for (stackfr = 1; stackfr < num_frames; stackfr++) {
-			strings[stackfr] = strings[stackfr - 1] + eachlen[stackfr - 1] + 1;
+			strings[stackfr] = strings[stackfr - 1] + eachlen[stackfr - 1];
 		}
 	}
+	ast_free(eachlen);
+
 #else /* !defined(BETTER_BACKTRACES) */
+
 	strings = backtrace_symbols(addresses, num_frames);
 #endif /* defined(BETTER_BACKTRACES) */
 	return strings;
@@ -1758,9 +1766,7 @@
 			ast_debug(1, "#%d: [%p] %s\n", i - 3, bt->addresses[i], strings[i]);
 		}
 
-		/* MALLOC_DEBUG will erroneously report an error here, unless we undef the macro. */
-#undef free
-		free(strings);
+		ast_std_free(strings);
 	} else {
 		ast_debug(1, "Could not allocate memory for backtrace\n");
 	}
--- main/named_acl.c
+++ main/named_acl.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377340 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -555,10 +555,18 @@
 	AST_CLI_DEFINE(handle_show_named_acl_cmd, "Show a named ACL or list all named ACLs"),
 };
 
+static void named_acl_cleanup(void)
+{
+	aco_info_destroy(&cfg_info);
+	ao2_global_obj_release(globals);
+}
+
 int ast_named_acl_init()
 {
 	ast_cli_register_multiple(cli_named_acl, ARRAY_LEN(cli_named_acl));
 
+	ast_register_atexit(named_acl_cleanup);
+
 	if (aco_info_init(&cfg_info)) {
 		return 0;
 	}
--- main/pbx.c
+++ main/pbx.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388578 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_SYSTEM_NAME */
@@ -11332,10 +11332,9 @@
 		headp = &globals;
 	}
 
-	if (value) {
+	if (value && (newvariable = ast_var_assign(name, value))) {
 		if (headp == &globals)
 			ast_verb(2, "Setting global variable '%s' to '%s'\n", name, value);
-		newvariable = ast_var_assign(name, value);
 		AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 	}
 
@@ -11382,10 +11381,9 @@
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 
-	if (value) {
+	if (value && (newvariable = ast_var_assign(name, value))) {
 		if (headp == &globals)
 			ast_verb(2, "Setting global variable '%s' to '%s'\n", name, value);
-		newvariable = ast_var_assign(name, value);
 		AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 		/*** DOCUMENTATION
 			<managerEventInstance>
--- main/threadstorage.c
+++ main/threadstorage.c
@@ -38,7 +38,7 @@
 
 #else /* !defined(DEBUG_THREADLOCALS) */
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397107 $")
 
 #include "asterisk/strings.h"
 #include "asterisk/utils.h"
@@ -249,10 +249,16 @@
 	AST_CLI_DEFINE(handle_cli_threadstorage_show_summary,     "Summarize outstanding memory allocations")
 };
 
+static void threadstorage_shutdown(void)
+{
+	ast_cli_unregister_multiple(cli, ARRAY_LEN(cli));
+}
+
 void threadstorage_init(void)
 {
 	pthread_mutex_init(&threadstoragelock, NULL);
 	ast_cli_register_multiple(cli, ARRAY_LEN(cli));
+	ast_register_atexit(threadstorage_shutdown);
 }
 
 #endif /* !defined(DEBUG_THREADLOCALS) */
--- main/udptl.c
+++ main/udptl.c
@@ -54,7 +54,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377849 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397365 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -1419,8 +1419,15 @@
 
 static void __ast_udptl_reload(int reload)
 {
+	RAII_VAR(struct udptl_config *, udptl_cfg, udptl_snapshot_alloc(), ao2_cleanup);
+
 	if (aco_process_config(&cfg_info, reload) == ACO_PROCESS_ERROR) {
-		ast_log(LOG_WARNING, "Could not reload udptl config\n");
+		if (!reload) {
+			if (!aco_set_defaults(&general_option, "general", udptl_cfg->general)) {
+				ast_log(LOG_WARNING, "Could not load udptl config; using defaults\n");
+				ao2_global_obj_replace(globals, udptl_cfg);
+			}
+		}
 	}
 }
 
--- main/utils.c
+++ main/utils.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387295 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397528 $")
 
 #include <ctype.h>
 #include <sys/stat.h>
@@ -869,7 +869,7 @@
 			ast_str_append(str, 0, "\t%s\n", symbols[frame_iterator]);
 		}
 
-		free(symbols);
+		ast_std_free(symbols);
 	} else {
 		ast_str_append(str, 0, "\tCouldn't retrieve backtrace symbols\n");
 	}
--- main/xmldoc.c
+++ main/xmldoc.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377511 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397067 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"
@@ -759,6 +759,7 @@
 				if ((paramtype = ast_xml_get_attribute(node, "required"))) {
 					if (!ast_true(paramtype)) {
 						optmidnode = 1;
+						ast_xml_free_attr(paramtype);
 						break;
 					}
 					ast_xml_free_attr(paramtype);
--- pbx/pbx_dundi.c
+++ pbx/pbx_dundi.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388378 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/network.h"
 #include <sys/ioctl.h>
@@ -598,14 +598,18 @@
 			ast_eid_to_str(dr[anscnt].eid_str, sizeof(dr[anscnt].eid_str), &dr[anscnt].eid);
 			if (ast_test_flag(&flags, DUNDI_FLAG_EXISTS)) {
 				AST_LIST_HEAD_INIT_NOLOCK(&headp);
-				newvariable = ast_var_assign("NUMBER", called_number);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-				newvariable = ast_var_assign("EID", dr[anscnt].eid_str);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-				newvariable = ast_var_assign("SECRET", cursecret);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-				newvariable = ast_var_assign("IPADDR", ipaddr);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				if ((newvariable = ast_var_assign("NUMBER", called_number))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
+				if ((newvariable = ast_var_assign("EID", dr[anscnt].eid_str))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
+				if ((newvariable = ast_var_assign("SECRET", cursecret))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
+				if ((newvariable = ast_var_assign("IPADDR", ipaddr))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
 				pbx_substitute_variables_varshead(&headp, map->dest, dr[anscnt].dest, sizeof(dr[anscnt].dest));
 				dr[anscnt].weight = get_mapping_weight(map, &headp);
 				while ((newvariable = AST_LIST_REMOVE_HEAD(&headp, entries)))
--- pbx/pbx_loopback.c
+++ pbx/pbx_loopback.c
@@ -28,7 +28,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 361155 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/file.h"
 #include "asterisk/logger.h"
@@ -91,12 +91,15 @@
 
 	snprintf(tmp, sizeof(tmp), "%d", priority);
 	AST_LIST_HEAD_INIT_NOLOCK(&headp);
-	newvariable = ast_var_assign("EXTEN", exten);
-	AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-	newvariable = ast_var_assign("CONTEXT", context);
-	AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-	newvariable = ast_var_assign("PRIORITY", tmp);
-	AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	if ((newvariable = ast_var_assign("EXTEN", exten))) {
+		AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	}
+	if ((newvariable = ast_var_assign("CONTEXT", context))) {
+		AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	}
+	if ((newvariable = ast_var_assign("PRIORITY", tmp))) {
+		AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	}
 	/* Substitute variables */
 	pbx_substitute_variables_varshead(&headp, data, buf, buflen);
 	/* free the list */
--- res/res_agi.c
+++ res/res_agi.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 381893 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394641 $")
 
 #include <math.h>
 #include <signal.h>
@@ -2007,8 +2007,8 @@
 	}
 
 	if (!(fs = ast_openstream(chan, argv[2], ast_channel_language(chan)))) {
-		ast_agi_send(agi->fd, chan, "200 result=%d endpos=%ld\n", 0, sample_offset);
-		return RESULT_SUCCESS;
+		ast_agi_send(agi->fd, chan, "200 result=-1 endpos=%ld\n", sample_offset);
+		return RESULT_FAILURE;
 	}
 
 	if ((vfs = ast_openvstream(chan, argv[2], ast_channel_language(chan)))) {
@@ -2065,9 +2065,9 @@
 	}
 
 	if (!(fs = ast_openstream(chan, argv[2], ast_channel_language(chan)))) {
-		ast_agi_send(agi->fd, chan, "200 result=%d endpos=%ld\n", 0, sample_offset);
+		ast_agi_send(agi->fd, chan, "200 result=-1 endpos=%ld\n", sample_offset);
 		ast_log(LOG_WARNING, "Unable to open %s\n", argv[2]);
-		return RESULT_SUCCESS;
+		return RESULT_FAILURE;
 	}
 
 	if ((vfs = ast_openvstream(chan, argv[2], ast_channel_language(chan))))
--- res/res_calendar.c
+++ res/res_calendar.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 378321 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/calendar.h"
@@ -1810,6 +1810,8 @@
 
 	/* Remove all calendars */
 	ao2_callback(calendars, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
+	ao2_cleanup(calendars);
+	calendars = NULL;
 
 	ast_mutex_lock(&refreshlock);
 	module_unloading = 1;
--- res/res_http_websocket.c
+++ res/res_http_websocket.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 376561 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391560 $")
 
 #include "asterisk/module.h"
 #include "asterisk/http.h"
@@ -544,9 +544,18 @@
 		/* Version 7 defined in specification http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07 */
 		/* Version 8 defined in specification http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10 */
 		/* Version 13 defined in specification http://tools.ietf.org/html/rfc6455 */
-		char combined[strlen(key) + strlen(WEBSOCKET_GUID) + 1], base64[64];
+		char *combined, base64[64];
+		unsigned combined_length;
 		uint8_t sha[20];
 
+		combined_length = (key ? strlen(key) : 0) + strlen(WEBSOCKET_GUID) + 1;
+		if (!key || combined_length > 8192) { /* no stack overflows please */
+			fputs("HTTP/1.1 400 Bad Request\r\n"
+			      "Sec-WebSocket-Version: 7, 8, 13\r\n\r\n", ser->f);
+			ao2_ref(protocol_handler, -1);
+			return 0;
+		}
+
 		if (!(session = ao2_alloc(sizeof(*session), session_destroy_fn))) {
 			ast_log(LOG_WARNING, "WebSocket connection from '%s' could not be accepted\n",
 				ast_sockaddr_stringify(&ser->remote_address));
@@ -556,7 +565,8 @@
 			return 0;
 		}
 
-		snprintf(combined, sizeof(combined), "%s%s", key, WEBSOCKET_GUID);
+		combined = ast_alloca(combined_length);
+		snprintf(combined, combined_length, "%s%s", key, WEBSOCKET_GUID);
 		ast_sha1_hash_uint(sha, combined);
 		ast_base64encode(base64, (const unsigned char*)sha, 20, sizeof(base64));
 
--- tests/test_hashtab_thrash.c
+++ tests/test_hashtab_thrash.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 376339 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396657 $")
 #include <pthread.h>
 #include "asterisk/hashtab.h"
 #include "asterisk/lock.h"
@@ -197,8 +197,10 @@
 		ast_hashtab_end_traversal(it);
 
 		if (last_count == count) {
-			/* Allow other threads to run. */
-			sched_yield();
+			/* Give other threads ample chance to run, note that using sched_yield here does not
+			 * provide enough of a chance and can cause this thread to starve others.
+			 */
+			usleep(1);
 		} else if (last_count > count) {
 			/* Make sure the hashtable never shrinks */
 			return "hashtab unexpectedly shrank";
--- utils/extconf.c
+++ utils/extconf.c
@@ -3149,10 +3149,9 @@
 		}
 	}
 
-	if (value) {
+	if (value && (newvariable = ast_var_assign(name, value))) {
 		if ((option_verbose > 1) && (headp == &globals))
 			ast_verbose(VERBOSE_PREFIX_2 "Setting global variable '%s' to '%s'\n", name, value);
-		newvariable = ast_var_assign(name, value);
 		AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 	}
 
