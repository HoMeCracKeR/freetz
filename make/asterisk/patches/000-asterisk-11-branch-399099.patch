--- addons/ooh323c/src/ooh245.c
+++ addons/ooh323c/src/ooh245.c
@@ -3259,8 +3259,8 @@
       OOTRACEDBGC3("Empty TCS found.  (%s, %s)\n",
                     call->callType, call->callToken);
 
-      ooH245AcknowledgeTerminalCapabilitySet(call);
       call->remoteTermCapSeqNo = tcs->sequenceNumber;
+      ooH245AcknowledgeTerminalCapabilitySet(call);
 
 /* close all transmit chans */
 
--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 382385 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -3098,7 +3098,7 @@
 {
 	int res = 0;
 
-	if (conf_load_config(0)) {
+	if (conf_load_config()) {
 		ast_log(LOG_ERROR, "Unable to load config. Not loading module.\n");
 		return AST_MODULE_LOAD_DECLINE;
 	}
@@ -3145,7 +3145,7 @@
 
 static int reload(void)
 {
-	return conf_load_config(1);
+	return conf_reload_config();
 }
 
 AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "Conference Bridge Application",
--- apps/app_dumpchan.c
+++ apps/app_dumpchan.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 358907 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397948 $")
 
 #include "asterisk/pbx.h"
 #include "asterisk/module.h"
@@ -138,10 +138,10 @@
 		S_OR(ast_channel_dialed(c)->number.str, "(N/A)"),
 		S_COR(ast_channel_redirecting(c)->from.number.valid, ast_channel_redirecting(c)->from.number.str, "(N/A)"),
 		ast_channel_parkinglot(c),
-		ast_channel_language(c),	
+		ast_channel_language(c),
 		ast_state2str(ast_channel_state(c)),
 		ast_channel_state(c),
-		ast_channel_rings(c), 
+		ast_channel_rings(c),
 		ast_getformatname_multiple(nf, sizeof(nf), ast_channel_nativeformats(c)),
 		ast_getformatname(ast_channel_writeformat(c)),
 		ast_getformatname(ast_channel_readformat(c)),
@@ -159,7 +159,7 @@
 		min,
 		sec,
 		ast_channel_internal_bridged_channel(c) ? ast_channel_name(ast_channel_internal_bridged_channel(c)) : "<none>",
-		ast_bridged_channel(c) ? ast_channel_name(ast_bridged_channel(c)) : "<none>", 
+		ast_bridged_channel(c) ? ast_channel_name(ast_bridged_channel(c)) : "<none>",
 		ast_channel_context(c),
 		ast_channel_exten(c),
 		ast_channel_priority(c),
@@ -182,17 +182,15 @@
 	if (!ast_strlen_zero(data))
 		level = atoi(data);
 
-	if (option_verbose >= level) {
-		serialize_showchan(chan, info, sizeof(info));
-		pbx_builtin_serialize_variables(chan, &vars);
-		ast_verbose("\n"
-			"Dumping Info For Channel: %s:\n"
-			"%s\n"
-			"Info:\n"
-			"%s\n"
-			"Variables:\n"
-			"%s%s\n", ast_channel_name(chan), line, info, ast_str_buffer(vars), line);
-	}
+	serialize_showchan(chan, info, sizeof(info));
+	pbx_builtin_serialize_variables(chan, &vars);
+	ast_verb(level, "\n"
+		 "Dumping Info For Channel: %s:\n"
+		 "%s\n"
+		 "Info:\n"
+		 "%s\n"
+		 "Variables:\n"
+		 "%s%s\n", ast_channel_name(chan), line, info, ast_str_buffer(vars), line);
 
 	return 0;
 }
--- apps/app_meetme.c
+++ apps/app_meetme.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387689 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396944 $")
 
 #include <dahdi/user.h>
 
@@ -655,9 +655,9 @@
 #define CONFFLAG_INTROMSG           (1ULL << 32) /*!< If set play an intro announcement at start of conference */
 #define CONFFLAG_INTROUSER_VMREC    (1ULL << 33)
 /*! If there's only one person left in a conference when someone leaves, kill the conference */
-#define CONFFLAG_KILL_LAST_MAN_STANDING ((uint64_t)1 << 34)
+#define CONFFLAG_KILL_LAST_MAN_STANDING (1ULL << 34)
 /*! If set, don't enable a denoiser for the channel */
-#define CONFFLAG_DONT_DENOISE       (1ULL << 33)
+#define CONFFLAG_DONT_DENOISE       (1ULL << 35)
 
 enum {
 	OPT_ARG_WAITMARKED = 0,
@@ -866,17 +866,26 @@
 	/*! This option uses the values in the sla_hold_access enum and sets the
 	 * access control type for hold on this station. */
 	unsigned int hold_access:1;
-	/*! Use count for inside sla_station_exec */
-	unsigned int ref_count;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
+/*!
+ * \brief A reference to a station
+ *
+ * This struct looks near useless at first glance.  However, its existence
+ * in the list of stations in sla_trunk means that this station references
+ * that trunk.  We use the mark to keep track of whether it needs to be
+ * removed from the sla_trunk's list of stations during a reload.
+ */
 struct sla_station_ref {
 	AST_LIST_ENTRY(sla_station_ref) entry;
 	struct sla_station *station;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
 struct sla_trunk {
-	AST_RWLIST_ENTRY(sla_trunk) entry;
 	AST_DECLARE_STRING_FIELDS(
 		AST_STRING_FIELD(name);
 		AST_STRING_FIELD(device);
@@ -900,10 +909,16 @@
 	/*! Whether this trunk is currently on hold, meaning that once a station
 	 *  connects to it, the trunk channel needs to have UNHOLD indicated to it. */
 	unsigned int on_hold:1;
-	/*! Use count for inside sla_trunk_exec */
-	unsigned int ref_count;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
+/*!
+ * \brief A station's reference to a trunk
+ *
+ * An sla_station keeps a list of trunk_refs.  This holds metadata about the
+ * stations usage of the trunk.
+ */
 struct sla_trunk_ref {
 	AST_LIST_ENTRY(sla_trunk_ref) entry;
 	struct sla_trunk *trunk;
@@ -917,10 +932,12 @@
 	 *  station.  This takes higher priority than a ring delay set at
 	 *  the station level. */
 	unsigned int ring_delay;
+	/*! Mark used during reload processing */
+	unsigned int mark:1;
 };
 
-static AST_RWLIST_HEAD_STATIC(sla_stations, sla_station);
-static AST_RWLIST_HEAD_STATIC(sla_trunks, sla_trunk);
+static struct ao2_container *sla_stations;
+static struct ao2_container *sla_trunks;
 
 static const char sla_registrar[] = "SLA";
 
@@ -932,10 +949,6 @@
 	SLA_EVENT_DIAL_STATE,
 	/*! The state of a ringing trunk has changed */
 	SLA_EVENT_RINGING_TRUNK,
-	/*! A reload of configuration has been requested */
-	SLA_EVENT_RELOAD,
-	/*! Poke the SLA thread so it can check if it can perform a reload */
-	SLA_EVENT_CHECK_RELOAD,
 };
 
 struct sla_event {
@@ -991,8 +1004,6 @@
 	/*! Attempt to handle CallerID, even though it is known not to work
 	 *  properly in some situations. */
 	unsigned int attempt_callerid:1;
-	/*! A reload has been requested */
-	unsigned int reload:1;
 } sla = {
 	.thread = AST_PTHREADT_NULL,
 };
@@ -1757,7 +1768,8 @@
 
 static char *sla_show_trunks(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const struct sla_trunk *trunk;
+	struct ao2_iterator i;
+	struct sla_trunk *trunk;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1775,12 +1787,17 @@
 	            "=== Configured SLA Trunks ===================================\n"
 	            "=============================================================\n"
 	            "===\n");
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
+	i = ao2_iterator_init(sla_trunks, 0);
+	for (; (trunk = ao2_iterator_next(&i)); ao2_ref(trunk, -1)) {
 		struct sla_station_ref *station_ref;
 		char ring_timeout[16] = "(none)";
-		if (trunk->ring_timeout)
+
+		ao2_lock(trunk);
+
+		if (trunk->ring_timeout) {
 			snprintf(ring_timeout, sizeof(ring_timeout), "%u Seconds", trunk->ring_timeout);
+		}
+
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n"
 		            "=== Trunk Name:       %s\n"
 		            "=== ==> Device:       %s\n"
@@ -1794,13 +1811,16 @@
 		            ring_timeout,
 		            trunk->barge_disabled ? "No" : "Yes",
 		            sla_hold_str(trunk->hold_access));
-		AST_RWLIST_RDLOCK(&sla_stations);
-		AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry)
+
+		AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
 			ast_cli(a->fd, "===    ==> Station name: %s\n", station_ref->station->name);
-		AST_RWLIST_UNLOCK(&sla_stations);
+		}
+
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n===\n");
+
+		ao2_unlock(trunk);
 	}
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	ao2_iterator_destroy(&i);
 	ast_cli(a->fd, "=============================================================\n\n");
 
 	return CLI_SUCCESS;
@@ -1822,7 +1842,8 @@
 
 static char *sla_show_stations(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const struct sla_station *station;
+	struct ao2_iterator i;
+	struct sla_station *station;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -1840,11 +1861,14 @@
 	            "=== Configured SLA Stations =================================\n"
 	            "=============================================================\n"
 	            "===\n");
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	for (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {
 		struct sla_trunk_ref *trunk_ref;
 		char ring_timeout[16] = "(none)";
 		char ring_delay[16] = "(none)";
+
+		ao2_lock(station);
+
 		if (station->ring_timeout) {
 			snprintf(ring_timeout, sizeof(ring_timeout), 
 				"%u", station->ring_timeout);
@@ -1865,7 +1889,6 @@
 		            S_OR(station->autocontext, "(none)"), 
 		            ring_timeout, ring_delay,
 		            sla_hold_str(station->hold_access));
-		AST_RWLIST_RDLOCK(&sla_trunks);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			if (trunk_ref->ring_timeout) {
 				snprintf(ring_timeout, sizeof(ring_timeout),
@@ -1885,11 +1908,12 @@
 			            trunkstate2str(trunk_ref->state),
 			            ring_timeout, ring_delay);
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 		ast_cli(a->fd, "=== ---------------------------------------------------------\n"
 		            "===\n");
+
+		ao2_unlock(station);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
+	ao2_iterator_destroy(&i);
 	ast_cli(a->fd, "============================================================\n"
 	            "\n");
 
@@ -2043,11 +2067,16 @@
 	struct sla_event *event;
 
 	if (sla.thread == AST_PTHREADT_NULL) {
+		ao2_ref(station, -1);
+		ao2_ref(trunk_ref, -1);
 		return;
 	}
 
-	if (!(event = ast_calloc(1, sizeof(*event))))
+	if (!(event = ast_calloc(1, sizeof(*event)))) {
+		ao2_ref(station, -1);
+		ao2_ref(trunk_ref, -1);
 		return;
+	}
 
 	event->type = type;
 	event->trunk_ref = trunk_ref;
@@ -2081,6 +2110,7 @@
 	struct sla_station *station;
 	struct sla_trunk_ref *trunk_ref = NULL;
 	char *trunk_name;
+	struct ao2_iterator i;
 
 	trunk_name = ast_strdupa(conf->confno);
 	strsep(&trunk_name, "_");
@@ -2089,16 +2119,23 @@
 		return;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	while ((station = ao2_iterator_next(&i))) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-			if (trunk_ref->chan == chan && !strcmp(trunk_ref->trunk->name, trunk_name))
+			if (trunk_ref->chan == chan && !strcmp(trunk_ref->trunk->name, trunk_name)) {
+				ao2_ref(trunk_ref, 1);
 				break;
+			}
 		}
-		if (trunk_ref)
+		ao2_unlock(station);
+		if (trunk_ref) {
+			/* station reference given to sla_queue_event_full() */
 			break;
+		}
+		ao2_ref(station, -1);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
+	ao2_iterator_destroy(&i);
 
 	if (!trunk_ref) {
 		ast_debug(1, "Trunk not found for event!\n");
@@ -5571,34 +5608,30 @@
 	ast_config_destroy(cfg);
 }
 
-/*! \brief Find an SLA trunk by name
- * \note This must be called with the sla_trunks container locked
+/*!
+ * \internal
+ * \brief Find an SLA trunk by name
  */
 static struct sla_trunk *sla_find_trunk(const char *name)
 {
-	struct sla_trunk *trunk = NULL;
-
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (!strcasecmp(trunk->name, name))
-			break;
-	}
+	struct sla_trunk tmp_trunk = {
+		.name = name,
+	};
 
-	return trunk;
+	return ao2_find(sla_trunks, &tmp_trunk, OBJ_POINTER);
 }
 
-/*! \brief Find an SLA station by name
- * \note This must be called with the sla_stations container locked
+/*!
+ * \internal
+ * \brief Find an SLA station by name
  */
 static struct sla_station *sla_find_station(const char *name)
 {
-	struct sla_station *station = NULL;
-
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
-		if (!strcasecmp(station->name, name))
-			break;
-	}
+	struct sla_station tmp_station = {
+		.name = name,
+	};
 
-	return station;
+	return ao2_find(sla_stations, &tmp_station, OBJ_POINTER);
 }
 
 static int sla_check_station_hold_access(const struct sla_trunk *trunk,
@@ -5622,9 +5655,11 @@
 	return 0;
 }
 
-/*! \brief Find a trunk reference on a station by name
+/*!
+ * \brief Find a trunk reference on a station by name
  * \param station the station
  * \param name the trunk's name
+ * \pre sla_station is locked
  * \return a pointer to the station's trunk reference.  If the trunk
  *         is not found, it is not idle and barge is disabled, or if
  *         it is on hold and private hold is set, then NULL will be returned.
@@ -5651,16 +5686,32 @@
 		break;
 	}
 
+	if (trunk_ref) {
+		ao2_ref(trunk_ref, 1);
+	}
+
 	return trunk_ref;
 }
 
+static void sla_station_ref_destructor(void *obj)
+{
+	struct sla_station_ref *station_ref = obj;
+
+	if (station_ref->station) {
+		ao2_ref(station_ref->station, -1);
+		station_ref->station = NULL;
+	}
+}
+
 static struct sla_station_ref *sla_create_station_ref(struct sla_station *station)
 {
 	struct sla_station_ref *station_ref;
 
-	if (!(station_ref = ast_calloc(1, sizeof(*station_ref))))
+	if (!(station_ref = ao2_alloc(sizeof(*station_ref), sla_station_ref_destructor))) {
 		return NULL;
+	}
 
+	ao2_ref(station, 1);
 	station_ref->station = station;
 
 	return station_ref;
@@ -5673,12 +5724,48 @@
 	if (!(ringing_station = ast_calloc(1, sizeof(*ringing_station))))
 		return NULL;
 
+	ao2_ref(station, 1);
 	ringing_station->station = station;
 	ringing_station->ring_begin = ast_tvnow();
 
 	return ringing_station;
 }
 
+static void sla_ringing_station_destroy(struct sla_ringing_station *ringing_station)
+{
+	if (ringing_station->station) {
+		ao2_ref(ringing_station->station, -1);
+		ringing_station->station = NULL;
+	}
+
+	ast_free(ringing_station);
+}
+
+static struct sla_failed_station *sla_create_failed_station(struct sla_station *station)
+{
+	struct sla_failed_station *failed_station;
+
+	if (!(failed_station = ast_calloc(1, sizeof(*failed_station)))) {
+		return NULL;
+	}
+
+	ao2_ref(station, 1);
+	failed_station->station = station;
+	failed_station->last_try = ast_tvnow();
+
+	return failed_station;
+}
+
+static void sla_failed_station_destroy(struct sla_failed_station *failed_station)
+{
+	if (failed_station->station) {
+		ao2_ref(failed_station->station, -1);
+		failed_station->station = NULL;
+	}
+
+	ast_free(failed_station);
+}
+
 static enum ast_device_state sla_state_to_devstate(enum sla_trunk_state state)
 {
 	switch (state) {
@@ -5701,18 +5788,25 @@
 {
 	struct sla_station *station;
 	struct sla_trunk_ref *trunk_ref;
+	struct ao2_iterator i;
 
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	while ((station = ao2_iterator_next(&i))) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			if (trunk_ref->trunk != trunk || (inactive_only ? trunk_ref->chan : 0)
-				|| trunk_ref == exclude)
+					|| trunk_ref == exclude) {
 				continue;
+			}
 			trunk_ref->state = state;
 			ast_devstate_changed(sla_state_to_devstate(state), AST_DEVSTATE_CACHABLE,
 					     "SLA:%s_%s", station->name, trunk->name);
 			break;
 		}
+		ao2_unlock(station);
+		ao2_ref(station, -1);
 	}
+	ao2_iterator_destroy(&i);
 }
 
 struct run_station_args {
@@ -5730,8 +5824,8 @@
 
 static void *run_station(void *data)
 {
-	struct sla_station *station;
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	struct ast_str *conf_name = ast_str_create(16);
 	struct ast_flags64 conf_flags = { 0 };
 	struct ast_conference *conf;
@@ -5774,6 +5868,8 @@
 	return NULL;
 }
 
+static void sla_ringing_trunk_destroy(struct sla_ringing_trunk *ringing_trunk);
+
 static void sla_stop_ringing_trunk(struct sla_ringing_trunk *ringing_trunk)
 {
 	char buf[80];
@@ -5783,10 +5879,11 @@
 	admin_exec(NULL, buf);
 	sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
 
-	while ((station_ref = AST_LIST_REMOVE_HEAD(&ringing_trunk->timed_out_stations, entry)))
-		ast_free(station_ref);
+	while ((station_ref = AST_LIST_REMOVE_HEAD(&ringing_trunk->timed_out_stations, entry))) {
+		ao2_ref(station_ref, -1);
+	}
 
-	ast_free(ringing_trunk);
+	sla_ringing_trunk_destroy(ringing_trunk);
 }
 
 static void sla_stop_ringing_station(struct sla_ringing_station *ringing_station,
@@ -5821,7 +5918,7 @@
 	}
 
 done:
-	ast_free(ringing_station);
+	sla_ringing_station_destroy(ringing_station);
 }
 
 static void sla_dial_state_callback(struct ast_dial *dial)
@@ -5873,8 +5970,10 @@
 			if (rm)
 				AST_LIST_REMOVE_CURRENT(entry);
 
-			if (trunk_ref)
+			if (trunk_ref) {
+				ao2_ref(s_trunk_ref, 1);
 				*trunk_ref = s_trunk_ref;
+			}
 
 			break;
 		}
@@ -5892,7 +5991,7 @@
 	struct sla_ringing_station *ringing_station;
 
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&sla.ringing_stations, ringing_station, entry) {
-		struct sla_trunk_ref *s_trunk_ref = NULL;
+		RAII_VAR(struct sla_trunk_ref *, s_trunk_ref, NULL, ao2_cleanup);
 		struct sla_ringing_trunk *ringing_trunk = NULL;
 		struct run_station_args args;
 		enum ast_dial_result dial_res;
@@ -5925,7 +6024,7 @@
 				ast_dial_join(ringing_station->station->dial);
 				ast_dial_destroy(ringing_station->station->dial);
 				ringing_station->station->dial = NULL;
-				ast_free(ringing_station);
+				sla_ringing_station_destroy(ringing_station);
 				break;
 			}
 			/* Track the channel that answered this trunk */
@@ -5936,12 +6035,14 @@
 			/* Now, start a thread that will connect this station to the trunk.  The rest of
 			 * the code here sets up the thread and ensures that it is able to save the arguments
 			 * before they are no longer valid since they are allocated on the stack. */
+			ao2_ref(s_trunk_ref, 1);
 			args.trunk_ref = s_trunk_ref;
+			ao2_ref(ringing_station->station, 1);
 			args.station = ringing_station->station;
 			args.cond = &cond;
 			args.cond_lock = &cond_lock;
-			ast_free(ringing_trunk);
-			ast_free(ringing_station);
+			sla_ringing_trunk_destroy(ringing_trunk);
+			sla_ringing_station_destroy(ringing_station);
 			ast_mutex_init(&cond_lock);
 			ast_cond_init(&cond, NULL);
 			ast_mutex_lock(&cond_lock);
@@ -5995,7 +6096,7 @@
 			continue;
 		if (ast_tvdiff_ms(ast_tvnow(), failed_station->last_try) > 1000) {
 			AST_LIST_REMOVE_CURRENT(entry);
-			ast_free(failed_station);
+			sla_failed_station_destroy(failed_station);
 			break;
 		}
 		res = 1;
@@ -6048,11 +6149,9 @@
 	if (res != AST_DIAL_RESULT_TRYING) {
 		struct sla_failed_station *failed_station;
 		ast_dial_destroy(dial);
-		if (!(failed_station = ast_calloc(1, sizeof(*failed_station))))
-			return -1;
-		failed_station->station = station;
-		failed_station->last_try = ast_tvnow();
-		AST_LIST_INSERT_HEAD(&sla.failed_stations, failed_station, entry);
+		if ((failed_station = sla_create_failed_station(station))) {
+			AST_LIST_INSERT_HEAD(&sla.failed_stations, failed_station, entry);
+		}
 		return -1;
 	}
 	if (!(ringing_station = sla_create_ringing_station(station))) {
@@ -6092,6 +6191,8 @@
 			break;
 	}
 
+	ao2_ref(trunk_ref, 1);
+
 	return trunk_ref;
 }
 
@@ -6103,7 +6204,7 @@
 static int sla_check_station_delay(struct sla_station *station, 
 	struct sla_ringing_trunk *ringing_trunk)
 {
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	unsigned int delay = UINT_MAX;
 	int time_left, time_elapsed;
 
@@ -6196,7 +6297,7 @@
 			ast_dial_join(ringing_station->station->dial);
 			ast_dial_destroy(ringing_station->station->dial);
 			ringing_station->station->dial = NULL;
-			ast_free(ringing_station);
+			sla_ringing_station_destroy(ringing_station);
 		}
 	}
 	AST_LIST_TRAVERSE_SAFE_END
@@ -6353,8 +6454,10 @@
 {
 	struct sla_station *station;
 	int res = 0;
+	struct ao2_iterator i;
 
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
+	i = ao2_iterator_init(sla_stations, 0);
+	for (; (station = ao2_iterator_next(&i)); ao2_ref(station, -1)) {
 		struct sla_ringing_trunk *ringing_trunk;
 		int time_left;
 
@@ -6384,6 +6487,7 @@
 		if (time_left < *timeout)
 			*timeout = time_left;
 	}
+	ao2_iterator_destroy(&i);
 
 	return res;
 }
@@ -6425,50 +6529,19 @@
 	return 1;
 }
 
-static int sla_load_config(int reload);
-
-/*! \brief Check if we can do a reload of SLA, and do it if we can */
-static void sla_check_reload(void)
+static void sla_event_destroy(struct sla_event *event)
 {
-	struct sla_station *station;
-	struct sla_trunk *trunk;
-
-	ast_mutex_lock(&sla.lock);
-
-	if (!AST_LIST_EMPTY(&sla.event_q) || !AST_LIST_EMPTY(&sla.ringing_trunks)
-		|| !AST_LIST_EMPTY(&sla.ringing_stations) || !AST_LIST_EMPTY(&sla.failed_stations)) {
-		ast_mutex_unlock(&sla.lock);
-		return;
-	}
-
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_RWLIST_TRAVERSE(&sla_stations, station, entry) {
-		if (station->ref_count)
-			break;
-	}
-	AST_RWLIST_UNLOCK(&sla_stations);
-	if (station) {
-		ast_mutex_unlock(&sla.lock);
-		return;
+	if (event->trunk_ref) {
+		ao2_ref(event->trunk_ref, -1);
+		event->trunk_ref = NULL;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (trunk->ref_count || trunk->chan || trunk->active_stations || trunk->hold_stations) {
-			break;
-		}
-	}
-	AST_RWLIST_UNLOCK(&sla_trunks);
-	if (trunk) {
-		ast_mutex_unlock(&sla.lock);
-		return;
+	if (event->station) {
+		ao2_ref(event->station, -1);
+		event->station = NULL;
 	}
 
-	/* yay */
-	sla_load_config(1);
-	sla.reload = 0;
-
-	ast_mutex_unlock(&sla.lock);
+	ast_free(event);
 }
 
 static void *sla_thread(void *data)
@@ -6507,27 +6580,21 @@
 			case SLA_EVENT_RINGING_TRUNK:
 				sla_handle_ringing_trunk_event();
 				break;
-			case SLA_EVENT_RELOAD:
-				sla.reload = 1;
-			case SLA_EVENT_CHECK_RELOAD:
-				break;
 			}
-			ast_free(event);
+			sla_event_destroy(event);
 			ast_mutex_lock(&sla.lock);
 		}
-
-		if (sla.reload) {
-			sla_check_reload();
-		}
 	}
 
 	ast_mutex_unlock(&sla.lock);
 
-	while ((ringing_station = AST_LIST_REMOVE_HEAD(&sla.ringing_stations, entry)))
-		ast_free(ringing_station);
+	while ((ringing_station = AST_LIST_REMOVE_HEAD(&sla.ringing_stations, entry))) {
+		sla_ringing_station_destroy(ringing_station);
+	}
 
-	while ((failed_station = AST_LIST_REMOVE_HEAD(&sla.failed_stations, entry)))
-		ast_free(failed_station);
+	while ((failed_station = AST_LIST_REMOVE_HEAD(&sla.failed_stations, entry))) {
+		sla_failed_station_destroy(failed_station);
+	}
 
 	return NULL;
 }
@@ -6548,7 +6615,8 @@
 	char conf_name[MAX_CONFNUM];
 	struct ast_conference *conf;
 	struct ast_flags64 conf_flags = { 0 };
-	struct sla_trunk_ref *trunk_ref = args->trunk_ref;
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, args->trunk_ref, ao2_cleanup);
+	RAII_VAR(struct sla_station *, station, args->station, ao2_cleanup);
 	int caller_is_saved;
 	struct ast_party_caller caller;
 	int last_state = 0;
@@ -6620,8 +6688,8 @@
 			break;
 
 		/* check that SLA station that originated trunk call is still alive */
-		if (args->station && ast_device_state(args->station->device) == AST_DEVICE_NOT_INUSE) {
-			ast_debug(3, "Originating station device %s no longer active\n", args->station->device);
+		if (station && ast_device_state(station->device) == AST_DEVICE_NOT_INUSE) {
+			ast_debug(3, "Originating station device %s no longer active\n", station->device);
 			trunk_ref->trunk->chan = NULL;
 			break;
 		}
@@ -6674,15 +6742,19 @@
 	return NULL;
 }
 
-/*! \brief For a given station, choose the highest priority idle trunk
+/*!
+ * \brief For a given station, choose the highest priority idle trunk
+ * \pre sla_station is locked
  */
 static struct sla_trunk_ref *sla_choose_idle_trunk(const struct sla_station *station)
 {
 	struct sla_trunk_ref *trunk_ref = NULL;
 
 	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-		if (trunk_ref->state == SLA_TRUNK_STATE_IDLE)
+		if (trunk_ref->state == SLA_TRUNK_STATE_IDLE) {
+			ao2_ref(trunk_ref, 1);
 			break;
+		}
 	}
 
 	return trunk_ref;
@@ -6691,8 +6763,8 @@
 static int sla_station_exec(struct ast_channel *chan, const char *data)
 {
 	char *station_name, *trunk_name;
-	struct sla_station *station;
-	struct sla_trunk_ref *trunk_ref = NULL;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
+	RAII_VAR(struct sla_trunk_ref *, trunk_ref, NULL, ao2_cleanup);
 	char conf_name[MAX_CONFNUM];
 	struct ast_flags64 conf_flags = { 0 };
 	struct ast_conference *conf;
@@ -6712,25 +6784,21 @@
 		return 0;
 	}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
 	station = sla_find_station(station_name);
-	if (station)
-		ast_atomic_fetchadd_int((int *) &station->ref_count, 1);
-	AST_RWLIST_UNLOCK(&sla_stations);
 
 	if (!station) {
 		ast_log(LOG_WARNING, "Station '%s' not found!\n", station_name);
 		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "FAILURE");
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 		return 0;
 	}
 
-	AST_RWLIST_RDLOCK(&sla_trunks);
+	ao2_lock(station);
 	if (!ast_strlen_zero(trunk_name)) {
 		trunk_ref = sla_find_trunk_ref_byname(station, trunk_name);
-	} else
+	} else {
 		trunk_ref = sla_choose_idle_trunk(station);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	}
+	ao2_unlock(station);
 
 	if (!trunk_ref) {
 		if (ast_strlen_zero(trunk_name))
@@ -6740,8 +6808,6 @@
 				"'%s' due to access controls.\n", trunk_name);
 		}
 		pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
-		ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 		return 0;
 	}
 
@@ -6770,7 +6836,7 @@
 			answer_trunk_chan(ringing_trunk->trunk->chan);
 			sla_change_trunk_state(ringing_trunk->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
 
-			free(ringing_trunk);
+			sla_ringing_trunk_destroy(ringing_trunk);
 
 			/* Queue up reprocessing ringing trunks, and then ringing stations again */
 			sla_queue_event(SLA_EVENT_RINGING_TRUNK);
@@ -6790,6 +6856,8 @@
 			.cond_lock = &cond_lock,
 			.cond = &cond,
 		};
+		ao2_ref(trunk_ref, 1);
+		ao2_ref(station, 1);
 		sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_UP, ALL_TRUNK_REFS, NULL);
 		/* Create a thread to dial the trunk and dump it into the conference.
 		 * However, we want to wait until the trunk has been dialed and the
@@ -6809,8 +6877,6 @@
 			pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "CONGESTION");
 			sla_change_trunk_state(trunk_ref->trunk, SLA_TRUNK_STATE_IDLE, ALL_TRUNK_REFS, NULL);
 			trunk_ref->chan = NULL;
-			ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-			sla_queue_event(SLA_EVENT_CHECK_RELOAD);
 			return 0;
 		}
 	}
@@ -6843,19 +6909,28 @@
 	
 	pbx_builtin_setvar_helper(chan, "SLASTATION_STATUS", "SUCCESS");
 
-	ast_atomic_fetchadd_int((int *) &station->ref_count, -1);
-	sla_queue_event(SLA_EVENT_CHECK_RELOAD);
-
 	return 0;
 }
 
+static void sla_trunk_ref_destructor(void *obj)
+{
+	struct sla_trunk_ref *trunk_ref = obj;
+
+	if (trunk_ref->trunk) {
+		ao2_ref(trunk_ref->trunk, -1);
+		trunk_ref->trunk = NULL;
+	}
+}
+
 static struct sla_trunk_ref *create_trunk_ref(struct sla_trunk *trunk)
 {
 	struct sla_trunk_ref *trunk_ref;
 
-	if (!(trunk_ref = ast_calloc(1, sizeof(*trunk_ref))))
+	if (!(trunk_ref = ao2_alloc(sizeof(*trunk_ref), sla_trunk_ref_destructor))) {
 		return NULL;
+	}
 
+	ao2_ref(trunk, 1);
 	trunk_ref->trunk = trunk;
 
 	return trunk_ref;
@@ -6865,9 +6940,11 @@
 {
 	struct sla_ringing_trunk *ringing_trunk;
 
-	if (!(ringing_trunk = ast_calloc(1, sizeof(*ringing_trunk))))
+	if (!(ringing_trunk = ast_calloc(1, sizeof(*ringing_trunk)))) {
 		return NULL;
-	
+	}
+
+	ao2_ref(trunk, 1);
 	ringing_trunk->trunk = trunk;
 	ringing_trunk->ring_begin = ast_tvnow();
 
@@ -6882,6 +6959,16 @@
 	return ringing_trunk;
 }
 
+static void sla_ringing_trunk_destroy(struct sla_ringing_trunk *ringing_trunk)
+{
+	if (ringing_trunk->trunk) {
+		ao2_ref(ringing_trunk->trunk, -1);
+		ringing_trunk->trunk = NULL;
+	}
+
+	ast_free(ringing_trunk);
+}
+
 enum {
 	SLA_TRUNK_OPT_MOH = (1 << 0),
 };
@@ -6900,7 +6987,7 @@
 	char conf_name[MAX_CONFNUM];
 	struct ast_conference *conf;
 	struct ast_flags64 conf_flags = { 0 };
-	struct sla_trunk *trunk;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
 	struct sla_ringing_trunk *ringing_trunk;
 	AST_DECLARE_APP_ARGS(args,
 		AST_APP_ARG(trunk_name);
@@ -6924,16 +7011,11 @@
 		}
 	}
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
 	trunk = sla_find_trunk(args.trunk_name);
-	if (trunk)
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, 1);
-	AST_RWLIST_UNLOCK(&sla_trunks);
 
 	if (!trunk) {
 		ast_log(LOG_ERROR, "SLA Trunk '%s' not found!\n", args.trunk_name);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6941,8 +7023,6 @@
 		ast_log(LOG_ERROR, "Call came in on %s, but the trunk is already in use!\n",
 			args.trunk_name);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6950,8 +7030,6 @@
 
 	if (!(ringing_trunk = queue_ringing_trunk(trunk))) {
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 
@@ -6959,8 +7037,6 @@
 	conf = build_conf(conf_name, "", "", 1, 1, 1, chan, NULL);
 	if (!conf) {
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "FAILURE");
-		ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-		sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
 		return 0;
 	}
 	ast_set_flag64(&conf_flags, 
@@ -6994,46 +7070,37 @@
 	AST_LIST_TRAVERSE_SAFE_END;
 	ast_mutex_unlock(&sla.lock);
 	if (ringing_trunk) {
-		ast_free(ringing_trunk);
+		sla_ringing_trunk_destroy(ringing_trunk);
 		pbx_builtin_setvar_helper(chan, "SLATRUNK_STATUS", "UNANSWERED");
 		/* Queue reprocessing of ringing trunks to make stations stop ringing
 		 * that shouldn't be ringing after this trunk stopped. */
 		sla_queue_event(SLA_EVENT_RINGING_TRUNK);
 	}
 
-	ast_atomic_fetchadd_int((int *) &trunk->ref_count, -1);
-	sla_queue_event(SLA_EVENT_CHECK_RELOAD);	
-
 	return 0;
 }
 
 static enum ast_device_state sla_state(const char *data)
 {
 	char *buf, *station_name, *trunk_name;
-	struct sla_station *station;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
 	struct sla_trunk_ref *trunk_ref;
 	enum ast_device_state res = AST_DEVICE_INVALID;
 
 	trunk_name = buf = ast_strdupa(data);
 	station_name = strsep(&trunk_name, "_");
 
-	AST_RWLIST_RDLOCK(&sla_stations);
-	AST_LIST_TRAVERSE(&sla_stations, station, entry) {
-		if (strcasecmp(station_name, station->name))
-			continue;
-		AST_RWLIST_RDLOCK(&sla_trunks);
+	station = sla_find_station(station_name);
+	if (station) {
+		ao2_lock(station);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
-			if (!strcasecmp(trunk_name, trunk_ref->trunk->name))
+			if (!strcasecmp(trunk_name, trunk_ref->trunk->name)) {
+				res = sla_state_to_devstate(trunk_ref->state);
 				break;
+			}
 		}
-		if (!trunk_ref) {
-			AST_RWLIST_UNLOCK(&sla_trunks);
-			break;
-		}
-		res = sla_state_to_devstate(trunk_ref->state);
-		AST_RWLIST_UNLOCK(&sla_trunks);
+		ao2_unlock(station);
 	}
-	AST_RWLIST_UNLOCK(&sla_stations);
 
 	if (res == AST_DEVICE_INVALID) {
 		ast_log(LOG_ERROR, "Could not determine state for trunk %s on station %s!\n",
@@ -7043,26 +7110,39 @@
 	return res;
 }
 
-static void destroy_trunk(struct sla_trunk *trunk)
+static int sla_trunk_release_refs(void *obj, void *arg, int flags)
 {
+	struct sla_trunk *trunk = obj;
 	struct sla_station_ref *station_ref;
 
-	if (!ast_strlen_zero(trunk->autocontext))
-		ast_context_remove_extension(trunk->autocontext, "s", 1, sla_registrar);
-
-	while ((station_ref = AST_LIST_REMOVE_HEAD(&trunk->stations, entry)))
-		ast_free(station_ref);
+	while ((station_ref = AST_LIST_REMOVE_HEAD(&trunk->stations, entry))) {
+		ao2_ref(station_ref, -1);
+	}
 
-	ast_string_field_free_memory(trunk);
-	ast_free(trunk);
+	return 0;
 }
 
-static void destroy_station(struct sla_station *station)
+static int sla_station_release_refs(void *obj, void *arg, int flags)
 {
+	struct sla_station *station = obj;
 	struct sla_trunk_ref *trunk_ref;
 
+	while ((trunk_ref = AST_LIST_REMOVE_HEAD(&station->trunks, entry))) {
+		ao2_ref(trunk_ref, -1);
+	}
+
+	return 0;
+}
+
+static void sla_station_destructor(void *obj)
+{
+	struct sla_station *station = obj;
+
+	ast_debug(1, "sla_station destructor for '%s'\n", station->name);
+
 	if (!ast_strlen_zero(station->autocontext)) {
-		AST_RWLIST_RDLOCK(&sla_trunks);
+		struct sla_trunk_ref *trunk_ref;
+
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			char exten[AST_MAX_EXTENSION];
 			char hint[AST_MAX_APP];
@@ -7073,31 +7153,43 @@
 			ast_context_remove_extension(station->autocontext, hint, 
 				PRIORITY_HINT, sla_registrar);
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 	}
 
-	while ((trunk_ref = AST_LIST_REMOVE_HEAD(&station->trunks, entry)))
-		ast_free(trunk_ref);
+	sla_station_release_refs(station, NULL, 0);
 
 	ast_string_field_free_memory(station);
-	ast_free(station);
 }
 
-static void sla_destroy(void)
+static int sla_trunk_hash(const void *obj, const int flags)
 {
-	struct sla_trunk *trunk;
-	struct sla_station *station;
+	const struct sla_trunk *trunk = obj;
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	while ((trunk = AST_RWLIST_REMOVE_HEAD(&sla_trunks, entry)))
-		destroy_trunk(trunk);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	return ast_str_case_hash(trunk->name);
+}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
-	while ((station = AST_RWLIST_REMOVE_HEAD(&sla_stations, entry)))
-		destroy_station(station);
-	AST_RWLIST_UNLOCK(&sla_stations);
+static int sla_trunk_cmp(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj, *trunk2 = arg;
+
+	return !strcasecmp(trunk->name, trunk2->name) ? CMP_MATCH | CMP_STOP : 0;
+}
+
+static int sla_station_hash(const void *obj, const int flags)
+{
+	const struct sla_station *station = obj;
+
+	return ast_str_case_hash(station->name);
+}
 
+static int sla_station_cmp(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj, *station2 = arg;
+
+	return !strcasecmp(station->name, station2->name) ? CMP_MATCH | CMP_STOP : 0;
+}
+
+static void sla_destroy(void)
+{
 	if (sla.thread != AST_PTHREADT_NULL) {
 		ast_mutex_lock(&sla.lock);
 		sla.stop = 1;
@@ -7111,6 +7203,15 @@
 
 	ast_mutex_destroy(&sla.lock);
 	ast_cond_destroy(&sla.cond);
+
+	ao2_callback(sla_trunks, 0, sla_trunk_release_refs, NULL);
+	ao2_callback(sla_stations, 0, sla_station_release_refs, NULL);
+
+	ao2_ref(sla_trunks, -1);
+	sla_trunks = NULL;
+
+	ao2_ref(sla_stations, -1);
+	sla_stations = NULL;
 }
 
 static int sla_check_device(const char *device)
@@ -7126,11 +7227,27 @@
 	return 0;
 }
 
+static void sla_trunk_destructor(void *obj)
+{
+	struct sla_trunk *trunk = obj;
+
+	ast_debug(1, "sla_trunk destructor for '%s'\n", trunk->name);
+
+	if (!ast_strlen_zero(trunk->autocontext)) {
+		ast_context_remove_extension(trunk->autocontext, "s", 1, sla_registrar);
+	}
+
+	sla_trunk_release_refs(trunk, NULL, 0);
+
+	ast_string_field_free_memory(trunk);
+}
+
 static int sla_build_trunk(struct ast_config *cfg, const char *cat)
 {
-	struct sla_trunk *trunk;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
 	struct ast_variable *var;
 	const char *dev;
+	int existing_trunk = 0;
 
 	if (!(dev = ast_variable_retrieve(cfg, cat, "device"))) {
 		ast_log(LOG_ERROR, "SLA Trunk '%s' defined with no device!\n", cat);
@@ -7138,16 +7255,25 @@
 	}
 
 	if (sla_check_device(dev)) {
-		ast_log(LOG_ERROR, "SLA Trunk '%s' define with invalid device '%s'!\n",
+		ast_log(LOG_ERROR, "SLA Trunk '%s' defined with invalid device '%s'!\n",
 			cat, dev);
 		return -1;
 	}
 
-	if (!(trunk = ast_calloc_with_stringfields(1, struct sla_trunk, 32))) {
+	if ((trunk = sla_find_trunk(cat))) {
+		trunk->mark = 0;
+		existing_trunk = 1;
+	} else if ((trunk = ao2_alloc(sizeof(*trunk), sla_trunk_destructor))) {
+		if (ast_string_field_init(trunk, 32)) {
+			return -1;
+		}
+		ast_string_field_set(trunk, name, cat);
+	} else {
 		return -1;
 	}
 
-	ast_string_field_set(trunk, name, cat);
+	ao2_lock(trunk);
+
 	ast_string_field_set(trunk, device, dev);
 
 	for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
@@ -7176,54 +7302,65 @@
 		}
 	}
 
+	ao2_unlock(trunk);
+
 	if (!ast_strlen_zero(trunk->autocontext)) {
 		struct ast_context *context;
 		context = ast_context_find_or_create(NULL, NULL, trunk->autocontext, sla_registrar);
 		if (!context) {
 			ast_log(LOG_ERROR, "Failed to automatically find or create "
 				"context '%s' for SLA!\n", trunk->autocontext);
-			destroy_trunk(trunk);
 			return -1;
 		}
 		if (ast_add_extension2(context, 0 /* don't replace */, "s", 1,
 			NULL, NULL, slatrunk_app, ast_strdup(trunk->name), ast_free_ptr, sla_registrar)) {
 			ast_log(LOG_ERROR, "Failed to automatically create extension "
 				"for trunk '%s'!\n", trunk->name);
-			destroy_trunk(trunk);
 			return -1;
 		}
 	}
 
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	AST_RWLIST_INSERT_TAIL(&sla_trunks, trunk, entry);
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	if (!existing_trunk) {
+		ao2_link(sla_trunks, trunk);
+	}
 
 	return 0;
 }
 
+/*!
+ * \internal
+ * \pre station is not locked
+ */
 static void sla_add_trunk_to_station(struct sla_station *station, struct ast_variable *var)
 {
-	struct sla_trunk *trunk;
-	struct sla_trunk_ref *trunk_ref;
+	RAII_VAR(struct sla_trunk *, trunk, NULL, ao2_cleanup);
+	struct sla_trunk_ref *trunk_ref = NULL;
 	struct sla_station_ref *station_ref;
 	char *trunk_name, *options, *cur;
+	int existing_trunk_ref = 0;
+	int existing_station_ref = 0;
 
 	options = ast_strdupa(var->value);
 	trunk_name = strsep(&options, ",");
-	
-	AST_RWLIST_RDLOCK(&sla_trunks);
-	AST_RWLIST_TRAVERSE(&sla_trunks, trunk, entry) {
-		if (!strcasecmp(trunk->name, trunk_name))
-			break;
-	}
 
-	AST_RWLIST_UNLOCK(&sla_trunks);
+	trunk = sla_find_trunk(trunk_name);
 	if (!trunk) {
 		ast_log(LOG_ERROR, "Trunk '%s' not found!\n", var->value);
 		return;
 	}
-	if (!(trunk_ref = create_trunk_ref(trunk)))
+
+	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
+		if (trunk_ref->trunk == trunk) {
+			trunk_ref->mark = 0;
+			existing_trunk_ref = 1;
+			break;
+		}
+	}
+
+	if (!trunk_ref && !(trunk_ref = create_trunk_ref(trunk))) {
 		return;
+	}
+
 	trunk_ref->state = SLA_TRUNK_STATE_IDLE;
 
 	while ((cur = strsep(&options, ","))) {
@@ -7247,41 +7384,73 @@
 		}
 	}
 
-	if (!(station_ref = sla_create_station_ref(station))) {
-		ast_free(trunk_ref);
+	AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
+		if (station_ref->station == station) {
+			station_ref->mark = 0;
+			existing_station_ref = 1;
+			break;
+		}
+	}
+
+	if (!station_ref && !(station_ref = sla_create_station_ref(station))) {
+		if (!existing_trunk_ref) {
+			ao2_ref(trunk_ref, -1);
+		} else {
+			trunk_ref->mark = 1;
+		}
 		return;
 	}
-	ast_atomic_fetchadd_int((int *) &trunk->num_stations, 1);
-	AST_RWLIST_WRLOCK(&sla_trunks);
-	AST_LIST_INSERT_TAIL(&trunk->stations, station_ref, entry);
-	AST_RWLIST_UNLOCK(&sla_trunks);
-	AST_LIST_INSERT_TAIL(&station->trunks, trunk_ref, entry);
+
+	if (!existing_station_ref) {
+		ao2_lock(trunk);
+		AST_LIST_INSERT_TAIL(&trunk->stations, station_ref, entry);
+		ast_atomic_fetchadd_int((int *) &trunk->num_stations, 1);
+		ao2_unlock(trunk);
+	}
+
+	if (!existing_trunk_ref) {
+		ao2_lock(station);
+		AST_LIST_INSERT_TAIL(&station->trunks, trunk_ref, entry);
+		ao2_unlock(station);
+	}
 }
 
 static int sla_build_station(struct ast_config *cfg, const char *cat)
 {
-	struct sla_station *station;
+	RAII_VAR(struct sla_station *, station, NULL, ao2_cleanup);
 	struct ast_variable *var;
 	const char *dev;
+	int existing_station = 0;
 
 	if (!(dev = ast_variable_retrieve(cfg, cat, "device"))) {
 		ast_log(LOG_ERROR, "SLA Station '%s' defined with no device!\n", cat);
 		return -1;
 	}
 
-	if (!(station = ast_calloc_with_stringfields(1, struct sla_station, 32))) {
+	if ((station = sla_find_station(cat))) {
+		station->mark = 0;
+		existing_station = 1;
+	} else if ((station = ao2_alloc(sizeof(*station), sla_station_destructor))) {
+		if (ast_string_field_init(station, 32)) {
+			return -1;
+		}
+		ast_string_field_set(station, name, cat);
+	} else {
 		return -1;
 	}
 
-	ast_string_field_set(station, name, cat);
+	ao2_lock(station);
+
 	ast_string_field_set(station, device, dev);
 
 	for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
-		if (!strcasecmp(var->name, "trunk"))
+		if (!strcasecmp(var->name, "trunk")) {
+			ao2_unlock(station);
 			sla_add_trunk_to_station(station, var);
-		else if (!strcasecmp(var->name, "autocontext"))
+			ao2_lock(station);
+		} else if (!strcasecmp(var->name, "autocontext")) {
 			ast_string_field_set(station, autocontext, var->value);
-		else if (!strcasecmp(var->name, "ringtimeout")) {
+		} else if (!strcasecmp(var->name, "ringtimeout")) {
 			if (sscanf(var->value, "%30u", &station->ring_timeout) != 1) {
 				ast_log(LOG_WARNING, "Invalid ringtimeout '%s' specified for station '%s'\n",
 					var->value, station->name);
@@ -7309,6 +7478,8 @@
 		}
 	}
 
+	ao2_unlock(station);
+
 	if (!ast_strlen_zero(station->autocontext)) {
 		struct ast_context *context;
 		struct sla_trunk_ref *trunk_ref;
@@ -7316,7 +7487,6 @@
 		if (!context) {
 			ast_log(LOG_ERROR, "Failed to automatically find or create "
 				"context '%s' for SLA!\n", station->autocontext);
-			destroy_station(station);
 			return -1;
 		}
 		/* The extension for when the handset goes off-hook.
@@ -7325,10 +7495,8 @@
 			NULL, NULL, slastation_app, ast_strdup(station->name), ast_free_ptr, sla_registrar)) {
 			ast_log(LOG_ERROR, "Failed to automatically create extension "
 				"for trunk '%s'!\n", station->name);
-			destroy_station(station);
 			return -1;
 		}
-		AST_RWLIST_RDLOCK(&sla_trunks);
 		AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
 			char exten[AST_MAX_EXTENSION];
 			char hint[AST_MAX_APP];
@@ -7340,7 +7508,6 @@
 				NULL, NULL, slastation_app, ast_strdup(exten), ast_free_ptr, sla_registrar)) {
 				ast_log(LOG_ERROR, "Failed to automatically create extension "
 					"for trunk '%s'!\n", station->name);
-				destroy_station(station);
 				return -1;
 			}
 			/* Hint for this line button 
@@ -7349,20 +7516,115 @@
 				NULL, NULL, hint, NULL, NULL, sla_registrar)) {
 				ast_log(LOG_ERROR, "Failed to automatically create hint "
 					"for trunk '%s'!\n", station->name);
-				destroy_station(station);
 				return -1;
 			}
 		}
-		AST_RWLIST_UNLOCK(&sla_trunks);
 	}
 
-	AST_RWLIST_WRLOCK(&sla_stations);
-	AST_RWLIST_INSERT_TAIL(&sla_stations, station, entry);
-	AST_RWLIST_UNLOCK(&sla_stations);
+	if (!existing_station) {
+		ao2_link(sla_stations, station);
+	}
+
+	return 0;
+}
+
+static int sla_trunk_mark(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj;
+	struct sla_station_ref *station_ref;
+
+	ao2_lock(trunk);
+
+	trunk->mark = 1;
+
+	AST_LIST_TRAVERSE(&trunk->stations, station_ref, entry) {
+		station_ref->mark = 1;
+	}
+
+	ao2_unlock(trunk);
 
 	return 0;
 }
 
+static int sla_station_mark(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj;
+	struct sla_trunk_ref *trunk_ref;
+
+	ao2_lock(station);
+
+	station->mark = 1;
+
+	AST_LIST_TRAVERSE(&station->trunks, trunk_ref, entry) {
+		trunk_ref->mark = 1;
+	}
+
+	ao2_unlock(station);
+
+	return 0;
+}
+
+static int sla_trunk_is_marked(void *obj, void *arg, int flags)
+{
+	struct sla_trunk *trunk = obj;
+
+	ao2_lock(trunk);
+
+	if (trunk->mark) {
+		/* Only remove all of the station references if the trunk itself is going away */
+		sla_trunk_release_refs(trunk, NULL, 0);
+	} else {
+		struct sla_station_ref *station_ref;
+
+		/* Otherwise only remove references to stations no longer in the config */
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&trunk->stations, station_ref, entry) {
+			if (!station_ref->mark) {
+				continue;
+			}
+			AST_LIST_REMOVE_CURRENT(entry);
+			ao2_ref(station_ref, -1);
+		}
+		AST_LIST_TRAVERSE_SAFE_END
+	}
+
+	ao2_unlock(trunk);
+
+	return trunk->mark ? CMP_MATCH : 0;
+}
+
+static int sla_station_is_marked(void *obj, void *arg, int flags)
+{
+	struct sla_station *station = obj;
+
+	ao2_lock(station);
+
+	if (station->mark) {
+		/* Only remove all of the trunk references if the station itself is going away */
+		sla_station_release_refs(station, NULL, 0);
+	} else {
+		struct sla_trunk_ref *trunk_ref;
+
+		/* Otherwise only remove references to trunks no longer in the config */
+		AST_LIST_TRAVERSE_SAFE_BEGIN(&station->trunks, trunk_ref, entry) {
+			if (!trunk_ref->mark) {
+				continue;
+			}
+			AST_LIST_REMOVE_CURRENT(entry);
+			ao2_ref(trunk_ref, -1);
+		}
+		AST_LIST_TRAVERSE_SAFE_END
+	}
+
+	ao2_unlock(station);
+
+	return station->mark ? CMP_MATCH : 0;
+}
+
+static int sla_in_use(void)
+{
+	return ao2_container_count(sla_trunks) || ao2_container_count(sla_stations);
+}
+
 static int sla_load_config(int reload)
 {
 	struct ast_config *cfg;
@@ -7374,6 +7636,8 @@
 	if (!reload) {
 		ast_mutex_init(&sla.lock);
 		ast_cond_init(&sla.cond, NULL);
+		sla_trunks = ao2_container_alloc(1, sla_trunk_hash, sla_trunk_cmp);
+		sla_stations = ao2_container_alloc(1, sla_station_hash, sla_station_cmp);
 	}
 
 	if (!(cfg = ast_config_load(SLA_CONFIG_FILE, config_flags))) {
@@ -7386,21 +7650,8 @@
 	}
 
 	if (reload) {
-		struct sla_station *station;
-		struct sla_trunk *trunk;
-
-		/* We need to actually delete the previous versions of trunks and stations now */
-		AST_RWLIST_TRAVERSE_SAFE_BEGIN(&sla_stations, station, entry) {
-			AST_RWLIST_REMOVE_CURRENT(entry);
-			ast_free(station);
-		}
-		AST_RWLIST_TRAVERSE_SAFE_END;
-
-		AST_RWLIST_TRAVERSE_SAFE_BEGIN(&sla_trunks, trunk, entry) {
-			AST_RWLIST_REMOVE_CURRENT(entry);
-			ast_free(trunk);
-		}
-		AST_RWLIST_TRAVERSE_SAFE_END;
+		ao2_callback(sla_trunks, 0, sla_trunk_mark, NULL);
+		ao2_callback(sla_stations, 0, sla_station_mark, NULL);
 	}
 
 	if ((val = ast_variable_retrieve(cfg, "general", "attemptcallerid")))
@@ -7427,9 +7678,13 @@
 
 	ast_config_destroy(cfg);
 
-	/* Even if we don't have any stations, we may after a reload and we need to
-	 * be able to process the SLA_EVENT_RELOAD event in that case */
-	if (sla.thread == AST_PTHREADT_NULL && (!AST_LIST_EMPTY(&sla_stations) || !AST_LIST_EMPTY(&sla_trunks))) {
+	if (reload) {
+		ao2_callback(sla_trunks, OBJ_NODATA | OBJ_UNLINK | OBJ_MULTIPLE, sla_trunk_is_marked, NULL);
+		ao2_callback(sla_stations, OBJ_NODATA | OBJ_UNLINK | OBJ_MULTIPLE, sla_station_is_marked, NULL);
+	}
+
+	/* Start SLA event processing thread once SLA has been configured. */
+	if (sla.thread == AST_PTHREADT_NULL && sla_in_use()) {
 		ast_pthread_create(&sla.thread, NULL, sla_thread, NULL);
 	}
 
@@ -7514,15 +7769,7 @@
 static int load_config(int reload)
 {
 	load_config_meetme();
-
-	if (reload && sla.thread != AST_PTHREADT_NULL) {
-		sla_queue_event(SLA_EVENT_RELOAD);
-		ast_log(LOG_NOTICE, "A reload of the SLA configuration has been requested "
-			"and will be completed when the system is idle.\n");
-		return 0;
-	}
-	
-	return sla_load_config(0);
+	return sla_load_config(reload);
 }
 
 #define MEETME_DATA_EXPORT(MEMBER)					\
@@ -7735,8 +7982,6 @@
 	return res;
 }
 
-
-
 static int load_module(void)
 {
 	int res = 0;
--- apps/app_mixmonitor.c
+++ apps/app_mixmonitor.c
@@ -39,7 +39,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 383631 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398011 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_MONITOR_DIR */
 #include "asterisk/stringfields.h"
@@ -142,7 +142,7 @@
 				<variable name="MIXMONITOR_FILENAME">
 					<para>Will contain the filename used to record.</para>
 				</variable>
-			</variablelist>	
+			</variablelist>
 		</description>
 		<see-also>
 			<ref type="application">Monitor</ref>
@@ -409,7 +409,7 @@
 	ast_audiohook_destroy(&mixmonitor->audiohook);
 }
 
-static int startmon(struct ast_channel *chan, struct ast_audiohook *audiohook) 
+static int startmon(struct ast_channel *chan, struct ast_audiohook *audiohook)
 {
 	struct ast_channel *peer = NULL;
 	int res = 0;
@@ -420,7 +420,7 @@
 	ast_audiohook_attach(chan, audiohook);
 
 	if (!res && ast_test_flag(ast_channel_flags(chan), AST_FLAG_NBRIDGE) && (peer = ast_bridged_channel(chan)))
-		ast_softhangup(peer, AST_SOFTHANGUP_UNBRIDGE);	
+		ast_softhangup(peer, AST_SOFTHANGUP_UNBRIDGE);
 
 	return res;
 }
@@ -497,13 +497,15 @@
 		if (mixmonitor->mixmonitor_ds) {
 			ast_mutex_destroy(&mixmonitor->mixmonitor_ds->lock);
 			ast_cond_destroy(&mixmonitor->mixmonitor_ds->destruction_condition);
-			ast_free(mixmonitor->filename_write);
-			ast_free(mixmonitor->filename_read);
 			ast_free(mixmonitor->mixmonitor_ds);
-			ast_free(mixmonitor->name);
-			ast_free(mixmonitor->post_process);
 		}
 
+		ast_free(mixmonitor->name);
+		ast_free(mixmonitor->post_process);
+		ast_free(mixmonitor->filename);
+		ast_free(mixmonitor->filename_write);
+		ast_free(mixmonitor->filename_read);
+
 		/* Free everything in the recipient list */
 		clear_mixmonitor_recipient_list(mixmonitor);
 
@@ -513,6 +515,7 @@
 		if (mixmonitor->callid) {
 			ast_callid_unref(mixmonitor->callid);
 		}
+
 		ast_free(mixmonitor);
 	}
 }
@@ -587,7 +590,7 @@
 	}
 }
 
-static void *mixmonitor_thread(void *obj) 
+static void *mixmonitor_thread(void *obj)
 {
 	struct mixmonitor *mixmonitor = obj;
 	char *fs_ext = "";
@@ -740,6 +743,8 @@
 	}
 
 	mixmonitor_free(mixmonitor);
+
+	ast_module_unref(ast_module_info->self);
 	return NULL;
 }
 
@@ -779,7 +784,7 @@
 	return 0;
 }
 
-static void launch_monitor_thread(struct ast_channel *chan, const char *filename,
+static int launch_monitor_thread(struct ast_channel *chan, const char *filename,
 				  unsigned int flags, int readvol, int writevol,
 				  const char *post_process, const char *filename_write,
 				  char *filename_read, const char *uid_channel_var,
@@ -806,33 +811,33 @@
 
 	/* Pre-allocate mixmonitor structure and spy */
 	if (!(mixmonitor = ast_calloc(1, sizeof(*mixmonitor)))) {
-		return;
+		return -1;
 	}
 
 	/* Now that the struct has been calloced, go ahead and initialize the string fields. */
 	if (ast_string_field_init(mixmonitor, 512)) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* Setup the actual spy before creating our thread */
 	if (ast_audiohook_init(&mixmonitor->audiohook, AST_AUDIOHOOK_TYPE_SPY, mixmonitor_spy_type, 0)) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* Copy over flags and channel name */
 	mixmonitor->flags = flags;
 	if (!(mixmonitor->autochan = ast_autochan_setup(chan))) {
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	if (setup_mixmonitor_ds(mixmonitor, chan, &datastore_id)) {
 		ast_autochan_destroy(mixmonitor->autochan);
 		mixmonitor_free(mixmonitor);
 		ast_free(datastore_id);
-		return;
+		return -1;
 	}
 
 	if (!ast_strlen_zero(uid_channel_var)) {
@@ -901,13 +906,13 @@
 			mixmonitor_spy_type, ast_channel_name(chan));
 		ast_audiohook_destroy(&mixmonitor->audiohook);
 		mixmonitor_free(mixmonitor);
-		return;
+		return -1;
 	}
 
 	/* reference be released at mixmonitor destruction */
 	mixmonitor->callid = ast_read_threadstorage_callid();
 
-	ast_pthread_create_detached_background(&thread, NULL, mixmonitor_thread, mixmonitor);
+	return ast_pthread_create_detached_background(&thread, NULL, mixmonitor_thread, mixmonitor);
 }
 
 /* a note on filename_parse: creates directory structure and assigns absolute path from relative paths for filenames */
@@ -1028,7 +1033,10 @@
 	}
 
 	pbx_builtin_setvar_helper(chan, "MIXMONITOR_FILENAME", args.filename);
-	launch_monitor_thread(chan,
+
+	/* If launch_monitor_thread works, the module reference must not be released until it is finished. */
+	ast_module_ref(ast_module_info->self);
+	if (launch_monitor_thread(chan,
 			args.filename,
 			flags.flags,
 			readvol,
@@ -1037,7 +1045,9 @@
 			filename_write,
 			filename_read,
 			uid_channel_var,
-			recipients);
+			recipients)) {
+		ast_module_unref(ast_module_info->self);
+	}
 
 	return 0;
 }
@@ -1324,6 +1334,7 @@
 	res = stop_mixmonitor_full(c, mixmonitor_id);
 
 	if (res) {
+		ast_channel_unref(c);
 		astman_send_error(s, m, "Could not stop monitoring channel");
 		return AMI_SUCCESS;
 	}
@@ -1355,7 +1366,6 @@
 	res |= ast_manager_unregister("MixMonitorMute");
 	res |= ast_manager_unregister("MixMonitor");
 	res |= ast_manager_unregister("StopMixMonitor");
-
 	return res;
 }
 
--- apps/app_playback.c
+++ apps/app_playback.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 381217 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/file.h"
 #include "asterisk/pbx.h"
@@ -212,6 +212,10 @@
 		s = x + 1;
 	ast_debug(2, "value is <%s>\n", s);
 	n = ast_var_assign("SAY", s);
+	if (!n) {
+		ast_log(LOG_ERROR, "Memory allocation error in do_say\n");
+		return -1;
+	}
 	AST_LIST_INSERT_HEAD(&head, n, entries);
 
 	/* scan the body, one piece at a time */
--- apps/app_queue.c
+++ apps/app_queue.c
@@ -63,7 +63,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391241 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396948 $")
 
 #include <sys/time.h>
 #include <sys/signal.h>
@@ -402,7 +402,7 @@
 	</application>
 	<application name="UnpauseQueueMember" language="en_US">
 		<synopsis>
-			Unpauses a queue member.		
+			Unpauses a queue member.
 		</synopsis>
 		<syntax>
 			<parameter name="queuename" />
@@ -1083,8 +1083,8 @@
  *  q_next links ALL defined callattempt structures into a linked list. call_next is
  *  a link which allows for a subset of the callattempts to be traversed. This subset
  *  is used in wait_for_answer so that irrelevant callattempts are not traversed. This
- *  also is helpful so that queue logs are always accurate in the case where a call to 
- *  a member times out, especially if using the ringall strategy. 
+ *  also is helpful so that queue logs are always accurate in the case where a call to
+ *  a member times out, especially if using the ringall strategy.
 */
 
 struct callattempt {
@@ -1292,7 +1292,7 @@
 	int rrpos;                          /*!< Round Robin - position */
 	int memberdelay;                    /*!< Seconds to delay connecting member to caller */
 	int autofill;                       /*!< Ignore the head call status and ring an available agent */
-	
+
 	struct ao2_container *members;             /*!< Head of the list of members */
 	struct queue_ent *head;             /*!< Head of the list of callers */
 	AST_LIST_ENTRY(call_queue) list;    /*!< Next call queue */
@@ -1504,8 +1504,8 @@
 			q->name, q->maxlen, int2strat(q->strategy), q->count, q->holdtime, q->talktime, q->callscompleted, q->callsabandoned,  q->servicelevel, sl);
 
 		ao2_unlock(q);
-	
-		pbx_builtin_setvar_multiple(chan, interfacevar); 
+
+		pbx_builtin_setvar_multiple(chan, interfacevar);
 	} else {
 		ao2_unlock(q);
 	}
@@ -1709,7 +1709,7 @@
  * \retval 1 if the member is available
  * \retval 0 if the member is not available
  */
-static int is_member_available(struct member *mem)
+static int is_member_available(struct call_queue *q, struct member *mem)
 {
 	int available = 0;
 
@@ -1734,6 +1734,10 @@
 			break;
 	}
 
+	/* Let wrapuptimes override device state availability */
+	if (mem->lastcall && q->wrapuptime && (time(NULL) - q->wrapuptime < mem->lastcall)) {
+		available = 0;
+	}
 	return available;
 }
 
@@ -1774,7 +1778,7 @@
 
 			/* check every member until we find one NOT_INUSE */
 			if (!avail) {
-				avail = is_member_available(m);
+				avail = is_member_available(q, m);
 			}
 			if (avail && found_member) {
 				/* early exit as we've found an available member and the member of interest */
@@ -1959,7 +1963,7 @@
 		return 0;
 	} else if (c > 96) {
 		return c - 64;
-	} 
+	}
 	return c - 32;
 }
 
@@ -2123,7 +2127,7 @@
 	}
 
 	contentdup = ast_strdupa(content);
-	
+
 	if (!(maxstr = strchr(contentdup, ','))) {
 		ast_log(LOG_WARNING, "Improperly formatted penaltychange rule at line %d. Ignoring.\n", linenum);
 		ast_free(rule);
@@ -2144,7 +2148,7 @@
 	if ((minstr = strchr(maxstr,','))) {
 		*minstr++ = '\0';
 	}
-	
+
 	/* The last check will evaluate true if either no penalty change is indicated for a given rule
 	 * OR if a min penalty change is indicated but no max penalty change is */
 	if (*maxstr == '+' || *maxstr == '-' || *maxstr == '\0') {
@@ -2176,7 +2180,7 @@
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
-	
+
 		if (!inserted) {
 			AST_LIST_INSERT_TAIL(&rl_iter->rules, rule, list);
 			inserted = 1;
@@ -2229,7 +2233,7 @@
 }
 
 /*! \brief Configure a queue parameter.
- * 
+ *
  * The failunknown flag is set for config files (and static realtime) to show
  * errors for unknown parameters. It is cleared for dynamic realtime to allow
  *  extra fields in the tables.
@@ -2238,7 +2242,7 @@
 */
 static void queue_set_param(struct call_queue *q, const char *param, const char *val, int linenum, int failunknown)
 {
-	if (!strcasecmp(param, "musicclass") || 
+	if (!strcasecmp(param, "musicclass") ||
 		!strcasecmp(param, "music") || !strcasecmp(param, "musiconhold")) {
 		ast_string_field_set(q, moh, val);
 	} else if (!strcasecmp(param, "announce")) {
@@ -2645,7 +2649,7 @@
 				ao2_unlock(q);
 				queue_t_unref(q, "Queue is dead; can't return it");
 				return NULL;
-			} 
+			}
 			ast_log(LOG_WARNING, "Static queue '%s' already exists. Not loading from realtime\n", q->name);
 			ao2_unlock(q);
 			return q;
@@ -3246,7 +3250,7 @@
 }
 
 /*! \brief Caller leaving queue.
- * 
+ *
  * Search the queue to find the leaving client, if found remove from queue
  * create manager event, move others up the queue.
 */
@@ -3384,7 +3388,7 @@
 	mem_iter = ao2_iterator_init(q->members, 0);
 	while ((mem = ao2_iterator_next(&mem_iter))) {
 
-		avl += is_member_available(mem);
+		avl += is_member_available(q, mem);
 		ao2_ref(mem, -1);
 
 		/* If autofill is not enabled or if the queue's strategy is ringall, then
@@ -3596,11 +3600,11 @@
 	return 1;
 }
 
-/*! 
+/*!
  * \brief Part 2 of ring_one
  *
- * Does error checking before attempting to request a channel and call a member. 
- * This function is only called from ring_one(). 
+ * Does error checking before attempting to request a channel and call a member.
+ * This function is only called from ring_one().
  * Failure can occur if:
  * - Agent on call
  * - Agent is paused
@@ -3675,7 +3679,7 @@
 		} else if (!ast_strlen_zero(ast_channel_dialed(qe->chan)->number.str)) {
 			ast_set_callerid(tmp->chan, ast_channel_dialed(qe->chan)->number.str, NULL, NULL);
 		} else if (!ast_strlen_zero(S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)))) {
-			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL); 
+			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL);
 		}
 		tmp->dial_callerid_absent = 1;
 	}
@@ -3807,7 +3811,7 @@
 	return best;
 }
 
-/*! 
+/*!
  * \brief Place a call to a queue member.
  *
  * Once metrics have been calculated for each member, this function is used
@@ -3841,7 +3845,7 @@
 			ast_debug(1, "Trying '%s' with metric %d\n", best->interface, best->metric);
 			ret = ring_entry(qe, best, busies);
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			ast_debug(1, "Queue timed out while ringing members.\n");
@@ -3923,14 +3927,14 @@
 	}
 
 	ast_verb(3, "Playing periodic announcement\n");
-	
+
 	if (qe->parent->randomperiodicannounce && qe->parent->numperiodicannounce) {
 		qe->last_periodic_announce_sound = ((unsigned long) ast_random()) % qe->parent->numperiodicannounce;
-	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce || 
+	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce ||
 		ast_str_strlen(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]) == 0) {
 		qe->last_periodic_announce_sound = 0;
 	}
-	
+
 	/* play the announcement */
 	res = play_file(qe->chan, ast_str_buffer(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]));
 
@@ -3958,7 +3962,7 @@
 	if (!qe->parent->randomperiodicannounce) {
 		qe->last_periodic_announce_sound++;
 	}
-	
+
 	return res;
 }
 
@@ -4601,7 +4605,7 @@
  	if (qe->parent->periodicannouncefrequency && qe->parent->announce_to_first_user) {
  		say_periodic_announcement(qe, ringing);
  	}
- 
+
 	if (!*to) {
 		for (o = start; o; o = o->call_next) {
 			rna(orig, qe, o->interface, o->member->membername, 1);
@@ -4619,7 +4623,7 @@
 	return peer;
 }
 
-/*! 
+/*!
  * \brief Check if we should start attempting to call queue members.
  *
  * A simple process, really. Count the number of members who are available
@@ -4649,11 +4653,11 @@
 		if (!ch->pending) {
 			idx++;
 		}
-		ch = ch->next;			
+		ch = ch->next;
 	}
 
 	ao2_unlock(qe->parent);
-	/* If the queue entry is within avl [the number of available members] calls from the top ... 
+	/* If the queue entry is within avl [the number of available members] calls from the top ...
 	 * Autofill and position check added to support autofill=no (as only calls
 	 * from the front of the queue are valid when autofill is disabled)
 	 */
@@ -4678,7 +4682,7 @@
 {
 	int max_penalty = qe->pr->max_relative ? qe->max_penalty + qe->pr->max_value : qe->pr->max_value;
 	int min_penalty = qe->pr->min_relative ? qe->min_penalty + qe->pr->min_value : qe->pr->min_value;
-	char max_penalty_str[20], min_penalty_str[20]; 
+	char max_penalty_str[20], min_penalty_str[20];
 	/* a relative change to the penalty could put it below 0 */
 	if (max_penalty < 0) {
 		max_penalty = 0;
@@ -4753,7 +4757,7 @@
 		if (qe->parent->periodicannouncefrequency &&
 			(res = say_periodic_announcement(qe,ringing)))
 			break;
-		
+
 		/* see if we need to move to the next penalty level for this queue */
 		while (qe->pr && ((time(NULL) - qe->start) >= qe->pr->time)) {
 			update_qe_rule(qe);
@@ -4764,7 +4768,7 @@
 			*reason = QUEUE_TIMEOUT;
 			break;
 		}
-		
+
 		/* Wait a second before checking again */
 		if ((res = ast_waitfordigit(qe->chan, RECHECK * 1000))) {
 			if (res > 0 && !valid_exit(qe, res)) {
@@ -4773,7 +4777,7 @@
 				break;
 			}
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			*reason = QUEUE_TIMEOUT;
@@ -4816,7 +4820,7 @@
 		member->calls++;
 		member->lastqueue = q;
 		ao2_unlock(q);
-	}	
+	}
 	ao2_lock(q);
 	q->callscompleted++;
 	if (callcompletedinsl) {
@@ -5024,7 +5028,7 @@
 				(long) (time(NULL) - callstart), qe->opos);
 
 	update_queue(qe->parent, member, callcompletedinsl, (time(NULL) - callstart));
-	
+
 	/* No need to lock the channels because they are already locked in ast_do_masquerade */
 	if ((datastore = ast_channel_datastore_find(old_chan, &queue_transfer_info, NULL))) {
 		ast_channel_datastore_remove(old_chan, datastore);
@@ -5123,7 +5127,7 @@
  * \param[in] qe the queue_ent structure which corresponds to the caller attempting to reach members
  * \param[in] opts the options passed as the third parameter to the Queue() application
  * \param[in] opt_args the options passed as the third parameter to the Queue() application
- * \param[in] announceoverride filename to play to user when waiting 
+ * \param[in] announceoverride filename to play to user when waiting
  * \param[in] url the url passed as the fourth parameter to the Queue() application
  * \param[in,out] tries the number of times we have tried calling queue members
  * \param[out] noption set if the call to Queue() has the 'n' option set.
@@ -5223,7 +5227,7 @@
 		ast_set_flag(&(bridge_config.features_caller), AST_FEATURE_PARKCALL);
 	}
 	if (ast_test_flag(&opts, OPT_NO_RETRY)) {
-		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR 
+		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR
 			|| qe->parent->strategy == QUEUE_STRATEGY_RRORDERED) {
 			(*tries)++;
 		} else {
@@ -5304,7 +5308,7 @@
 		AST_LIST_LOCK(dialed_interfaces);
 		AST_LIST_TRAVERSE(dialed_interfaces, di, list) {
 			if (!strcasecmp(cur->interface, di->interface)) {
-				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n", 
+				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n",
 					di->interface);
 				break;
 			}
@@ -5359,7 +5363,7 @@
 			   XXX If we're forcibly removed, these outgoing calls won't get
 			   hung up XXX */
 			tmp->q_next = outgoing;
-			outgoing = tmp;		
+			outgoing = tmp;
 			/* If this line is up, don't try anybody else */
 			if (outgoing->chan && (ast_channel_state(outgoing->chan) == AST_STATE_UP))
 				break;
@@ -5583,7 +5587,7 @@
 		 	pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-		
+
 		/* if setqueueentryvar is defined, make queue entry (i.e. the caller) variables available to the channel */
 		/* use  pbx_builtin_setvar to set a load of variables with one call */
 		if (qe->parent->setqueueentryvar) {
@@ -5592,7 +5596,7 @@
 			pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-	
+
 		ao2_unlock(qe->parent);
 
 		/* try to set queue variables if configured to do so*/
@@ -5636,7 +5640,7 @@
 				}
 			} else {
 				mixmonapp = pbx_findapp("MixMonitor");
-				
+
 				if (mixmonapp) {
 					ast_debug(1, "Starting MixMonitor as requested.\n");
 					if (!monitorfilename) {
@@ -5703,7 +5707,7 @@
 
 						pbx_substitute_variables_helper(qe->chan, meid2, meid, sizeof(meid) - 1);
 					}
-	
+
 					snprintf(tmpid2, sizeof(tmpid2), "%s.%s", tmpid, qe->parent->monfmt);
 
 					if (!ast_strlen_zero(monitor_exec)) {
@@ -5711,7 +5715,7 @@
 					} else {
 						snprintf(mixmonargs, sizeof(mixmonargs), "%s,b%s", tmpid2, monitor_options);
 					}
-					
+
 					ast_debug(1, "Arguments being passed to MixMonitor: %s\n", mixmonargs);
 					/* We purposely lock the CDR so that pbx_exec does not update the application data */
 					if (ast_channel_cdr(qe->chan)) {
@@ -5727,12 +5731,12 @@
 			}
 		}
 		/* Drop out of the queue at this point, to prepare for next caller */
-		leave_queue(qe);			
+		leave_queue(qe);
 		if (!ast_strlen_zero(url) && ast_channel_supports_html(peer)) {
 			ast_debug(1, "app_queue: sendurl=%s.\n", url);
 			ast_channel_sendurl(peer, url);
 		}
-		
+
 		/* run a macro for this connection if defined. The macro simply returns, no action is taken on the result */
 		/* use macro from dialplan if passed as a option, otherwise use the default queue macro */
 		if (!ast_strlen_zero(macro)) {
@@ -5869,7 +5873,7 @@
 					qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		ast_copy_string(oldcontext, ast_channel_context(qe->chan), sizeof(oldcontext));
 		ast_copy_string(oldexten, ast_channel_exten(qe->chan), sizeof(oldexten));
-	
+
 		if ((queue_end_bridge = ao2_alloc(sizeof(*queue_end_bridge), NULL))) {
 			queue_end_bridge->q = qe->parent;
 			queue_end_bridge->chan = qe->chan;
@@ -5910,7 +5914,7 @@
 					(long) (callstart - qe->start), (long) (time(NULL) - callstart), qe->opos);
 				send_agent_complete(qe, queuename, peer, member, callstart, vars, sizeof(vars), AGENT);
 			}
-			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {	
+			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {
 				ast_channel_datastore_remove(qe->chan, tds);
 			}
 			ast_channel_unlock(qe->chan);
@@ -6038,7 +6042,7 @@
 	ast_free(value);
 }
 
-/*! \brief Remove member from queue 
+/*! \brief Remove member from queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY removed member from queue
@@ -6107,7 +6111,7 @@
 	return res;
 }
 
-/*! \brief Add member to queue 
+/*! \brief Add member to queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY added member from queue
@@ -6169,7 +6173,7 @@
 				new_member->penalty, new_member->calls, (int) new_member->lastcall,
 				new_member->status, new_member->paused);
 
-			if (is_member_available(new_member)) {
+			if (is_member_available(q, new_member)) {
 				ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 			}
 
@@ -6235,7 +6239,7 @@
 					dump_queue_members(q);
 				}
 
-				if (is_member_available(mem)) {
+				if (is_member_available(q, mem)) {
 					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 				} else if (!num_available_members(q)) {
 					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
@@ -6587,7 +6591,7 @@
 				ast_log(LOG_WARNING, "Error converting penalty: %s: Out of range.\n", penalty_tok);
 				break;
 			}
-			
+
 			if (!paused_tok) {
 				ast_log(LOG_WARNING, "Error parsing persistent member string for '%s' (paused)\n", queue_name);
 				break;
@@ -6599,7 +6603,7 @@
 			}
 
 			ast_debug(1, "Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d\n", queue_name, interface, membername, penalty, paused);
-			
+
 			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface) == RES_OUTOFMEMORY) {
 				ast_log(LOG_ERROR, "Out of Memory when reloading persistent queue member\n");
 				break;
@@ -6854,7 +6858,7 @@
 		return -1;
 	}
 
-	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event, 
+	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event,
 		"%s", args.params ? args.params : "");
 
 	return 0;
@@ -6892,14 +6896,14 @@
 
 /*!\brief The starting point for all queue calls
  *
- * The process involved here is to 
+ * The process involved here is to
  * 1. Parse the options specified in the call to Queue()
  * 2. Join the queue
  * 3. Wait in a loop until it is our turn to try calling a queue member
  * 4. Attempt to call a queue member
  * 5. If 4. did not result in a bridged call, then check for between
  *    call options such as periodic announcements etc.
- * 6. Try 4 again unless some condition (such as an expiration time) causes us to 
+ * 6. Try 4 again unless some condition (such as an expiration time) causes us to
  *    exit the queue.
  */
 static int queue_exec(struct ast_channel *chan, const char *data)
@@ -7084,7 +7088,7 @@
 			record_abandoned(&qe);
 			reason = QUEUE_TIMEOUT;
 			res = 0;
-			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld", 
+			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld",
 				qe.pos, qe.opos, (long) time(NULL) - qe.start);
 			break;
 		}
@@ -7103,7 +7107,7 @@
 				goto stop;
 			}
 		}
-	
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7145,7 +7149,7 @@
 			break;
 		}
 
-		
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7194,12 +7198,12 @@
 
 	/* Don't allow return code > 0 */
 	if (res >= 0) {
-		res = 0;	
+		res = 0;
 		if (ringing) {
 			ast_indicate(chan, -1);
 		} else {
 			ast_moh_stop(chan);
-		}			
+		}
 		ast_stopstream(chan);
 	}
 
@@ -7374,6 +7378,9 @@
 			   ((m = interface_exists(q, args.interface)))) {
 			count = m->ringinuse;
 			ao2_ref(m, -1);
+		} else if (!ast_strlen_zero(args.interface)) {
+			ast_log(LOG_ERROR, "Queue member interface %s not in queue %s\n",
+				args.interface, args.queuename);
 		} else {
 			ast_log(LOG_ERROR, "Unknown option %s provided to %s, valid values are: "
 				"logged, free, ready, count, penalty, paused, ringinuse\n", args.option, cmd);
@@ -7488,7 +7495,7 @@
 		ast_log(LOG_ERROR, "%s requires an argument: queuename\n", cmd);
 		return -1;
 	}
-	
+
 	if ((q = find_load_queue_rt_friendly(data))) {
 		ao2_lock(q);
 		mem_iter = ao2_iterator_init(q->members, 0);
@@ -7622,7 +7629,7 @@
 	}
 
 	penalty = get_member_penalty (args.queuename, args.interface);
-	
+
 	if (penalty >= 0) { /* remember that buf is already '\0' */
 		snprintf (buf, len, "%d", penalty);
 	}
@@ -7718,7 +7725,7 @@
 	char *rulecat = NULL;
 	struct ast_variable *rulevar = NULL;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
-	
+
 	if (!(cfg = ast_config_load("queuerules.conf", config_flags))) {
 		ast_log(LOG_NOTICE, "No queuerules.conf file found, queues will not follow penalty rules\n");
 		return AST_MODULE_LOAD_SUCCESS;
@@ -7919,7 +7926,7 @@
  *
  * Once we have isolated a queue within reload_queues, we call this. This will either
  * reload information for the queue or if we're just reloading member information, we'll just
- * reload that without touching other settings within the queue 
+ * reload that without touching other settings within the queue
  *
  * \param cfg The configuration which we are reading
  * \param mask Tells us what information we need to reload
@@ -7955,7 +7962,7 @@
 	} else {
 		new = 0;
 	}
-	
+
 	if (!new) {
 		ao2_lock(q);
 		prev_weight = q->weight ? 1 : 0;
@@ -8074,7 +8081,7 @@
  * \param mask Gives flags telling us what information to actually reload
  * \param queuename If set to a non-zero string, then only reload information from
  * that particular queue. Otherwise inspect all queues
- * \retval -1 Failure occurred 
+ * \retval -1 Failure occurred
  * \retval 0 All clear!
  */
 static int reload_queues(int reload, struct ast_flags *mask, const char *queuename)
@@ -8198,9 +8205,9 @@
 	}
 }
 
-/*! 
- * \brief Show queue(s) status and statistics 
- * 
+/*!
+ * \brief Show queue(s) status and statistics
+ *
  * List the queues strategy, calls processed, members logged in,
  * other queue statistics such as avg hold time.
 */
@@ -8348,7 +8355,7 @@
 	return CLI_SUCCESS;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param list Space delimited list of words
@@ -8405,11 +8412,11 @@
 		/* terminating conditions satisfied, word at beginning or separated by ' ' */
 		return 1;
 	}
-	
+
 	return 0;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param line The line as typed not including the current word being completed
@@ -8475,7 +8482,7 @@
 			"       Provides summary information on a specified queue.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return complete_queue_show(a->line, a->word, a->pos, a->n);	
+		return complete_queue_show(a->line, a->word, a->pos, a->n);
 	}
 
 	return __queues_show(NULL, a->fd, a->argc, a->argv);
@@ -8585,7 +8592,7 @@
 				"Queue: %s\r\n"
 				"LoggedIn: %d\r\n"
 				"Available: %d\r\n"
-				"Callers: %d\r\n" 
+				"Callers: %d\r\n"
 				"HoldTime: %d\r\n"
 				"TalkTime: %d\r\n"
 				"LongestHoldTime: %d\r\n"
@@ -8895,7 +8902,7 @@
 {
 	const char *queuename = NULL;
 	struct ast_flags mask = {QUEUE_RESET_STATS,};
-	
+
 	queuename = astman_get_header(m, "Queue");
 
 	if (!reload_handler(1, &mask, queuename)) {
@@ -8985,7 +8992,7 @@
 		astman_send_error(s, m, "Need 'Interface' and 'Penalty' parameters.");
 		return 0;
 	}
- 
+
 	penalty = atoi(penalty_s);
 
 	if (set_member_value((char *)queuename, (char *)interface, MEMBER_PENALTY, penalty)) {
@@ -9207,7 +9214,7 @@
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue {pause|unpause} member";
-		e->usage = 
+		e->usage =
 			"Usage: queue {pause|unpause} member <member> [queue <queue> [reason <reason>]]\n"
 			"	Pause or unpause a queue member. Not specifying a particular queue\n"
 			"	will pause or unpause a member across all queues to which the member\n"
@@ -9342,7 +9349,7 @@
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue set penalty";
-		e->usage = 
+		e->usage =
 		"Usage: queue set penalty <penalty> on <interface> [in <queue>]\n"
 		"	Set a member's penalty in the queue specified. If no queue is specified\n"
 		"	then that interface's penalty is set in all queues to which that interface is a member\n";
@@ -9375,7 +9382,7 @@
 	}
 }
 
-static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state) 
+static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state)
 {
 	int which = 0;
 	struct rule_list *rl_iter;
@@ -9429,7 +9436,7 @@
 		}
 	}
 	AST_LIST_UNLOCK(&rule_lists);
-	return CLI_SUCCESS; 
+	return CLI_SUCCESS;
 }
 
 static char *handle_queue_reset(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
@@ -9535,7 +9542,7 @@
 	return CLI_SUCCESS;
 }
 
-static const char qpm_cmd_usage[] = 
+static const char qpm_cmd_usage[] =
 "Usage: queue pause member <channel> in <queue> reason <reason>\n";
 
 static const char qum_cmd_usage[] =
--- apps/app_stack.c
+++ apps/app_stack.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
  
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 371592 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/pbx.h"
 #include "asterisk/module.h"
@@ -245,8 +245,9 @@
 	}
 
 	if (!found) {
-		variables = ast_var_assign(var, "");
-		AST_LIST_INSERT_HEAD(&frame->varshead, variables, entries);
+		if ((variables = ast_var_assign(var, ""))) {
+			AST_LIST_INSERT_HEAD(&frame->varshead, variables, entries);
+		}
 		pbx_builtin_pushvar_helper(chan, var, value);
 	} else {
 		pbx_builtin_setvar_helper(chan, var, value);
--- apps/app_verbose.c
+++ apps/app_verbose.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 356042 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397948 $")
 
 #include "asterisk/module.h"
 #include "asterisk/app.h"
@@ -63,7 +63,7 @@
 		<syntax>
 			<parameter name="level" required="true">
 				<para>Level must be one of <literal>ERROR</literal>, <literal>WARNING</literal>, <literal>NOTICE</literal>,
-				<literal>DEBUG</literal>, <literal>VERBOSE</literal> or <literal>DTMF</literal>.</para>	
+				<literal>DEBUG</literal>, <literal>VERBOSE</literal> or <literal>DTMF</literal>.</para>
 			</parameter>
 			<parameter name="message" required="true">
 				<para>Output text message.</para>
@@ -100,24 +100,8 @@
 		vsize = 0;
 		ast_log(LOG_WARNING, "'%s' is not a verboser number\n", args.level);
 	}
-	if (option_verbose >= vsize) {
-		switch (vsize) {
-		case 0:
-			ast_verb(0, "%s\n", args.msg);
-			break;
-		case 1:
-			ast_verb(1, "%s\n", args.msg);
-			break;
-		case 2:
-			ast_verb(2, "%s\n", args.msg);
-			break;
-		case 3:
-			ast_verb(3, "%s\n", args.msg);
-			break;
-		default:
-			ast_verb(4, "%s\n", args.msg);
-		}
-	}
+
+	ast_verb(vsize, "%s\n", args.msg);
 
 	return 0;
 }
@@ -171,7 +155,7 @@
 	res = ast_unregister_application(app_verbose);
 	res |= ast_unregister_application(app_log);
 
-	return res;	
+	return res;
 }
 
 static int load_module(void)
--- apps/app_voicemail.c
+++ apps/app_voicemail.c
@@ -91,7 +91,7 @@
 #endif
 #endif
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388816 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398281 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_SPOOL_DIR */
 #include <sys/time.h>
@@ -15159,6 +15159,7 @@
 				DISPOSE(vms->curdir, vms->curmsg);
 				break;
 			}
+			ast_config_destroy(msg_cfg);
 			DISPOSE(vms->curdir, vms->curmsg);
 		}
 		if (!found) {
--- apps/confbridge/conf_config_parser.c
+++ apps/confbridge/conf_config_parser.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 382066 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391700 $")
 #include "asterisk/logger.h"
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -1320,12 +1320,10 @@
 	return 0;
 }
 
-int conf_load_config(int reload)
+int conf_load_config(void)
 {
-	if (!reload) {
-		if (aco_info_init(&cfg_info)) {
-			return -1;
-		}
+	if (aco_info_init(&cfg_info)) {
+		return -1;
 	}
 
 	/* User options */
@@ -1373,23 +1371,29 @@
 	/* Menu options */
 	aco_option_register_custom(&cfg_info, "^[0-9A-D*#]+$", ACO_REGEX, menu_types, NULL, menu_option_handler, 0);
 
-	if (aco_process_config(&cfg_info, reload) == ACO_PROCESS_ERROR) {
+	if (aco_process_config(&cfg_info, 0) == ACO_PROCESS_ERROR) {
 		goto error;
 	}
 
-	if (!reload && ast_cli_register_multiple(cli_confbridge_parser, ARRAY_LEN(cli_confbridge_parser))) {
+	if (ast_cli_register_multiple(cli_confbridge_parser, ARRAY_LEN(cli_confbridge_parser))) {
 		goto error;
 	}
 
 	return 0;
 error:
-	/* On a reload, just keep the config we already have in place. */
-	if (!reload) {
-		conf_destroy_config();
-	}
+	conf_destroy_config();
 	return -1;
 }
 
+int conf_reload_config(void)
+{
+	if (aco_process_config(&cfg_info, 1) == ACO_PROCESS_ERROR) {
+		/* On a reload, just keep the config we already have in place. */
+		return -1;
+	}
+	return 0;
+}
+
 static void conf_user_profile_copy(struct user_profile *dst, struct user_profile *src)
 {
 	*dst = *src;
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -244,7 +244,10 @@
 };
 
 /*! \brief load confbridge.conf file */
-int conf_load_config(int reload);
+int conf_load_config(void);
+
+/*! \brief reload confbridge.conf file */
+int conf_reload_config(void);
 
 /*! \brief destroy the information loaded from the confbridge.conf file*/
 void conf_destroy_config(void);
--- cel/cel_custom.c
+++ cel/cel_custom.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 337975 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398168 $")
 
 #include "asterisk/paths.h"
 #include "asterisk/channel.h"
@@ -82,6 +82,7 @@
 	struct ast_config *cfg;
 	struct ast_variable *var;
 	struct ast_flags config_flags = { 0 };
+	int mappings = 0;
 	int res = 0;
 
 	cfg = ast_config_load(CONFIG, config_flags);
@@ -90,7 +91,10 @@
 		return -1;
 	}
 
-	var = ast_variable_browse(cfg, "mappings");
+	if (!(var = ast_variable_browse(cfg, "mappings"))) {
+		ast_log(LOG_NOTICE, "No mappings found in " CONFIG ". Not logging CEL to custom CSVs.\n");
+	}
+
 	while (var) {
 		if (!ast_strlen_zero(var->name) && !ast_strlen_zero(var->value)) {
 			struct cel_config *sink = ast_calloc_with_stringfields(1, struct cel_config, 1024);
@@ -105,6 +109,8 @@
 			ast_string_field_build(sink, filename, "%s/%s/%s", ast_config_AST_LOG_DIR, name, var->name);
 			ast_mutex_init(&sink->lock);
 
+			ast_verb(3, "Added CEL CSV mapping for '%s'.\n", sink->filename);
+			mappings += 1;
 			AST_RWLIST_INSERT_TAIL(&sinks, sink, list);
 		} else {
 			ast_log(LOG_NOTICE, "Mapping must have both a filename and a format at line %d\n", var->lineno);
@@ -113,6 +119,8 @@
 	}
 	ast_config_destroy(cfg);
 
+	ast_verb(1, "Added CEL CSV mapping for %d files.\n", mappings);
+
 	return res;
 }
 
--- channels/chan_dahdi.c
+++ channels/chan_dahdi.c
@@ -49,7 +49,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387298 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397744 $")
 
 #if defined(__NetBSD__) || defined(__FreeBSD__)
 #include <pthread.h>
@@ -566,14 +566,6 @@
 #endif	/* defined(HAVE_SS7) */
 
 #ifdef HAVE_OPENR2
-struct dahdi_mfcr2 {
-	pthread_t r2master;		       /*!< Thread of master */
-	openr2_context_t *protocol_context;    /*!< OpenR2 context handle */
-	struct dahdi_pvt *pvts[SIG_MFCR2_MAX_CHANNELS];     /*!< Member channel pvt structs */
-	int numchans;                          /*!< Number of channels in this R2 block */
-	int monitored_count;                   /*!< Number of channels being monitored */
-};
-
 struct dahdi_mfcr2_conf {
 	openr2_variant_t variant;
 	int mfback_timeout;
@@ -608,6 +600,15 @@
 	openr2_calling_party_category_t category;
 };
 
+/* MFC-R2 pseudo-link structure */
+struct dahdi_mfcr2 {
+	pthread_t r2master;		       /*!< Thread of master */
+	openr2_context_t *protocol_context;    /*!< OpenR2 context handle */
+	struct dahdi_pvt *pvts[SIG_MFCR2_MAX_CHANNELS];     /*!< Member channel pvt structs */
+	int numchans;                          /*!< Number of channels in this R2 block */
+	struct dahdi_mfcr2_conf conf;         /*!< Configuration used to setup this pseudo-link */
+};
+
 /* malloc'd array of malloc'd r2links */
 static struct dahdi_mfcr2 **r2links;
 /* how many r2links have been malloc'd */
@@ -4245,6 +4246,7 @@
 	snprintf(cause_str, sizeof(cause_str), "R2 DISCONNECT (%s)", openr2_proto_get_disconnect_string(cause));
 	datalen += strlen(cause_str);
 	cause_code = ast_alloca(datalen);
+	memset(cause_code, 0, datalen);
 	cause_code->ast_cause = dahdi_r2_cause_to_ast_cause(cause);
 	ast_copy_string(cause_code->chan_name, ast_channel_name(p->owner), AST_CHANNEL_NAME);
 	ast_copy_string(cause_code->code, cause_str, datalen + 1 - sizeof(*cause_code));
@@ -12428,14 +12430,20 @@
 	r2links_count = 0;
 }
 
-#define R2_LINK_CAPACITY 10
-static struct dahdi_mfcr2 *dahdi_r2_get_link(void)
+/* This is an artificial convenient capacity, to keep at most a full E1 of channels in a single thread */
+#define R2_LINK_CAPACITY 30
+static struct dahdi_mfcr2 *dahdi_r2_get_link(const struct dahdi_chan_conf *conf)
 {
 	struct dahdi_mfcr2 *new_r2link = NULL;
 	struct dahdi_mfcr2 **new_r2links = NULL;
-	/* this function is called just when starting up and no monitor threads have been launched,
-	   no need to lock monitored_count member */
-	if (!r2links_count || (r2links[r2links_count - 1]->monitored_count == R2_LINK_CAPACITY)) {
+
+	/* Only create a new R2 link if 
+	   1. This is the first link requested
+	   2. Configuration changed 
+	   3. We got more channels than supported per link */
+	if (!r2links_count ||
+	    memcmp(&conf->mfcr2, &r2links[r2links_count - 1]->conf, sizeof(conf->mfcr2)) ||
+	   (r2links[r2links_count - 1]->numchans == R2_LINK_CAPACITY)) {
 		new_r2link = ast_calloc(1, sizeof(**r2links));
 		if (!new_r2link) {
 			ast_log(LOG_ERROR, "Cannot allocate R2 link!\n");
@@ -12507,7 +12515,8 @@
 			ast_log(LOG_ERROR, "Failed to configure r2context from advanced configuration file %s\n", conf->mfcr2.r2proto_file);
 		}
 	}
-	r2_link->monitored_count = 0;
+	/* Save the configuration used to setup this link */
+	memcpy(&r2_link->conf, conf, sizeof(r2_link->conf));
 	return 0;
 }
 #endif
@@ -12738,7 +12747,7 @@
 #ifdef HAVE_OPENR2
 			if (chan_sig == SIG_MFCR2) {
 				struct dahdi_mfcr2 *r2_link;
-				r2_link = dahdi_r2_get_link();
+				r2_link = dahdi_r2_get_link(conf);
 				if (!r2_link) {
 					ast_log(LOG_WARNING, "Cannot get another R2 DAHDI context!\n");
 					destroy_dahdi_pvt(tmp);
@@ -12780,7 +12789,6 @@
 				tmp->mfcr2call = 0;
 				tmp->mfcr2_dnis_index = 0;
 				tmp->mfcr2_ani_index = 0;
-				r2_link->monitored_count++;
 			}
 #endif
 #ifdef HAVE_PRI
@@ -15452,6 +15460,7 @@
 	dahdi_softhangup_all();
 	ast_verb(4, "Final softhangup of all DAHDI channels complete.\n");
 	destroy_all_channels();
+	memset(round_robin, 0, sizeof(round_robin));
 	ast_debug(1, "Channels destroyed. Now re-reading config. %d active channels remaining.\n", ast_active_channels());
 
 	ast_mutex_unlock(&monlock);
--- channels/chan_h323.c
+++ channels/chan_h323.c
@@ -47,7 +47,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 366408 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398510 $")
 
 #ifdef __cplusplus
 }
@@ -346,8 +346,8 @@
 		if (h323debug)
 			ast_debug(1, "Preparing %s for new native format\n", ast_channel_name(c));
 		ast_format_cap_from_old_bitfield(ast_channel_nativeformats(c), pvt->nativeformats);
-		ast_set_read_format(c, &c->readformat);
-		ast_set_write_format(c, &c->writeformat);
+		ast_set_read_format(c, ast_channel_readformat(c));
+		ast_set_write_format(c, ast_channel_writeformat(c));
 	}
 	if (pvt->needhangup) {
 		if (h323debug)
@@ -787,8 +787,8 @@
 
 				pvt->nativeformats = ast_format_to_old_bitfield(&f->subclass.format);
 
-				ast_set_read_format(pvt->owner, &pvt->owner->readformat);
-				ast_set_write_format(pvt->owner, &pvt->owner->writeformat);
+				ast_set_read_format(pvt->owner, ast_channel_readformat(pvt->owner));
+				ast_set_write_format(pvt->owner, ast_channel_writeformat(pvt->owner));
 				ast_channel_unlock(pvt->owner);
 			}
 			/* Do in-band DTMF detection */
@@ -854,7 +854,10 @@
 		if (!(ast_format_cap_iscompatible(ast_channel_nativeformats(c), &frame->subclass.format))) {
 			char tmp[256];
 			ast_log(LOG_WARNING, "Asked to transmit frame type '%s', while native formats is '%s' (read/write = %s/%s)\n",
-				ast_getformatname(&frame->subclass.format), ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)), ast_getformatname(&c->readformat), ast_getformatname(&c->writeformat));
+				ast_getformatname(&frame->subclass.format),
+				ast_getformatname_multiple(tmp, sizeof(tmp), ast_channel_nativeformats(c)),
+				ast_getformatname(ast_channel_readformat(c)),
+				ast_getformatname(ast_channel_writeformat(c)));
 			return 0;
 		}
 	}
@@ -1061,10 +1064,10 @@
 
 		pvt->nativeformats = ast_format_cap_to_old_bitfield(ast_channel_nativeformats(ch));
 		ast_best_codec(ast_channel_nativeformats(ch), &tmpfmt);
-		ast_format_copy(&ch->writeformat, &tmpfmt);
-		ast_format_copy(&ch->rawwriteformat, &tmpfmt);
-		ast_format_copy(&ch->readformat, &tmpfmt);
-		ast_format_copy(&ch->rawreadformat, &tmpfmt);
+		ast_format_copy(ast_channel_writeformat(ch), &tmpfmt);
+		ast_format_copy(ast_channel_rawwriteformat(ch), &tmpfmt);
+		ast_format_copy(ast_channel_readformat(ch), &tmpfmt);
+		ast_format_copy(ast_channel_rawreadformat(ch), &tmpfmt);
 		if (!pvt->rtp)
 			__oh323_rtp_create(pvt);
 #if 0
@@ -2079,11 +2082,15 @@
 			if (!(ast_format_cap_identical(ast_channel_nativeformats(pvt->owner), pvt_native))) {
 				if (h323debug) {
 					char tmp[256], tmp2[256];
-					ast_debug(1, "Native format changed to '%s' from '%s', read format is %s, write format is %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), pvt_native), ast_getformatname_multiple(tmp2, sizeof(tmp2), ast_channel_nativeformats(pvt->owner)), ast_getformatname(&pvt->owner->readformat), ast_getformatname(&pvt->owner->writeformat));
+					ast_debug(1, "Native format changed to '%s' from '%s', read format is %s, write format is %s\n",
+						ast_getformatname_multiple(tmp, sizeof(tmp), pvt_native),
+						ast_getformatname_multiple(tmp2, sizeof(tmp2), ast_channel_nativeformats(pvt->owner)),
+						ast_getformatname(ast_channel_readformat(pvt->owner)),
+						ast_getformatname(ast_channel_readformat(pvt->owner)));
 				}
 				ast_format_cap_copy(ast_channel_nativeformats(pvt->owner), pvt_native);
-				ast_set_read_format(pvt->owner, &pvt->owner->readformat);
-				ast_set_write_format(pvt->owner, &pvt->owner->writeformat);
+				ast_set_read_format(pvt->owner, ast_channel_readformat(pvt->owner));
+				ast_set_write_format(pvt->owner, ast_channel_writeformat(pvt->owner));
 			}
 			if (pvt->options.progress_audio)
 				ast_queue_control(pvt->owner, AST_CONTROL_PROGRESS);
--- channels/chan_iax2.c
+++ channels/chan_iax2.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394181 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398457 $")
 
 #include <sys/mman.h>
 #include <dirent.h>
@@ -810,7 +810,7 @@
 	/*! Status of knowledge of peer ADSI capability */
 	int peeradsicpe;
 
-	/*! Who we are bridged to */
+	/*! Callno of native bridge peer. (Valid if nonzero) */
 	unsigned short bridgecallno;
 
 	int pingid;			/*!< Transmit PING request */
@@ -1511,12 +1511,11 @@
 #ifdef SCHED_MULTITHREADED
 static int __schedule_action(void (*func)(const void *data), const void *data, const char *funcname)
 {
-	struct iax2_thread *thread = NULL;
+	struct iax2_thread *thread;
 	static time_t lasterror;
-	static time_t t;
+	time_t t;
 
 	thread = find_idle_thread();
-
 	if (thread != NULL) {
 		thread->schedfunc = func;
 		thread->scheddata = data;
@@ -1528,9 +1527,10 @@
 		return 0;
 	}
 	time(&t);
-	if (t != lasterror)
-		ast_debug(1, "Out of idle IAX2 threads for scheduling!\n");
-	lasterror = t;
+	if (t != lasterror) {
+		lasterror = t;
+		ast_debug(1, "Out of idle IAX2 threads for scheduling! (%s)\n", funcname);
+	}
 
 	return -1;
 }
@@ -3534,42 +3534,49 @@
 	struct iax_frame *f = (struct iax_frame *)data;
 	int freeme = 0;
 	int callno = f->callno;
+
 	/* Make sure this call is still active */
 	if (callno) 
 		ast_mutex_lock(&iaxsl[callno]);
 	if (callno && iaxs[callno]) {
-		if ((f->retries < 0) /* Already ACK'd */ ||
-		    (f->retries >= max_retries) /* Too many attempts */) {
-				/* Record an error if we've transmitted too many times */
-				if (f->retries >= max_retries) {
-					if (f->transfer) {
-						/* Transfer timeout */
-						send_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);
-					} else if (f->final) {
-						iax2_destroy(callno);
-					} else {
-						if (iaxs[callno]->owner)
-							ast_log(LOG_WARNING, "Max retries exceeded to host %s on %s (type = %d, subclass = %u, ts=%d, seqno=%d)\n", ast_inet_ntoa(iaxs[f->callno]->addr.sin_addr),ast_channel_name(iaxs[f->callno]->owner), f->af.frametype, f->af.subclass.integer, f->ts, f->oseqno);
-						iaxs[callno]->error = ETIMEDOUT;
-						if (iaxs[callno]->owner) {
-							struct ast_frame fr = { AST_FRAME_CONTROL, { AST_CONTROL_HANGUP }, .data.uint32 = AST_CAUSE_DESTINATION_OUT_OF_ORDER };
-							/* Hangup the fd */
-							iax2_queue_frame(callno, &fr); /* XXX */
-							/* Remember, owner could disappear */
-							if (iaxs[callno] && iaxs[callno]->owner)
-								ast_channel_hangupcause_set(iaxs[callno]->owner, AST_CAUSE_DESTINATION_OUT_OF_ORDER);
-						} else {
-							if (iaxs[callno]->reg) {
-								memset(&iaxs[callno]->reg->us, 0, sizeof(iaxs[callno]->reg->us));
-								iaxs[callno]->reg->regstate = REG_STATE_TIMEOUT;
-								iaxs[callno]->reg->refresh = IAX_DEFAULT_REG_EXPIRE;
-							}
-							iax2_destroy(callno);
-						}
+		if (f->retries < 0) {
+			/* Already ACK'd */
+			freeme = 1;
+		} else if (f->retries >= max_retries) {
+			/* Too many attempts.  Record an error. */
+			if (f->transfer) {
+				/* Transfer timeout */
+				send_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);
+			} else if (f->final) {
+				iax2_destroy(callno);
+			} else {
+				if (iaxs[callno]->owner) {
+					ast_log(LOG_WARNING, "Max retries exceeded to host %s on %s (type = %d, subclass = %u, ts=%d, seqno=%d)\n",
+						ast_inet_ntoa(iaxs[f->callno]->addr.sin_addr),
+						ast_channel_name(iaxs[f->callno]->owner),
+						f->af.frametype,
+						f->af.subclass.integer,
+						f->ts,
+						f->oseqno);
+				}
+				iaxs[callno]->error = ETIMEDOUT;
+				if (iaxs[callno]->owner) {
+					struct ast_frame fr = { AST_FRAME_CONTROL, { AST_CONTROL_HANGUP }, .data.uint32 = AST_CAUSE_DESTINATION_OUT_OF_ORDER };
+					/* Hangup the fd */
+					iax2_queue_frame(callno, &fr); /* XXX */
+					/* Remember, owner could disappear */
+					if (iaxs[callno] && iaxs[callno]->owner)
+						ast_channel_hangupcause_set(iaxs[callno]->owner, AST_CAUSE_DESTINATION_OUT_OF_ORDER);
+				} else {
+					if (iaxs[callno]->reg) {
+						memset(&iaxs[callno]->reg->us, 0, sizeof(iaxs[callno]->reg->us));
+						iaxs[callno]->reg->regstate = REG_STATE_TIMEOUT;
+						iaxs[callno]->reg->refresh = IAX_DEFAULT_REG_EXPIRE;
 					}
-
+					iax2_destroy(callno);
 				}
-				freeme = 1;
+			}
+			freeme = 1;
 		} else {
 			/* Update it if it needs it */
 			update_packet(f);
@@ -8738,8 +8745,6 @@
 	return 0;
 }
 
-static int iax2_poke_peer(struct iax2_peer *peer, int heldcall);
-
 static void reg_source_db(struct iax2_peer *p)
 {
 	char data[80];
@@ -9701,9 +9706,10 @@
 
 	if (!(thread = find_idle_thread())) {
 		time(&t);
-		if (t != last_errtime)
+		if (t != last_errtime) {
+			last_errtime = t;
 			ast_debug(1, "Out of idle IAX2 threads for I/O, pausing!\n");
-		last_errtime = t;
+		}
 		usleep(1);
 		return 1;
 	}
@@ -10243,6 +10249,7 @@
 		data_size += strlen(subclass);
 
 		cause_code = ast_alloca(data_size);
+		memset(cause_code, 0, data_size);
 		ast_copy_string(cause_code->chan_name, ast_channel_name(iaxs[fr->callno]->owner), AST_CHANNEL_NAME);
 
 		cause_code->ast_cause = ies.causecode;
@@ -11509,13 +11516,13 @@
 				}
 				break;
 			case IAX_COMMAND_TXREJ:
-				if (iaxs[fr->callno]->bridgecallno) {
-					while (ast_mutex_trylock(&iaxsl[iaxs[fr->callno]->bridgecallno])) {
-						DEADLOCK_AVOIDANCE(&iaxsl[fr->callno]);
-					}
-					if (!iaxs[fr->callno]) {
-						break;
-					}
+				while (iaxs[fr->callno]
+					&& iaxs[fr->callno]->bridgecallno
+					&& ast_mutex_trylock(&iaxsl[iaxs[fr->callno]->bridgecallno])) {
+					DEADLOCK_AVOIDANCE(&iaxsl[fr->callno]);
+				}
+				if (!iaxs[fr->callno]) {
+					break;
 				}
 
 				iaxs[fr->callno]->transferring = TRANSFER_NONE;
@@ -11526,20 +11533,21 @@
 					break;
 				}
 
-				if (iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {
+				if (iaxs[iaxs[fr->callno]->bridgecallno]
+					&& iaxs[iaxs[fr->callno]->bridgecallno]->transferring) {
 					iaxs[iaxs[fr->callno]->bridgecallno]->transferring = TRANSFER_NONE;
 					send_command(iaxs[iaxs[fr->callno]->bridgecallno], AST_FRAME_IAX, IAX_COMMAND_TXREJ, 0, NULL, 0, -1);
 				}
 				ast_mutex_unlock(&iaxsl[iaxs[fr->callno]->bridgecallno]);
 				break;
 			case IAX_COMMAND_TXREADY:
-				if (iaxs[fr->callno]->bridgecallno) {
-					while (ast_mutex_trylock(&iaxsl[iaxs[fr->callno]->bridgecallno])) {
-						DEADLOCK_AVOIDANCE(&iaxsl[fr->callno]);
-					}
-					if (!iaxs[fr->callno]) {
-						break;
-					}
+				while (iaxs[fr->callno]
+					&& iaxs[fr->callno]->bridgecallno
+					&& ast_mutex_trylock(&iaxsl[iaxs[fr->callno]->bridgecallno])) {
+					DEADLOCK_AVOIDANCE(&iaxsl[fr->callno]);
+				}
+				if (!iaxs[fr->callno]) {
+					break;
 				}
 
 				if (iaxs[fr->callno]->transferring == TRANSFER_BEGIN) {
@@ -11558,8 +11566,9 @@
 					break;
 				}
 
-				if (!(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_READY) &&
-				    !(iaxs[iaxs[fr->callno]->bridgecallno]->transferring == TRANSFER_MREADY)) {
+				if (!iaxs[iaxs[fr->callno]->bridgecallno]
+					|| (iaxs[iaxs[fr->callno]->bridgecallno]->transferring != TRANSFER_READY
+						&& iaxs[iaxs[fr->callno]->bridgecallno]->transferring != TRANSFER_MREADY)) {
 					ast_mutex_unlock(&iaxsl[iaxs[fr->callno]->bridgecallno]);
 					break;
 				}
@@ -11686,12 +11695,13 @@
 
 			/* Don't actually pass these frames along */
 			if ((f.subclass.integer != IAX_COMMAND_ACK) &&
-			  (f.subclass.integer != IAX_COMMAND_TXCNT) &&
-			  (f.subclass.integer != IAX_COMMAND_TXACC) &&
-			  (f.subclass.integer != IAX_COMMAND_INVAL) &&
-			  (f.subclass.integer != IAX_COMMAND_VNAK)) {
-				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno)
+				(f.subclass.integer != IAX_COMMAND_TXCNT) &&
+				(f.subclass.integer != IAX_COMMAND_TXACC) &&
+				(f.subclass.integer != IAX_COMMAND_INVAL) &&
+				(f.subclass.integer != IAX_COMMAND_VNAK)) {
+				if (iaxs[fr->callno] && iaxs[fr->callno]->aseqno != iaxs[fr->callno]->iseqno) {
 					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
+				}
 			}
 			ast_mutex_unlock(&iaxsl[fr->callno]);
 			return 1;
@@ -11813,8 +11823,9 @@
 		/*iaxs[fr->callno]->last = fr->ts; (do it afterwards cos schedule/forward_delivery needs the last ts too)*/
 		fr->outoforder = 0;
 	} else {
-		if (iaxdebug && iaxs[fr->callno])
+		if (iaxdebug && iaxs[fr->callno]) {
 			ast_debug(1, "Received out of order packet... (type=%d, subclass %d, ts = %d, last = %d)\n", f.frametype, f.subclass.integer, fr->ts, iaxs[fr->callno]->last);
+		}
 		fr->outoforder = -1;
 	}
 	fr->cacheable = ((f.frametype == AST_FRAME_VOICE) || (f.frametype == AST_FRAME_VIDEO));
@@ -11943,11 +11954,10 @@
 			break;
 		}
 
-		if (thread->iostate == IAX_IOSTATE_IDLE)
-			continue;
-
 		/* See what we need to do */
 		switch (thread->iostate) {
+		case IAX_IOSTATE_IDLE:
+			continue;
 		case IAX_IOSTATE_READY:
 			thread->actions++;
 			thread->iostate = IAX_IOSTATE_PROCESSING;
@@ -11960,14 +11970,10 @@
 #ifdef SCHED_MULTITHREADED
 			thread->schedfunc(thread->scheddata);
 #endif		
+			break;
 		default:
 			break;
 		}
-		time(&thread->checktime);
-		thread->iostate = IAX_IOSTATE_IDLE;
-#ifdef DEBUG_SCHED_MULTITHREAD
-		thread->curfunc[0]='\0';
-#endif		
 
 		/* The network thread added us to the active_thread list when we were given
 		 * frames to process, Now that we are done, we must remove ourselves from
@@ -11978,12 +11984,18 @@
 
 		/* Make sure another frame didn't sneak in there after we thought we were done. */
 		handle_deferred_full_frames(thread);
+
+		time(&thread->checktime);
+		thread->iostate = IAX_IOSTATE_IDLE;
+#ifdef DEBUG_SCHED_MULTITHREAD
+		thread->curfunc[0]='\0';
+#endif
 	}
 
 	/*!
-	 * \note For some reason, idle threads are exiting without being removed
-	 * from an idle list, which is causing memory corruption.  Forcibly remove
-	 * it from the list, if it's there.
+	 * \note For some reason, idle threads are exiting without being
+	 * removed from an idle list, which is causing memory
+	 * corruption.  Forcibly remove it from the list, if it's there.
 	 */
 	AST_LIST_LOCK(&idle_list);
 	AST_LIST_REMOVE(&idle_list, thread, list);
@@ -14276,7 +14288,7 @@
 		return res;
 
 	res = AST_DEVICE_UNAVAILABLE;
-	ast_debug(3, "iax2_devicestate: Found peer. What's device state of %s? addr=%d, defaddr=%d maxms=%d, lastms=%d\n",
+	ast_debug(3, "Found peer. What's device state of %s? addr=%d, defaddr=%d maxms=%d, lastms=%d\n",
 		pds.peer, ast_sockaddr_ipv4(&p->addr), p->defaddr.sin_addr.s_addr, p->maxms, p->lastms);
 
 	if ((ast_sockaddr_ipv4(&p->addr) || p->defaddr.sin_addr.s_addr) &&
@@ -14565,7 +14577,7 @@
 	struct iax2_thread *thread;
 
 	AST_LIST_LOCK(list_head);
-	while ((thread = AST_LIST_REMOVE_HEAD(&idle_list, list))) {
+	while ((thread = AST_LIST_REMOVE_HEAD(list_head, list))) {
 		pthread_t thread_id = thread->threadid;
 
 		thread->stop = 1;
@@ -14608,9 +14620,9 @@
 	}
 
 	/* Call for all threads to halt */
-	cleanup_thread_list(&idle_list);
 	cleanup_thread_list(&active_list);
 	cleanup_thread_list(&dynamic_list);
+	cleanup_thread_list(&idle_list);
 
 	ast_netsock_release(netsock);
 	ast_netsock_release(outsock);
--- channels/chan_misdn.c
+++ channels/chan_misdn.c
@@ -58,7 +58,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 379230 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398236 $")
 
 #include <pthread.h>
 #include <sys/socket.h>
@@ -10203,7 +10203,7 @@
 			struct ast_format_cap *cap = ast_format_cap_alloc_nolock();
 			struct ast_format tmpfmt;
 			if (!(cap)) {
-				return RESPONSE_ERR; 
+				return RESPONSE_ERR;
 			}
 			ast_format_cap_add(cap, ast_format_set(&tmpfmt, AST_FORMAT_ALAW, 0));
 			chan = misdn_new(ch, AST_STATE_RESERVED, bc->dialed.number, bc->caller.number, cap, NULL, bc->port, bc->channel);
@@ -11232,7 +11232,7 @@
 static int unload_module(void)
 {
 	/* First, take us out of the channel loop */
-	ast_log(LOG_VERBOSE, "-- Unregistering mISDN Channel Driver --\n");
+	ast_verb(0, "-- Unregistering mISDN Channel Driver --\n");
 
 	misdn_tasks_destroy();
 
@@ -12762,8 +12762,7 @@
 	} else if (misdn_debug_only[port]
 		? (level == 1 && misdn_debug[port]) || level == misdn_debug[port]
 		: level <= misdn_debug[port]) {
-		ast_console_puts(port_buf);
-		ast_console_puts(buf);
+		ast_verbose("%s%s", port_buf, buf);
 	}
 
 	if (level <= misdn_debug[0] && !ast_strlen_zero(global_tracefile)) {
@@ -12775,12 +12774,7 @@
 
 		fp = fopen(global_tracefile, "a+");
 		if (!fp) {
-			ast_console_puts("Error opening Tracefile: [ ");
-			ast_console_puts(global_tracefile);
-			ast_console_puts(" ] ");
-
-			ast_console_puts(strerror(errno));
-			ast_console_puts("\n");
+			ast_verbose("Error opening Tracefile: [ %s ] %s\n", global_tracefile, strerror(errno));
 			return;
 		}
 
--- channels/chan_motif.c
+++ channels/chan_motif.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377462 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397744 $")
 
 #include <sys/socket.h>
 #include <fcntl.h>
@@ -2373,7 +2373,8 @@
 
 		/* Size of the string making up the cause code is "Motif " + text */
 		data_size += 6 + strlen(iks_name(text));
-		cause_code = ast_malloc(data_size);
+		cause_code = ast_alloca(data_size);
+		memset(cause_code, 0, data_size);
 
 		/* Get the appropriate cause code mapping for this reason */
 		for (i = 0; i < ARRAY_LEN(jingle_reason_mappings); i++) {
@@ -2387,7 +2388,8 @@
 		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "Motif %s", iks_name(text));
 	} else {
 		/* No technology specific information is available */
-		cause_code = ast_malloc(data_size);
+		cause_code = ast_alloca(data_size);
+		memset(cause_code, 0, data_size);
 	}
 
 	ast_copy_string(cause_code->chan_name, ast_channel_name(chan), AST_CHANNEL_NAME);
@@ -2395,8 +2397,6 @@
 	ast_queue_control_data(chan, AST_CONTROL_PVT_CAUSE_CODE, cause_code, data_size);
 	ast_channel_hangupcause_hash_set(chan, cause_code, data_size);
 
-	ast_free(cause_code);
-
 	ast_debug(3, "Hanging up channel '%s' due to session terminate message with cause '%d'\n", ast_channel_name(chan), cause);
 	ast_queue_hangup_with_cause(chan, cause);
 	session->gone = 1;
@@ -2555,9 +2555,9 @@
 	aco_option_register_custom(&cfg_info, "connection", ACO_EXACT, endpoint_options, NULL, custom_connection_handler, 0);
 	aco_option_register_custom(&cfg_info, "transport", ACO_EXACT, endpoint_options, NULL, custom_transport_handler, 0);
 	aco_option_register(&cfg_info, "maxicecandidates", ACO_EXACT, endpoint_options, DEFAULT_MAX_ICE_CANDIDATES, OPT_UINT_T, PARSE_DEFAULT,
-			    FLDSET(struct jingle_endpoint, maxicecandidates));
+			    FLDSET(struct jingle_endpoint, maxicecandidates), DEFAULT_MAX_ICE_CANDIDATES);
 	aco_option_register(&cfg_info, "maxpayloads", ACO_EXACT, endpoint_options, DEFAULT_MAX_PAYLOADS, OPT_UINT_T, PARSE_DEFAULT,
-			    FLDSET(struct jingle_endpoint, maxpayloads));
+			    FLDSET(struct jingle_endpoint, maxpayloads), DEFAULT_MAX_PAYLOADS);
 
 	ast_format_cap_add_all_by_type(jingle_tech.capabilities, AST_FORMAT_TYPE_AUDIO);
 
@@ -2608,6 +2608,8 @@
 static int unload_module(void)
 {
 	ast_channel_unregister(&jingle_tech);
+	ast_format_cap_destroy(jingle_tech.capabilities);
+	jingle_tech.capabilities = NULL;
 	ast_rtp_glue_unregister(&jingle_rtp_glue);
 	ast_sched_context_destroy(sched);
 	aco_info_destroy(&cfg_info);
--- channels/chan_sip.c
+++ channels/chan_sip.c
@@ -210,7 +210,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397828 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $")
 
 #include <signal.h>
 #include <sys/signal.h>
@@ -15159,6 +15159,8 @@
 			append_history(p, "RegistryInit", "Account: %s@%s", r->username, r->hostname);
 		}
 
+		p->socket.type = r->transport;
+
 		/* Use port number specified if no SRV record was found */
 		if (!ast_sockaddr_isnull(&r->us)) {
 			if (!ast_sockaddr_port(&r->us) && r->portno) {
@@ -16020,7 +16022,7 @@
 	if (ast_apply_acl(sip_cfg.contact_acl, &peer->addr, "SIP contact ACL: ") != AST_SENSE_ALLOW ||
 			ast_apply_acl(peer->contactacl, &peer->addr, "SIP contact ACL: ") != AST_SENSE_ALLOW) {
 		ast_log(LOG_WARNING, "Domain '%s' disallowed by contact ACL (violating IP %s)\n", hostport,
-			ast_sockaddr_stringify_addr(&testsa));
+				ast_sockaddr_stringify_addr(&peer->addr));
 		ast_string_field_set(peer, fullcontact, "");
 		ast_string_field_set(pvt, our_contact, "");
 		return PARSE_REGISTER_DENIED;
@@ -18558,7 +18560,24 @@
 		ast_string_field_set(p, context, sip_cfg.messagecontext);
 	}
 
-	get_destination(p, NULL, NULL);
+	switch (get_destination(p, NULL, NULL)) {
+	case SIP_GET_DEST_REFUSED:
+		/* Okay to send 403 since this is after auth processing */
+		transmit_response(p, "403 Forbidden", req);
+		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
+		return;
+	case SIP_GET_DEST_INVALID_URI:
+		transmit_response(p, "416 Unsupported URI Scheme", req);
+		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
+		return;
+	case SIP_GET_DEST_EXTEN_NOT_FOUND:
+	case SIP_GET_DEST_EXTEN_MATCHMORE:
+		transmit_response(p, "404 Not Found", req);
+		sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
+		return;
+	case SIP_GET_DEST_EXTEN_FOUND:
+		break;
+	}
 
 	if (!(msg = ast_msg_alloc())) {
 		transmit_response(p, "500 Internal Server Error", req);
@@ -23013,8 +23032,8 @@
 					wait = ast_random() % 2000;
 				}
 				p->waitid = ast_sched_add(sched, wait, sip_reinvite_retry, dialog_ref(p, "passing dialog ptr into sched structure based on waitid for sip_reinvite_retry."));
-				ast_log(LOG_WARNING, "just did sched_add waitid(%d) for sip_reinvite_retry for dialog %s in handle_response_invite\n", p->waitid, p->callid);
-				ast_debug(2, "Reinvite race. Waiting %d secs before retry\n", wait);
+				ast_debug(2, "Reinvite race. Scheduled sip_reinvite_retry in %d secs in handle_response_invite (waitid %d, dialog '%s')\n",
+						wait, p->waitid, p->callid);
 			}
 		}
 		break;
@@ -26830,6 +26849,21 @@
 
 			sender = ast_strdupa(from);
 			ast_callerid_parse(sender, &name, &location);
+			if (ast_strlen_zero(location)) {
+				/* This can occur if either
+				 *  1) A name-addr style From header does not close the angle brackets
+				 *  properly.
+				 *  2) The From header is not in name-addr style and the content of the
+				 *  From contains characters other than 0-9, *, #, or +.
+				 *
+				 *  In both cases, ast_callerid_parse() should have parsed the From header
+				 *  as a name rather than a number. So we just need to set the location
+				 *  to what was parsed as a name, and set the name NULL since there was
+				 *  no name present.
+				 */
+				location = name;
+				name = NULL;
+			}
 			ast_string_field_set(pvt, fromname, name);
 			if (strchr(location, ':')) { /* Must be a URI */
 				parse_uri(location, "sip:,sips:", &user, NULL, &domain, NULL);
@@ -28035,6 +28069,7 @@
 				/* size of the string making up the cause code is "SIP " + cause length */
 				data_size += 4 + strlen(REQ_OFFSET_TO_STR(req, rlpart2));
 				cause_code = ast_alloca(data_size);
+				memset(cause_code, 0, data_size);
 
 				ast_copy_string(cause_code->chan_name, ast_channel_name(p->owner), AST_CHANNEL_NAME);
 
@@ -28349,9 +28384,7 @@
 
 	copy_socket_data(&p->socket, &req->socket);
 
-	if (ast_sockaddr_isnull(&p->recv)) { /* This may already be set before getting here */
-		ast_sockaddr_copy(&p->recv, addr);
-	}
+	ast_sockaddr_copy(&p->recv, addr);
 
 	/* if we have an owner, then this request has been authenticated */
 	if (p->owner) {
@@ -34684,7 +34717,12 @@
 
 	clear_sip_domains();
 	sip_cfg.contact_acl = ast_free_acl_list(sip_cfg.contact_acl);
+	if (sipsock_read_id) {
+		ast_io_remove(io, sipsock_read_id);
+		sipsock_read_id = NULL;
+	}
 	close(sipsock);
+	io_context_destroy(io);
 	ast_sched_context_destroy(sched);
 	con = ast_context_find(used_context);
 	if (con) {
@@ -34698,6 +34736,11 @@
 	sip_reqresp_parser_exit();
 	sip_unregister_tests();
 
+	if (notify_types) {
+		ast_config_destroy(notify_types);
+		notify_types = NULL;
+	}
+
 	ast_format_cap_destroy(sip_tech.capabilities);
 	sip_cfg.caps = ast_format_cap_destroy(sip_cfg.caps);
 
--- channels/chan_unistim.c
+++ channels/chan_unistim.c
@@ -38,7 +38,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 389661 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396377 $")
 
 #include <sys/stat.h>
 #include <signal.h>
@@ -2903,7 +2903,11 @@
 			send_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext("Enter the number to dial", pte));
 			send_text(TEXT_LINE1, TEXT_NORMAL, pte, ustmtext("and press Call", pte));
 		}
-		send_text_status(pte, ustmtext("Call   Redial BackSp Erase", pte));
+		if (ast_strlen_zero(pte->device->redial_number)) {
+			send_text_status(pte, ustmtext("Call          BackSp Erase", pte));
+		} else {
+			send_text_status(pte, ustmtext("Call   Redial BackSp Erase", pte));
+		}
 	}
 
 	pte->device->size_phone_number = 0;
@@ -3298,6 +3302,8 @@
 static void key_call(struct unistimsession *pte, char keycode)
 {
 	struct unistim_subchannel *sub = get_sub(pte->device, SUB_REAL);
+	struct unistim_subchannel *sub_3way = get_sub(pte->device, SUB_THREEWAY);
+
 	if ((keycode >= KEY_0) && (keycode <= KEY_SHARP)) {
 		if (keycode == KEY_SHARP) {
 			keycode = '#';
@@ -3312,23 +3318,21 @@
 	switch (keycode) {
 	case KEY_FUNC1:
 		if (ast_channel_state(sub->owner) == AST_STATE_UP) {
-			if (get_sub(pte->device, SUB_THREEWAY)) {
+			if (sub_3way) {
 				close_call(pte);
 			}
 		}
 		break;
 	case KEY_FUNC2:
-		if (ast_channel_state(sub->owner) == AST_STATE_UP) {
-			if (get_sub(pte->device, SUB_THREEWAY)) {
-				transfer_cancel_step2(pte);
-			} else {
-				transfer_call_step1(pte);
-			}
+		if (sub_3way) {
+			transfer_cancel_step2(pte);
+		} else if (ast_channel_state(sub->owner) == AST_STATE_UP) {
+			transfer_call_step1(pte);
 		}
 		break;
 	case KEY_HANGUP:
 	case KEY_FUNC4:
-		if (!get_sub(pte->device, SUB_THREEWAY)) {
+		if (!sub_3way) {
 			close_call(pte);
 		}
 		break;
@@ -4010,13 +4014,24 @@
 			send_text(TEXT_LINE1, TEXT_NORMAL, pte, pte->device->call_forward);
 		}
 		send_icon(TEXT_LINE0, FAV_ICON_REFLECT + FAV_BLINK_SLOW, pte);
-		send_text_status(pte, ustmtext("Dial   Redial NoFwd  ", pte));
+		if (ast_strlen_zero(pte->device->redial_number)) {
+			send_text_status(pte, ustmtext("Dial          NoFwd  ", pte));
+		} else {
+			send_text_status(pte, ustmtext("Dial   Redial NoFwd  ", pte));
+		}
 	} else {
-		if ((pte->device->extension == EXTENSION_ASK) ||
-			(pte->device->extension == EXTENSION_TN)) {
-			send_text_status(pte, ustmtext("Dial   Redial Fwd    Unregis", pte));
+		if ((pte->device->extension == EXTENSION_ASK) || (pte->device->extension == EXTENSION_TN)) {
+			if (ast_strlen_zero(pte->device->redial_number)) {
+				send_text_status(pte, ustmtext("Dial          Fwd    Unregis", pte));
+			} else {
+				send_text_status(pte, ustmtext("Dial   Redial Fwd    Unregis", pte));
+			}
 		} else {
-			send_text_status(pte, ustmtext("Dial   Redial Fwd    Pickup", pte));
+			if (ast_strlen_zero(pte->device->redial_number)) {
+				send_text_status(pte, ustmtext("Dial          Fwd    Pickup", pte));
+			} else {
+				send_text_status(pte, ustmtext("Dial   Redial Fwd    Pickup", pte));
+			}
 		}
 		send_text(TEXT_LINE1, TEXT_NORMAL, pte, pte->device->maintext1);
 		if (pte->device->missed_call == 0) {
@@ -4777,7 +4792,7 @@
 	struct unistim_line *l;
 	struct unistim_device *d;
 	struct unistimsession *s;
-	int i;
+	int i,end_call = 1;
 
 	s = channel_to_session(ast);
 	sub = ast_channel_tech_pvt(ast);
@@ -4792,8 +4807,8 @@
 		ast_verb(0, "unistim_hangup(%s) on %s@%s (STATE_%s)\n", ast_channel_name(ast), l->name, l->parent->name, ptestate_tostr(s->state));
 	}
 	sub_trans = get_sub(d, SUB_THREEWAY);
-	if (sub_trans && (sub_trans->owner) && (sub->subtype == SUB_REAL) &&
-		(sub->alreadygone == 0)) {
+	sub_real = get_sub(d, SUB_REAL);
+	if (sub_trans && (sub_trans->owner) && (sub->subtype == SUB_REAL)) { /* 3rd party busy or congested and transfer_cancel_step2 does not called */
 		if (unistimdebug) {
 			ast_verb(0, "Threeway call disconnected, switching to real call\n");
 		}
@@ -4803,16 +4818,13 @@
 		sub_trans->moh = 0;
 		sub_trans->subtype = SUB_REAL;
 		swap_subs(sub_trans, sub);
-
 		send_text_status(s, ustmtext("       Transf        Hangup", s));
 		send_callerid_screen(s, sub_trans);
 		unistim_hangup_clean(ast, sub);
 		unistim_unalloc_sub(d, sub);
 		return 0;
 	}
-	sub_real = get_sub(d, SUB_REAL);
-	if (sub_real && (sub_real->owner) && (sub->subtype == SUB_THREEWAY) &&
-		(sub->alreadygone == 0)) {
+	if (sub_real && (sub_real->owner) && (sub->subtype == SUB_THREEWAY)) { /* 3way call cancelled by softkey pressed */
 		if (unistimdebug) {
 			ast_verb(0, "Real call disconnected, stay in call\n");
 		}
@@ -4822,10 +4834,8 @@
 		unistim_unalloc_sub(d, sub);
 		return 0;
 	}
-
 	if (sub->subtype == SUB_REAL) {
 		sub_stop_silence(s, sub);
-		send_end_call(s); /* Send end call packet only if ending active call, in other way sound should be loosed */
 	} else if (sub->subtype == SUB_RING) {
 		send_no_ring(s);
 		for (i = 0; i < FAVNUM; i++) {
@@ -4836,9 +4846,16 @@
 			if (is_key_line(d, i) && !strcmp(l->name, d->sline[i]->name)) {
 				send_favorite_short(i, FAV_LINE_ICON, s);
 				d->ssub[i] = NULL;
+				continue;
+			}
+			if (d->ssub[i] != NULL) { /* Found other subchannel active other then hangup'ed one */
+				end_call = 0;
 			}
 		}
 	}
+	if (end_call) {
+		send_end_call(s); /* Send end call packet only if ending active call, in other way sound should be loosed */
+	}
 	sub->moh = 0;
 	if (sub->softkey >= 0) {
 		send_favorite_short(sub->softkey, FAV_LINE_ICON, s);
@@ -6132,7 +6149,7 @@
 			return 0;
 		}
 		if (d->softkeyicon[p] != 0) {
-			ast_log(LOG_WARNING, "Invalid position %d for bookmark : already used\n:", p);
+			ast_log(LOG_WARNING, "Invalid position %d for bookmark : already used:\n", p);
 			return 0;
 		}
 		memmove(line, line + 2, sizeof(line) - 2);
--- channels/iax2-parser.c
+++ channels/iax2-parser.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 369013 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398305 $")
 
 #include <sys/socket.h>
 #include <netinet/in.h>
@@ -239,11 +239,12 @@
 	dump_prov_ies(output, maxlen, value, len);
 }
 
-static struct iax2_ie {
+struct iax2_ie {
 	int ie;
 	char *name;
 	void (*dump)(char *output, int maxlen, void *value, int len);
-} infoelts[] = {
+};
+static struct iax2_ie infoelts[] = {
 	{ IAX_IE_CALLED_NUMBER, "CALLED NUMBER", dump_string },
 	{ IAX_IE_CALLING_NUMBER, "CALLING NUMBER", dump_string },
 	{ IAX_IE_CALLING_ANI, "ANI", dump_string },
@@ -392,6 +393,7 @@
 	int found;
 	char interp[1024];
 	char tmp[1024];
+
 	if (len < 2)
 		return;
 	while(len > 2) {
@@ -604,6 +606,16 @@
 		"TXFER  ",
 		"CNLINE ",
 		"REDIR  ",
+		"T38PARM",
+		"CC ERR!",/* This must never go across an IAX link. */
+		"SRCCHG ",
+		"READACT",
+		"AOC    ",
+		"ENDOFQ ",
+		"INCOMPL",
+		"MCID   ",
+		"UPDRTPP",
+		"PCAUSEC",
 	};
 	struct ast_iax2_full_hdr *fh;
 	char retries[20];
--- channels/sig_analog.c
+++ channels/sig_analog.c
@@ -2734,6 +2734,7 @@
 		subclass = analog_event2str(res);
 		data_size += strlen(subclass);
 		cause_code = ast_alloca(data_size);
+		memset(cause_code, 0, data_size);
 		cause_code->ast_cause = AST_CAUSE_NORMAL_CLEARING;
 		ast_copy_string(cause_code->chan_name, ast_channel_name(ast), AST_CHANNEL_NAME);
 		snprintf(cause_code->code, data_size - sizeof(*cause_code) + 1, "ANALOG %s", subclass);
--- channels/sig_pri.c
+++ channels/sig_pri.c
@@ -1296,6 +1296,7 @@
 	if (chan) {
 		int datalen = sizeof(*cause_code) + strlen(cause);
 		cause_code = ast_alloca(datalen);
+		memset(cause_code, 0, datalen);
 		cause_code->ast_cause = ast_cause;
 		ast_copy_string(cause_code->chan_name, ast_channel_name(chan), AST_CHANNEL_NAME);
 		ast_copy_string(cause_code->code, cause, datalen + 1 - sizeof(*cause_code));
@@ -9286,7 +9287,7 @@
 			info_str = pri_dump_info_str(pri->pri);
 			if (info_str) {
 				ast_cli(fd, "%s", info_str);
-				free(info_str);
+				ast_std_free(info_str);
 			}
 #else
 			pri_dump_info(pri->pri);
--- channels/sig_ss7.c
+++ channels/sig_ss7.c
@@ -411,6 +411,7 @@
 	int datalen = sizeof(*cause_code) + strlen(cause);
 
 	cause_code = ast_alloca(datalen);
+	memset(cause_code, 0, datalen);
 	cause_code->ast_cause = ast_cause;
 	ast_copy_string(cause_code->chan_name, ast_channel_name(owner), AST_CHANNEL_NAME);
 	ast_copy_string(cause_code->code, cause, datalen + 1 - sizeof(*cause_code));
--- channels/sip/dialplan_functions.c
+++ channels/sip/dialplan_functions.c
@@ -25,7 +25,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 369013 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397133 $")
 
 #include <math.h>
 
@@ -353,7 +353,7 @@
 		goto done;
 	}
 	ast_channel_tech_set(chan, &sip_tech);
-	ast_channel_tech_pvt_set(chan, p);
+	ast_channel_tech_pvt_set(chan, dialog_ref(p, "Give the owner channel a reference to the dialog"));
 	p->owner = chan;
 
 	varstr = ast_str_create(16);
@@ -397,8 +397,9 @@
 	ast_free(varstr);
 	ast_free(buffer);
 
-	/* This unref will take care of destroying the channel, RTP instance, and SIP pvt */
+	/* This unlink and unref will take care of destroying the channel, RTP instance, and SIP pvt */
 	if (p) {
+		dialog_unlink_all(p);
 		dialog_unref(p, "Destroy test object");
 	}
 	ast_rtp_engine_unregister(&test_engine);
--- configs/h323.conf.sample
+++ configs/h323.conf.sample
@@ -29,6 +29,8 @@
 ;allow=gsm		; Always allow GSM, it's cool :)
 ;allow=ulaw		; see https://wiki.asterisk.org/wiki/display/AST/RTP+Packetization
 			; for framing options
+;autoframing=yes	; Set packetization based on the remote endpoint's (ptime)
+			; preferences. Defaults to no.
 ;
 ; User-Input Mode (DTMF)
 ;
--- configs/iax.conf.sample
+++ configs/iax.conf.sample
@@ -607,6 +607,15 @@
 ; IPs can also optionally be given but are not required.  Caller*ID can be
 ; suggested to the other side as well if it is for example a phone instead of
 ; another PBX.
+;connectedline=yes ; Set how connected line information is handled for this
+;                  ; peer. If set to "yes", both sending and receiving
+;                  ; connected line information will be enabled. If set to
+;                  ; "send", this peer will send connected line information
+;                  ; but will not process connected line updates. If set to
+;                  ; "receive", connected line updates will be processed
+;                  ; but not sent. If set to "no", connected line updates
+;                  ; will be disabled. Default is "no".
+
 
 ;[dynamichost]
 ;host=dynamic
--- configs/indications.conf.sample
+++ configs/indications.conf.sample
@@ -434,7 +434,7 @@
 ringcadence = 2000,4000
 dial = 425
 busy = 425/500,0/500
-ring = 425/400,0/200
+ring = 425/400,0/200,425/400,0/2000
 congestion = 425/500,0/500
 
 [nl]
--- configs/sip.conf.sample
+++ configs/sip.conf.sample
@@ -310,6 +310,8 @@
 ;allow=ulaw                     ; Allow codecs in order of preference
 ;allow=ilbc                     ; see https://wiki.asterisk.org/wiki/display/AST/RTP+Packetization
 				; for framing options
+;autoframing=yes		; Set packetization based on the remote endpoint's (ptime)
+				; preferences. Defaults to no.
 ;
 ; This option specifies a preference for which music on hold class this channel
 ; should listen to when put on hold if the music class has not been set on the
@@ -1192,6 +1194,7 @@
 ; language
 ; allow
 ; disallow
+; autoframing
 ; insecure
 ; trustrpid
 ; progressinband
--- configs/sla.conf.sample
+++ configs/sla.conf.sample
@@ -15,6 +15,17 @@
 ; -------------------------------------
 
 
+; ********************************
+; **** Configuration Ordering ****
+; ********************************
+
+; Note that SLA configuration processing assumes that *all* trunk declarations are
+; listed in the configuration file before any stations.
+
+; ********************************
+; ********************************
+
+
 ; ---- Trunk Declarations -------------
 ;
 ;[line1]                    ; Provide a name for this trunk.
--- contrib/realtime/postgresql/realtime.sql
+++ contrib/realtime/postgresql/realtime.sql
@@ -136,6 +136,23 @@
 PRIMARY KEY (queue_name, interface)
 ) WITHOUT OIDS;
 
+drop table queue_log;
+CREATE TABLE "queue_log" (
+"id" SERIAL,
+"time" TIMESTAMP WITHOUT TIME ZONE DEFAULT now() NOT NULL,
+"callid" character varying(50) NOT NULL,
+"queuename" character varying(50) NOT NULL,
+"agent" character varying(50) NOT NULL,
+"event" character varying(20) NOT NULL,
+"data1" character varying(50) NOT NULL,
+"data2" character varying(50) NOT NULL,
+"data3" character varying(50) NOT NULL,
+"data4" character varying(50) NOT NULL,
+"data5" character varying(50) NOT NULL,
+CONSTRAINT queue_log_pkey PRIMARY KEY (id)
+) WITHOUT OIDS;
+
+GRANT ALL ON TABLE queue_log TO asterisk;
 GRANT ALL ON TABLE cdr TO asterisk;
 GRANT ALL ON TABLE extensions_conf TO asterisk;
 GRANT ALL ON TABLE sip_conf TO asterisk;
--- default.exports
+++ default.exports
@@ -1,4 +1,8 @@
 {
+	global:
+		/* See main/asterisk.exports.in for an explanation why this is
+		 * needed. */
+		_IO_stdin_used;
 	local:
 		*;
 };
--- funcs/func_channel.c
+++ funcs/func_channel.c
@@ -20,7 +20,7 @@
  *
  * \author Kevin P. Fleming <kpfleming@digium.com>
  * \author Ben Winslow
- * 
+ *
  * \ingroup functions
  */
 
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 384641 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 394981 $")
 
 #include <regex.h>
 #include <ctype.h>
@@ -253,16 +253,35 @@
 						<para>     <literal>audio</literal>             Get audio destination</para>
 						<para>     <literal>video</literal>             Get video destination</para>
 						<para>     <literal>text</literal>              Get text destination</para>
+						<para>   Defaults to <literal>audio</literal> if unspecified.</para>
+					</enum>
+					<enum name="rtpsource">
+						<para>R/O Get source RTP destination information.</para>
+						<para>   This option takes one additional argument:</para>
+						<para>    Argument 1:</para>
+						<para>     <literal>audio</literal>             Get audio destination</para>
+						<para>     <literal>video</literal>             Get video destination</para>
+						<para>     <literal>text</literal>              Get text destination</para>
+						<para>   Defaults to <literal>audio</literal> if unspecified.</para>
 					</enum>
 				</enumlist>
 				<para><emphasis>chan_iax2</emphasis> provides the following additional options:</para>
 				<enumlist>
+					<enum name="osptoken">
+						<para>R/O Get the peer's osptoken.</para>
+					</enum>
 					<enum name="peerip">
 						<para>R/O Get the peer's ip address.</para>
 					</enum>
 					<enum name="peername">
 						<para>R/O Get the peer's username.</para>
 					</enum>
+					<enum name="secure_signaling">
+						<para>R/O Get the if the IAX channel is secured.</para>
+					</enum>
+					<enum name="secure_media">
+						<para>R/O Get the if the IAX channel is secured.</para>
+					</enum>
 				</enumlist>
 				<para><emphasis>chan_dahdi</emphasis> provides the following additional options:</para>
 				<enumlist>
@@ -320,17 +339,35 @@
 				<para><emphasis>chan_ooh323</emphasis> provides the following additional options:</para>
 				<enumlist>
 					<enum name="faxdetect">
-						<para>Fax Detect [R/W]</para>
+						<para>R/W Fax Detect</para>
 						<para>Returns 0 or 1</para>
 						<para>Write yes or no</para>
 					</enum>
 					<enum name="t38support">
-						<para>t38support [R/W]</para>
+						<para>R/W t38support</para>
 						<para>Returns 0 or 1</para>
 						<para>Write yes or no</para>
 					</enum>
-					<enum name="h323id">
-						<para>Returns h323id [R]</para>
+					<enum name="h323id_url">
+						<para>R/0 Returns caller URL</para>
+ 					</enum>
+					<enum name="caller_h323id">
+						<para>R/0 Returns caller h323id</para>
+					</enum>
+					<enum name="caller_dialeddigits">
+						<para>R/0 Returns caller dialed digits</para>
+					</enum>
+					<enum name="caller_email">
+						<para>R/0 Returns caller email</para>
+					</enum>
+					<enum name="callee_email">
+						<para>R/0 Returns callee email</para>
+					</enum>
+					<enum name="callee_dialeddigits">
+						<para>R/0 Returns callee dialed digits</para>
+					</enum>
+					<enum name="caller_url">
+						<para>R/0 Returns caller URL</para>
 					</enum>
 				</enumlist>
 			</parameter>
@@ -538,7 +575,7 @@
 #ifdef CHANNEL_TRACE
 	else if (!strcasecmp(data, "trace")) {
 		ast_channel_lock(chan);
-		if (ast_true(value)) 
+		if (ast_true(value))
 			ret = ast_channel_trace_enable(chan);
 		else if (ast_false(value))
 			ret = ast_channel_trace_disable(chan);
@@ -553,7 +590,7 @@
 		struct ast_tone_zone *new_zone;
 		if (!(new_zone = ast_get_indication_zone(value))) {
 			ast_log(LOG_ERROR, "Unknown country code '%s' for tonezone. Check indications.conf for available country codes.\n", value);
-			ret = -1;	
+			ret = -1;
 		} else {
 			ast_channel_lock(chan);
 			if (ast_channel_zone(chan)) {
--- funcs/func_dialgroup.c
+++ funcs/func_dialgroup.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 366917 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include <sys/stat.h>
 
@@ -174,11 +174,17 @@
 {
 	int len = 500, res = 0;
 	char *buf = NULL;
+	char *new_buf;
 	char *dialgroup = ast_strdupa(cdialgroup);
 
 	do {
 		len *= 2;
-		buf = ast_realloc(buf, len);
+		new_buf = ast_realloc(buf, len);
+		if (!new_buf) {
+			ast_free(buf);
+			return -1;
+		}
+		buf = new_buf;
 
 		if ((res = dialgroup_read(chan, "", dialgroup, buf, len)) < 0) {
 			ast_free(buf);
--- funcs/func_global.c
+++ funcs/func_global.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include <sys/stat.h>
 
@@ -253,15 +253,16 @@
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 
-	var = ast_var_assign(args.var, S_OR(value, ""));
-	AST_LIST_INSERT_HEAD(varshead, var, entries);
-	manager_event(EVENT_FLAG_DIALPLAN, "VarSet", 
-		"Channel: %s\r\n"
-		"Variable: SHARED(%s)\r\n"
-		"Value: %s\r\n"
-		"Uniqueid: %s\r\n", 
-		chan ? ast_channel_name(chan) : "none", args.var, value, 
-		chan ? ast_channel_uniqueid(chan) : "none");
+	if ((var = ast_var_assign(args.var, S_OR(value, "")))) {
+		AST_LIST_INSERT_HEAD(varshead, var, entries);
+		manager_event(EVENT_FLAG_DIALPLAN, "VarSet", 
+			"Channel: %s\r\n"
+			"Variable: SHARED(%s)\r\n"
+			"Value: %s\r\n"
+			"Uniqueid: %s\r\n", 
+			chan ? ast_channel_name(chan) : "none", args.var, value, 
+			chan ? ast_channel_uniqueid(chan) : "none");
+	}
 
 	ast_channel_unlock(chan);
 
--- funcs/func_strings.c
+++ funcs/func_strings.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396310 $")
 
 #include <regex.h>
 #include <ctype.h>
@@ -165,6 +165,10 @@
 			<para>Literally returns the given <replaceable>string</replaceable>.  The intent is to permit
 			other dialplan functions which take a variable name as an argument to be able to take a literal
 			string, instead.</para>
+			<note><para>The functions which take a variable name need to be passed var and not
+			${var}.  Similarly, use PASSTHRU() and not ${PASSTHRU()}.</para></note>
+			<para>Example: ${CHANNEL} contains SIP/321-1</para>
+			<para>         ${CUT(PASSTHRU(${CUT(CHANNEL,-,1)}),/,2)}) will return 321</para>
 		</description>
 	</function>
 	<function name="REGEX" language="en_US">
@@ -1694,6 +1698,12 @@
 
 	for (i = 0; i < ARRAY_LEN(test_args); i++) {
 		struct ast_var_t *var = ast_var_assign("FIELDS", test_args[i].fields);
+		if (!var) {
+			ast_test_status_update(test, "Out of memory\n");
+			res = AST_TEST_FAIL;
+			break;
+		}
+
 		AST_LIST_INSERT_HEAD(ast_channel_varshead(chan), var, entries);
 
 		snprintf(expression, sizeof(expression), "${FIELDNUM(%s,%s,%s)}", var->name, test_args[i].delim, test_args[i].field);
@@ -1796,6 +1806,13 @@
 		char tmp[512], tmp2[512] = "";
 
 		struct ast_var_t *var = ast_var_assign("test_string", test_strings[i][0]);
+		if (!var) {
+			ast_test_status_update(test, "Unable to allocate variable\n");
+			ast_free(str);
+			ast_channel_release(chan);
+			return AST_TEST_FAIL;
+		}
+			
 		AST_LIST_INSERT_HEAD(ast_channel_varshead(chan), var, entries);
 
 		if (test_strings[i][3]) {
--- include/asterisk/astmm.h
+++ include/asterisk/astmm.h
@@ -54,6 +54,12 @@
 #undef vasprintf
 #undef free
 
+void *ast_std_malloc(size_t size);
+void *ast_std_calloc(size_t nmemb, size_t size);
+void *ast_std_realloc(void *ptr, size_t size);
+void ast_std_free(void *ptr);
+void ast_free_ptr(void *ptr);
+
 void *__ast_calloc(size_t nmemb, size_t size, const char *file, int lineno, const char *func);
 void *__ast_calloc_cache(size_t nmemb, size_t size, const char *file, int lineno, const char *func);
 void *__ast_malloc(size_t size, const char *file, int lineno, const char *func);
--- include/asterisk/frame.h
+++ include/asterisk/frame.h
@@ -296,12 +296,16 @@
 };
 
 enum ast_control_t38_rate {
-	AST_T38_RATE_2400 = 0,
+	AST_T38_RATE_2400 = 1,
 	AST_T38_RATE_4800,
 	AST_T38_RATE_7200,
 	AST_T38_RATE_9600,
 	AST_T38_RATE_12000,
-	AST_T38_RATE_14400,
+	/* Set to 0 so it's taken as default when unspecified.
+	 * See ITU-T T.38 Implementors' Guide (11 May 2012),
+	 * Table H.2: if the T38MaxBitRate attribute is omitted
+	 * it should use a default of 14400. */
+	AST_T38_RATE_14400 = 0,
 };
 
 enum ast_control_t38_rate_management {
--- include/asterisk/lock.h
+++ include/asterisk/lock.h
@@ -281,30 +281,18 @@
 #else
 void ast_remove_lock_info(void *lock_addr);
 #endif /* HAVE_BKTR */
+void ast_suspend_lock_info(void *lock_addr);
+void ast_restore_lock_info(void *lock_addr);
 #else
 #ifdef HAVE_BKTR
 #define ast_remove_lock_info(ignore,me)
 #else
 #define ast_remove_lock_info(ignore)
 #endif /* HAVE_BKTR */
+#define ast_suspend_lock_info(ignore);
+#define ast_restore_lock_info(ignore);
 #endif /* !defined(LOW_MEMORY) */
 
-#ifdef HAVE_BKTR
-static inline void __dump_backtrace(struct ast_bt *bt, int canlog)
-{
-	char **strings;
-
-	ssize_t i;
-
-	strings = backtrace_symbols(bt->addresses, bt->num_frames);
-
-	for (i = 0; i < bt->num_frames; i++)
-		__ast_mutex_logger("%s\n", strings[i]);
-
-	free(strings);
-}
-#endif
-
 /*!
  * \brief log info for the current lock with ast_log().
  *
--- include/asterisk/logger.h
+++ include/asterisk/logger.h
@@ -411,7 +411,7 @@
  * \param addresses A list of addresses, such as the ->addresses structure element of struct ast_bt.
  * \param num_frames Number of addresses in the addresses list
  * \retval NULL Unable to allocate memory
- * \return List of strings
+ * \return List of strings. Free the entire list with a single ast_std_free call.
  * \since 1.6.2.16
  */
 char **ast_bt_get_symbols(void **addresses, size_t num_frames);
--- include/asterisk/utils.h
+++ include/asterisk/utils.h
@@ -459,24 +459,20 @@
 long int ast_random(void);
 
 
+#ifndef __AST_DEBUG_MALLOC
+#define ast_std_malloc malloc
+#define ast_std_calloc calloc
+#define ast_std_realloc realloc
+#define ast_std_free free
+
 /*!
  * \brief free() wrapper
  *
  * ast_free_ptr should be used when a function pointer for free() needs to be passed
  * as the argument to a function. Otherwise, astmm will cause seg faults.
  */
-#ifdef __AST_DEBUG_MALLOC
-static void ast_free_ptr(void *ptr) attribute_unused;
-static void ast_free_ptr(void *ptr)
-{
-	ast_free(ptr);
-}
-#else
 #define ast_free free
 #define ast_free_ptr ast_free
-#endif
-
-#ifndef __AST_DEBUG_MALLOC
 
 #define MALLOC_FAILURE_MSG \
 	ast_log(LOG_ERROR, "Memory Allocation Failure in function %s at line %d of %s\n", func, lineno, file);
--- main/asterisk.c
+++ main/asterisk.c
@@ -1,7 +1,7 @@
 /*
  * Asterisk -- An open source telephony toolkit.
  *
- * Copyright (C) 1999 - 2012, Digium, Inc.
+ * Copyright (C) 1999 - 2013, Digium, Inc.
  *
  * Mark Spencer <markster@digium.com>
  *
@@ -39,7 +39,7 @@
  *
  * \section copyright Copyright and Author
  *
- * Copyright (C) 1999 - 2012, Digium, Inc.
+ * Copyright (C) 1999 - 2013, Digium, Inc.
  * Asterisk is a <a href="http://www.digium.com/en/company/view-policy.php?id=Trademark-Policy">registered trademark</a>
  * of <a href="http://www.digium.com">Digium, Inc</a>.
  *
@@ -65,7 +65,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 379790 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include "asterisk/_private.h"
 
@@ -173,7 +173,7 @@
 
 /*! \brief Welcome message when starting a CLI interface */
 #define WELCOME_MESSAGE \
-    ast_verbose("Asterisk %s, Copyright (C) 1999 - 2012 Digium, Inc. and others.\n" \
+    ast_verbose("Asterisk %s, Copyright (C) 1999 - 2013 Digium, Inc. and others.\n" \
                 "Created by Mark Spencer <markster@digium.com>\n" \
                 "Asterisk comes with ABSOLUTELY NO WARRANTY; type 'core show warranty' for details.\n" \
                 "This is free software, with components licensed under the GNU General Public\n" \
@@ -1721,8 +1721,8 @@
 		time_t s, e;
 		/* Begin shutdown routine, hanging up active channels */
 		ast_begin_shutdown(1);
-		if (option_verbose && ast_opt_console) {
-			ast_verbose("Beginning asterisk %s....\n", restart ? "restart" : "shutdown");
+		if (ast_opt_console) {
+			ast_verb(0, "Beginning asterisk %s....\n", restart ? "restart" : "shutdown");
 		}
 		time(&s);
 		for (;;) {
@@ -1738,7 +1738,7 @@
 		if (niceness != SHUTDOWN_REALLY_NICE) {
 			ast_begin_shutdown(0);
 		}
-		if (option_verbose && ast_opt_console) {
+		if (ast_opt_console) {
 			ast_verb(0, "Waiting for inactivity to perform %s...\n", restart ? "restart" : "halt");
 		}
 		for (;;) {
@@ -1753,7 +1753,7 @@
 	 * case someone else has taken over the shutdown. */
 	ast_mutex_lock(&safe_system_lock);
 	if (shuttingdown != niceness) {
-		if (shuttingdown == NOT_SHUTTING_DOWN && option_verbose && ast_opt_console) {
+		if (shuttingdown == NOT_SHUTTING_DOWN && ast_opt_console) {
 			ast_verb(0, "Asterisk %s cancelled.\n", restart ? "restart" : "shutdown");
 		}
 		ast_mutex_unlock(&safe_system_lock);
@@ -1892,49 +1892,127 @@
 	sig_flags.need_quit = 1;
 }
 
-static const char *fix_header(char *outbuf, int maxout, const char *s, char *cmp)
+static const char *fix_header(char *outbuf, int maxout, const char *s, char level)
 {
-	const char *c;
+	const char *cmp;
+
+	switch (level) {
+	case 0: *outbuf = '\0';
+		return s;
+	case 1: cmp = VERBOSE_PREFIX_1;
+		break;
+	case 2: cmp = VERBOSE_PREFIX_2;
+		break;
+	case 3: cmp = VERBOSE_PREFIX_3;
+		break;
+	default: cmp = VERBOSE_PREFIX_4;
+		break;
+	}
 
 	if (!strncmp(s, cmp, strlen(cmp))) {
-		c = s + strlen(cmp);
-		term_color(outbuf, cmp, COLOR_GRAY, 0, maxout);
-		return c;
+		s += strlen(cmp);
 	}
-	return NULL;
+	term_color(outbuf, cmp, COLOR_GRAY, 0, maxout);
+
+	return s;
+}
+
+struct console_state_data {
+	int newline;
+	char verbose_line_level;
+};
+
+static int console_state_init(void *ptr)
+{
+	struct console_state_data *state = ptr;
+	state->newline = 1;
+	state->verbose_line_level = 0;
+	return 0;
 }
 
+AST_THREADSTORAGE_CUSTOM(console_state, console_state_init, ast_free_ptr);
+
 /* These gymnastics are due to platforms which designate char as unsigned by
  * default. Level is the negative character -- offset by 1, because \0 is the
  * EOS delimiter. */
 #define VERBOSE_MAGIC2LEVEL(x) (((char) -*(signed char *) (x)) - 1)
 #define VERBOSE_HASMAGIC(x)	(*(signed char *) (x) < 0)
 
-static void console_verboser(const char *s)
+static int console_log_verbose(const char *s)
 {
-	char tmp[80];
-	const char *c = NULL;
-	char level = 0;
+	/* verbose level of 0 evaluates to a magic of -1, 1 to -2, etc...
+	   search up to -7 (level = 6) as this is currently the largest
+	   level used */
+	static const char find_set[9] = { -1, -2, -3, -4, -5, -6, -7, '\n'};
 
-	if (VERBOSE_HASMAGIC(s)) {
-		level = VERBOSE_MAGIC2LEVEL(s);
-		s++;
-		if (level > option_verbose) {
-			return;
+	struct console_state_data *state =
+		ast_threadstorage_get(&console_state, sizeof(*state));
+
+	char prefix[80];
+	const char *c = s;
+	int num, res = 0;
+
+	do {
+		if (VERBOSE_HASMAGIC(s)) {
+			/* if it has one always use the given line's level,
+			   otherwise we'll use the last line's level */
+			state->verbose_line_level = VERBOSE_MAGIC2LEVEL(s);
+			/* move past magic */
+			s++;
 		}
-	}
 
-	if ((c = fix_header(tmp, sizeof(tmp), s, VERBOSE_PREFIX_4)) ||
-	    (c = fix_header(tmp, sizeof(tmp), s, VERBOSE_PREFIX_3)) ||
-	    (c = fix_header(tmp, sizeof(tmp), s, VERBOSE_PREFIX_2)) ||
-	    (c = fix_header(tmp, sizeof(tmp), s, VERBOSE_PREFIX_1))) {
-		fputs(tmp, stdout);
-		fputs(c, stdout);
-	} else {
-		fputs(s, stdout);
+		c = fix_header(prefix, sizeof(prefix), s,
+			       state->verbose_line_level);
+
+		if (!state->newline) {
+			/* don't use the prefix if line continuation */
+			*prefix = '\0';
+		}
+
+		/* for a given line separate on verbose magic and newlines */
+		if (!(s = strpbrk(c, find_set))) {
+			s = strchr(c, '\0');
+		} else if (*s == '\n') {
+			++s;
+		}
+
+		/* check if we should write this line after calculating begin/end
+		   so we process the case of a higher level line embedded within
+		   two lower level lines */
+		if (state->verbose_line_level > option_verbose) {
+			continue;
+		}
+
+		state->newline = *(s - 1) == '\n';
+		if (!ast_strlen_zero(prefix)) {
+			fputs(prefix, stdout);
+		}
+
+		num = s - c;
+		if (fwrite(c, sizeof(char), num, stdout) < num) {
+			break;
+		}
+
+		if (!res) {
+			/* if at least some info has been written
+			   we'll want to return true */
+			res = 1;
+		}
+		c = s;
+	} while (*s);
+
+	if (res) {
+		fflush(stdout);
 	}
 
-	fflush(stdout);
+	return res;
+}
+
+static void console_verboser(const char *s)
+{
+	if (!console_log_verbose(s)) {
+		return;
+	}
 
 	/* Wake up a poll()ing console */
 	if (ast_opt_console && consolethread != AST_PTHREADT_NULL) {
@@ -1977,6 +2055,11 @@
 	/* Called when readline data is available */
 	if (!ast_all_zeros(s))
 		ast_el_add_history(s);
+
+	while (isspace(*s)) {
+		s++;
+	}
+
 	/* The real handler for bang */
 	if (s[0] == '!') {
 		if (s[1])
@@ -2337,23 +2420,6 @@
 #endif /* ! LOW_MEMORY */
 };
 
-struct el_read_char_state_struct {
-	unsigned int line_full:1;
-	unsigned int prev_line_full:1;
-	char prev_line_verbosity;
-};
-
-static int el_read_char_state_init(void *ptr)
-{
-	struct el_read_char_state_struct *state = ptr;
-	state->line_full = 1;
-	state->prev_line_full = 1;
-	state->prev_line_verbosity = 0;
-	return 0;
-}
-
-AST_THREADSTORAGE_CUSTOM(el_read_char_state, el_read_char_state_init, ast_free_ptr);
-
 static int ast_el_read_char(EditLine *editline, char *cp)
 {
 	int num_read = 0;
@@ -2363,7 +2429,6 @@
 	int max;
 #define EL_BUF_SIZE 512
 	char buf[EL_BUF_SIZE];
-	struct el_read_char_state_struct *state = ast_threadstorage_get(&el_read_char_state, sizeof(*state));
 
 	for (;;) {
 		max = 1;
@@ -2393,8 +2458,6 @@
 			}
 		}
 		if (fds[0].revents) {
-			char level = 0;
-			char *curline = buf, *nextline;
 			res = read(ast_consock, buf, sizeof(buf) - 1);
 			/* if the remote side disappears exit */
 			if (res < 1) {
@@ -2434,33 +2497,7 @@
 				}
 			}
 
-			do {
-				state->prev_line_full = state->line_full;
-				if ((nextline = strchr(curline, '\n'))) {
-					state->line_full = 1;
-					nextline++;
-				} else {
-					state->line_full = 0;
-					nextline = strchr(curline, '\0');
-				}
-
-				if (state->prev_line_full && VERBOSE_HASMAGIC(curline)) {
-					level = VERBOSE_MAGIC2LEVEL(curline);
-					curline++;
-				} else if (state->prev_line_full && !VERBOSE_HASMAGIC(curline)) {
-					/* Non-verbose output */
-					level = 0;
-				} else {
-					level = state->prev_line_verbosity;
-				}
-				if ((!state->prev_line_full && state->prev_line_verbosity <= option_verbose) || (state->prev_line_full && level <= option_verbose)) {
-					if (write(STDOUT_FILENO, curline, nextline - curline) < 0) {
-					}
-				}
-
-				state->prev_line_verbosity = level;
-				curline = nextline;
-			} while (!ast_strlen_zero(curline));
+			console_log_verbose(buf);
 
 			if ((res < EL_BUF_SIZE - 1) && ((buf[res-1] == '\n') || (buf[res-2] == '\n'))) {
 				*cp = CC_REFRESH;
@@ -2603,45 +2640,62 @@
 	return ast_str_buffer(prompt);
 }
 
+static void destroy_match_list(char **match_list, int matches)
+{
+	if (match_list) {
+		int idx;
+
+		for (idx = 0; idx < matches; ++idx) {
+			ast_free(match_list[idx]);
+		}
+		ast_free(match_list);
+	}
+}
+
 static char **ast_el_strtoarr(char *buf)
 {
-	char **match_list = NULL, **match_list_tmp, *retstr;
-	size_t match_list_len;
+	char *retstr;
+	char **match_list = NULL;
+	char **new_list;
+	size_t match_list_len = 1;
 	int matches = 0;
 
-	match_list_len = 1;
-	while ( (retstr = strsep(&buf, " ")) != NULL) {
-
-		if (!strcmp(retstr, AST_CLI_COMPLETE_EOF))
+	while ((retstr = strsep(&buf, " "))) {
+		if (!strcmp(retstr, AST_CLI_COMPLETE_EOF)) {
 			break;
+		}
 		if (matches + 1 >= match_list_len) {
 			match_list_len <<= 1;
-			if ((match_list_tmp = ast_realloc(match_list, match_list_len * sizeof(char *)))) {
-				match_list = match_list_tmp;
-			} else {
-				if (match_list)
-					ast_free(match_list);
-				return (char **) NULL;
+			new_list = ast_realloc(match_list, match_list_len * sizeof(char *));
+			if (!new_list) {
+				destroy_match_list(match_list, matches);
+				return NULL;
 			}
+			match_list = new_list;
 		}
 
-		match_list[matches++] = ast_strdup(retstr);
+		retstr = ast_strdup(retstr);
+		if (!retstr) {
+			destroy_match_list(match_list, matches);
+			return NULL;
+		}
+		match_list[matches++] = retstr;
 	}
 
-	if (!match_list)
-		return (char **) NULL;
+	if (!match_list) {
+		return NULL;
+	}
 
 	if (matches >= match_list_len) {
-		if ((match_list_tmp = ast_realloc(match_list, (match_list_len + 1) * sizeof(char *)))) {
-			match_list = match_list_tmp;
-		} else {
-			if (match_list)
-				ast_free(match_list);
-			return (char **) NULL;
+		new_list = ast_realloc(match_list, (match_list_len + 1) * sizeof(char *));
+		if (!new_list) {
+			destroy_match_list(match_list, matches);
+			return NULL;
 		}
+		match_list = new_list;
 	}
 
-	match_list[matches] = (char *) NULL;
+	match_list[matches] = NULL;
 
 	return match_list;
 }
@@ -2742,7 +2796,9 @@
 
 		if (nummatches > 0) {
 			char *mbuf;
+			char *new_mbuf;
 			int mlen = 0, maxmbuf = 2048;
+
 			/* Start with a 2048 byte buffer */
 			if (!(mbuf = ast_malloc(maxmbuf))) {
 				*((char *) lf->cursor) = savechr;
@@ -2756,10 +2812,13 @@
 				if (mlen + 1024 > maxmbuf) {
 					/* Every step increment buffer 1024 bytes */
 					maxmbuf += 1024;
-					if (!(mbuf = ast_realloc(mbuf, maxmbuf))) {
+					new_mbuf = ast_realloc(mbuf, maxmbuf);
+					if (!new_mbuf) {
+						ast_free(mbuf);
 						*((char *) lf->cursor) = savechr;
 						return (char *)(CC_ERROR);
 					}
+					mbuf = new_mbuf;
 				}
 				/* Only read 1024 bytes at a time */
 				res = read(ast_consock, mbuf + mlen, 1024);
@@ -3070,7 +3129,7 @@
 
 static int show_cli_help(void)
 {
-	printf("Asterisk %s, Copyright (C) 1999 - 2012, Digium, Inc. and others.\n", ast_get_version());
+	printf("Asterisk %s, Copyright (C) 1999 - 2013, Digium, Inc. and others.\n", ast_get_version());
 	printf("Usage: asterisk [OPTIONS]\n");
 	printf("Valid Options:\n");
 	printf("   -V              Display version number and exit\n");
@@ -3472,7 +3531,7 @@
 
 static void print_intro_message(const char *runuser, const char *rungroup)
 {
-	if (ast_opt_console || option_verbose || (ast_opt_remote && !ast_opt_exec)) {
+ 	if (ast_opt_console || option_verbose || (ast_opt_remote && !ast_opt_exec)) {
 		if (ast_register_verbose(console_verboser)) {
 			fprintf(stderr, "Unable to register console verboser?\n");
 			return;
@@ -3964,8 +4023,8 @@
 
 	print_intro_message(runuser, rungroup);
 
-	if (ast_opt_console && !option_verbose) {
-		ast_verbose("[ Initializing Custom Configuration Options ]\n");
+	if (ast_opt_console) {
+		ast_verb(0, "[ Initializing Custom Configuration Options ]\n");
 	}
 	/* custom config setup */
 	register_config_cli();
--- main/asterisk.exports.in
+++ main/asterisk.exports.in
@@ -46,6 +46,25 @@
 		LINKER_SYMBOL_PREFIXres_srtp;
 		LINKER_SYMBOL_PREFIXres_srtp_policy;
 		LINKER_SYMBOL_PREFIXsecure_call_info;
+		/*
+
+		If _IO_stdin_used is not exported, stdout/stderr may not get
+		properly aligned. That causes breakage on some architectures.
+
+		http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634261#51
+		http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634261#94
+		http://lists.gnu.org/archive/html/bug-glibc/2001-12/msg00203.html
+
+		We export the symbol to get proper behaviour. Now printf
+		doesn't SIGBUS anymore on the SPARC.
+
+		Michael Karcher wrote on Jan 13, 2013:
+		> A build process that mangles the export of _IO_stdin_used is
+		> (as defined by the libc ABI, even if not explicitly written
+		> down) broken. [...]
+
+		*/
+		LINKER_SYMBOL_PREFIX_IO_stdin_used;
 	local:
 		*;
 };
--- main/astfd.c
+++ main/astfd.c
@@ -31,7 +31,7 @@
 
 #ifdef DEBUG_FD_LEAKS
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 369013 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397107 $")
 
 #include <stdio.h>
 #include <string.h>
@@ -274,8 +274,14 @@
 
 static struct ast_cli_entry cli_show_fd = AST_CLI_DEFINE(handle_show_fd, "Show open file descriptors");
 
+static void fd_shutdown(void)
+{
+	ast_cli_unregister(&cli_show_fd);
+}
+
 int ast_fd_init(void)
 {
+	ast_register_atexit(fd_shutdown);
 	return ast_cli_register(&cli_show_fd);
 }
 
--- main/astmm.c
+++ main/astmm.c
@@ -32,7 +32,7 @@
 
 #if defined(__AST_DEBUG_MALLOC)
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377401 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398721 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_LOG_DIR */
 #include <stddef.h>
@@ -70,7 +70,7 @@
 #undef vasprintf
 #undef asprintf
 
-#define FENCE_MAGIC		0xdeadbeef	/*!< Allocated memory high/low fence overwrite check. */
+#define FENCE_MAGIC		0xfeedbabe	/*!< Allocated memory high/low fence overwrite check. */
 #define FREED_MAGIC		0xdeaddead	/*!< Freed memory wipe filler. */
 #define MALLOC_FILLER	0x55		/*!< Malloced memory filler.  Must not be zero. */
 
@@ -157,6 +157,31 @@
 		}                                    \
 	} while (0)
 
+void *ast_std_malloc(size_t size)
+{
+	return malloc(size);
+}
+
+void *ast_std_calloc(size_t nmemb, size_t size)
+{
+	return calloc(nmemb, size);
+}
+
+void *ast_std_realloc(void *ptr, size_t size)
+{
+	return realloc(ptr, size);
+}
+
+void ast_std_free(void *ptr)
+{
+	free(ptr);
+}
+
+void ast_free_ptr(void *ptr)
+{
+	ast_free(ptr);
+}
+
 /*!
  * \internal
  *
--- main/astobj2.c
+++ main/astobj2.c
@@ -24,7 +24,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388700 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397528 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/astobj2.h"
@@ -123,7 +123,7 @@
 	for(i = 0; i < c; i++) {
 		ast_verbose("%d: %p %s\n", i, addresses[i], strings[i]);
 	}
-	free(strings);
+	ast_std_free(strings);
 }
 #endif
 
--- main/cdr.c
+++ main/cdr.c
@@ -37,7 +37,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 383840 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include <signal.h>
 
@@ -383,8 +383,7 @@
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
 
-		if (value) {
-			newvariable = ast_var_assign(name, value);
+		if (value && (newvariable = ast_var_assign(name, value))) {
 			AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 		}
 	}
@@ -408,8 +407,8 @@
 	AST_LIST_TRAVERSE(headpa,variables,entries) {
 		if (variables &&
 		    (var = ast_var_name(variables)) && (val = ast_var_value(variables)) &&
-		    !ast_strlen_zero(var) && !ast_strlen_zero(val)) {
-			newvariable = ast_var_assign(var, val);
+		    !ast_strlen_zero(var) && !ast_strlen_zero(val) &&
+		    (newvariable = ast_var_assign(var, val))) {
 			AST_LIST_INSERT_HEAD(headpb, newvariable, entries);
 			x++;
 		}
--- main/cel.c
+++ main/cel.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377883 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397034 $")
 
 #include "asterisk/_private.h"
 
@@ -310,7 +310,7 @@
 
 	config = ast_config_load2("cel.conf", "cel", config_flags);
 
-	if (config == CONFIG_STATUS_FILEMISSING) {
+	if (config == CONFIG_STATUS_FILEMISSING || config == CONFIG_STATUS_FILEUNCHANGED || config == CONFIG_STATUS_FILEINVALID) {
 		config = NULL;
 		goto return_cleanup;
 	}
--- main/cli.c
+++ main/cli.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 386051 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_MODULE_DIR */
@@ -2299,6 +2299,13 @@
 		return NULL;
 
 	cur = duplicate;
+
+	/* Remove leading spaces from the command */
+	while (isspace(*s)) {
+		cur++;
+		s++;
+	}
+
 	/* scan the original string copying into cur when needed */
 	for (; *s ; s++) {
 		if (x >= max - 1) {
@@ -2363,9 +2370,22 @@
 	return matches;
 }
 
+static void destroy_match_list(char **match_list, int matches)
+{
+	if (match_list) {
+		int idx;
+
+		for (idx = 1; idx < matches; ++idx) {
+			ast_free(match_list[idx]);
+		}
+		ast_free(match_list);
+	}
+}
+
 char **ast_cli_completion_matches(const char *text, const char *word)
 {
 	char **match_list = NULL, *retstr, *prevstr;
+	char **new_list;
 	size_t match_list_len, max_equal, which, i;
 	int matches = 0;
 
@@ -2374,14 +2394,19 @@
 	while ((retstr = ast_cli_generator(text, word, matches)) != NULL) {
 		if (matches + 1 >= match_list_len) {
 			match_list_len <<= 1;
-			if (!(match_list = ast_realloc(match_list, match_list_len * sizeof(*match_list))))
+			new_list = ast_realloc(match_list, match_list_len * sizeof(*match_list));
+			if (!new_list) {
+				destroy_match_list(match_list, matches);
 				return NULL;
+			}
+			match_list = new_list;
 		}
 		match_list[++matches] = retstr;
 	}
 
-	if (!match_list)
+	if (!match_list) {
 		return match_list; /* NULL */
+	}
 
 	/* Find the longest substring that is common to all results
 	 * (it is a candidate for completion), and store a copy in entry 0.
@@ -2394,20 +2419,23 @@
 		max_equal = i;
 	}
 
-	if (!(retstr = ast_malloc(max_equal + 1))) {
-		ast_free(match_list);
+	retstr = ast_malloc(max_equal + 1);
+	if (!retstr) {
+		destroy_match_list(match_list, matches);
 		return NULL;
 	}
-
 	ast_copy_string(retstr, match_list[1], max_equal + 1);
 	match_list[0] = retstr;
 
 	/* ensure that the array is NULL terminated */
 	if (matches + 1 >= match_list_len) {
-		if (!(match_list = ast_realloc(match_list, (match_list_len + 1) * sizeof(*match_list)))) {
+		new_list = ast_realloc(match_list, (match_list_len + 1) * sizeof(*match_list));
+		if (!new_list) {
 			ast_free(retstr);
+			destroy_match_list(match_list, matches);
 			return NULL;
 		}
+		match_list = new_list;
 	}
 	match_list[matches + 1] = NULL;
 
--- main/config.c
+++ main/config.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 386677 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_CONFIG_DIR */
 #include "asterisk/network.h"	/* we do some sockaddr manipulation here */
@@ -3164,6 +3164,10 @@
 
 	AST_LIST_LOCK(&cfmtime_head);
 	while ((cfmtime = AST_LIST_REMOVE_HEAD(&cfmtime_head, list))) {
+		struct cache_file_include *cfinclude;
+		while ((cfinclude = AST_LIST_REMOVE_HEAD(&cfmtime->includes, list))) {
+			ast_free(cfinclude);
+		}
 		ast_free(cfmtime);
 	}
 	AST_LIST_UNLOCK(&cfmtime_head);
--- main/config_options.c
+++ main/config_options.c
@@ -27,7 +27,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 374196 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include <regex.h>
 
@@ -153,14 +153,15 @@
 			return -1;
 		}
 		if (!ao2_link(type->internal->opts, opt)) {
-			while (--idx) {
+			do {
 				ao2_unlink(types[idx]->internal->opts, opt);
-			}
+			} while (--idx);
 			return -1;
 		}
-		/* The container should hold the only ref to opt */
-		ao2_ref(opt, -1);
 	}
+	/* The container(s) should hold the only ref to opt */
+	ao2_ref(opt, -1);
+
 	return 0;
 }
 
--- main/data.c
+++ main/data.c
@@ -28,7 +28,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377883 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396961 $")
 
 #include "asterisk/_private.h"
 
@@ -1631,7 +1631,7 @@
 {
 	struct data_filter *filter = obj, *globres;
 
-	AST_LIST_TRAVERSE(&(filter->glob_list), globres, list) {
+	while ((globres = AST_LIST_REMOVE_HEAD(&(filter->glob_list), list))) {
 		ao2_ref(globres, -1);
 	}
 
--- main/event.c
+++ main/event.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387030 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include "asterisk/_private.h"
 
@@ -1197,13 +1197,17 @@
 	const void *data, size_t data_len)
 {
 	struct ast_event_ie *ie;
+	struct ast_event *old_event;
 	unsigned int extra_len;
 	uint16_t event_len;
 
 	event_len = ntohs((*event)->event_len);
 	extra_len = sizeof(*ie) + data_len;
 
-	if (!(*event = ast_realloc(*event, event_len + extra_len))) {
+	old_event = *event;
+	*event = ast_realloc(*event, event_len + extra_len);
+	if (!*event) {
+		ast_free(old_event);
 		return -1;
 	}
 
--- main/features.c
+++ main/features.c
@@ -30,7 +30,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387038 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398022 $")
 
 #include "asterisk/_private.h"
 
@@ -1145,7 +1145,7 @@
 
 	if (tobj->return_to_pbx) {
 		if (!ast_check_hangup(tobj->peer)) {
-			ast_log(LOG_VERBOSE, "putting peer %s into PBX again\n", ast_channel_name(tobj->peer));
+			ast_verb(0, "putting peer %s into PBX again\n", ast_channel_name(tobj->peer));
 			if (ast_pbx_start(tobj->peer)) {
 				ast_log(LOG_WARNING, "FAILED continuing PBX on peer %s\n", ast_channel_name(tobj->peer));
 				ast_autoservice_chan_hangup_peer(tobj->chan, tobj->peer);
@@ -1154,7 +1154,7 @@
 			ast_autoservice_chan_hangup_peer(tobj->chan, tobj->peer);
 		}
 		if (!ast_check_hangup(tobj->chan)) {
-			ast_log(LOG_VERBOSE, "putting chan %s into PBX again\n", ast_channel_name(tobj->chan));
+			ast_verb(0, "putting chan %s into PBX again\n", ast_channel_name(tobj->chan));
 			if (ast_pbx_start(tobj->chan)) {
 				ast_log(LOG_WARNING, "FAILED continuing PBX on chan %s\n", ast_channel_name(tobj->chan));
 				ast_hangup(tobj->chan);
@@ -3613,6 +3613,10 @@
 				res = AST_FEATURE_RETURN_SUCCESS; /* We found something */
 			} else if (operation == FEATURE_INTERPRET_DO) {
 				res = builtin_features[x].operation(chan, peer, config, code, sense, NULL);
+				ast_test_suite_event_notify("FEATURE_DETECTION",
+						"Result: success\r\n"
+						"Feature: %s",
+						builtin_features[x].sname);
 			}
 			if (feature) {
 				memcpy(feature, &builtin_features[x], sizeof(*feature));
@@ -3625,6 +3629,12 @@
 			}
 		}
 	}
+
+	if (operation == FEATURE_INTERPRET_CHECK && x == FEATURES_COUNT) {
+		ast_test_suite_event_notify("FEATURE_DETECTION",
+				"Result: fail");
+	}
+
 	ast_rwlock_unlock(&features_lock);
 
 	if (ast_strlen_zero(dynamic_features_buf) || feature_detected) {
@@ -8840,6 +8850,7 @@
 		}
 		res = -1;
 	}
+	parked_chan = ast_channel_unref(parked_chan);
 
 
 exit_features_test:
@@ -9025,6 +9036,9 @@
 	ast_unregister_application(parkcall);
 	ast_unregister_application(parkedcall);
 	ast_unregister_application(app_bridge);
+#if defined(TEST_FRAMEWORK)
+	AST_TEST_UNREGISTER(features_test);
+#endif	/* defined(TEST_FRAMEWORK) */
 
 	pthread_cancel(parking_thread);
 	pthread_kill(parking_thread, SIGURG);
@@ -9072,4 +9086,3 @@
 
 	return res;
 }
-
--- main/format.c
+++ main/format.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377244 $");
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $");
 
 #include "asterisk/_private.h"
 #include "asterisk/format.h"
@@ -916,7 +916,7 @@
 
 static int format_list_add_custom(struct ast_format_list *new)
 {
-	struct ast_format_list *entry;
+	RAII_VAR(struct ast_format_list *, entry, NULL, ao2_cleanup);
 	if (!(entry = ao2_alloc(sizeof(*entry), NULL))) {
 		return -1;
 	}
--- main/heap.c
+++ main/heap.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 369013 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include "asterisk/heap.h"
 #include "asterisk/utils.h"
@@ -181,18 +181,19 @@
 #endif
 )
 {
-	h->avail_len = h->avail_len * 2 + 1;
+	void **new_heap;
+	size_t new_len = h->avail_len * 2 + 1;
 
-	if (!(h->heap =
 #ifdef MALLOC_DEBUG
-			__ast_realloc(h->heap, h->avail_len * sizeof(void *), file, lineno, func)
+	new_heap = __ast_realloc(h->heap, new_len * sizeof(void *), file, lineno, func);
 #else
-			ast_realloc(h->heap, h->avail_len * sizeof(void *))
+	new_heap = ast_realloc(h->heap, new_len * sizeof(void *));
 #endif
-		)) {
-		h->cur_len = h->avail_len = 0;
+	if (!new_heap) {
 		return -1;
 	}
+	h->heap = new_heap;
+	h->avail_len = new_len;
 
 	return 0;
 }
--- main/http.c
+++ main/http.c
@@ -36,7 +36,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 384119 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397309 $")
 
 #include <time.h>
 #include <sys/time.h>
@@ -666,7 +666,7 @@
 			prev = v;
 		}
 	}
-	
+
 done:
 	ast_free(buf);
 	return post_vars;
@@ -843,7 +843,7 @@
 	struct ast_variable *v, *cookies=NULL;
 
 	for (v = headers; v; v = v->next) {
-		if (!strncasecmp(v->name, "Cookie", 6)) {
+		if (!strcasecmp(v->name, "Cookie")) {
 			char *tmp = ast_strdupa(v->value);
 			if (cookies) {
 				ast_variables_destroy(cookies);
@@ -1024,7 +1024,7 @@
 	struct http_uri_redirect *redirect;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
 	uint32_t bindport = DEFAULT_PORT;
-	struct ast_sockaddr *addrs = NULL;
+	RAII_VAR(struct ast_sockaddr *, addrs, NULL, ast_free);
 	int num_addrs = 0;
 	int http_tls_was_enabled = 0;
 
@@ -1229,7 +1229,25 @@
 
 static void http_shutdown(void)
 {
+	struct http_uri_redirect *redirect;
 	ast_cli_unregister_multiple(cli_http, ARRAY_LEN(cli_http));
+
+	ast_tcptls_server_stop(&http_desc);
+	if (http_tls_cfg.enabled) {
+		ast_tcptls_server_stop(&https_desc);
+	}
+	ast_free(http_tls_cfg.certfile);
+	ast_free(http_tls_cfg.pvtfile);
+	ast_free(http_tls_cfg.cipher);
+
+	ast_http_uri_unlink(&statusuri);
+	ast_http_uri_unlink(&staticuri);
+
+	AST_RWLIST_WRLOCK(&uri_redirects);
+	while ((redirect = AST_RWLIST_REMOVE_HEAD(&uri_redirects, entry))) {
+		ast_free(redirect);
+	}
+	AST_RWLIST_UNLOCK(&uri_redirects);
 }
 
 int ast_http_init(void)
--- main/indications.c
+++ main/indications.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377742 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include <math.h>
 
@@ -341,12 +341,12 @@
 	}
 
 	while ((s = strsep(&stringp, separator)) && !ast_strlen_zero(s)) {
+		struct playtones_item *new_items;
 		struct ast_tone_zone_part tone_data = {
 			.time = 0,
 		};
 
 		s = ast_strip(s);
-
 		if (s[0]=='!') {
 			s++;
 		} else if (d.reppos == -1) {
@@ -374,9 +374,12 @@
 			}
 		}
 
-		if (!(d.items = ast_realloc(d.items, (d.nitems + 1) * sizeof(*d.items)))) {
+		new_items = ast_realloc(d.items, (d.nitems + 1) * sizeof(*d.items));
+		if (!new_items) {
+			ast_free(d.items);
 			return -1;
 		}
+		d.items = new_items;
 
 		d.items[d.nitems].fac1 = 2.0 * cos(2.0 * M_PI * (tone_data.freq1 / sample_rate)) * max_sample_val;
 		d.items[d.nitems].init_v2_1 = sin(-4.0 * M_PI * (tone_data.freq1 / sample_rate)) * d.vol;
@@ -499,6 +502,9 @@
 
 	ast_tone_zone_unlock(zone);
 
+	if (!_zone)
+		zone = ast_tone_zone_unref(zone);
+
 	return ts;
 }
 
--- main/loader.c
+++ main/loader.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 378094 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_MODULE_DIR */
@@ -1035,6 +1035,8 @@
 			break;
 		case AST_MODULE_LOAD_PRIORITY:
 			AST_LIST_REMOVE_CURRENT(entry);
+			ast_free(order->resource);
+			ast_free(order);
 			break;
 		}
 	}
--- main/lock.c
+++ main/lock.c
@@ -27,8 +27,9 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388839 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398649 $")
 
+#include "asterisk/utils.h"
 #include "asterisk/lock.h"
 
 /* Allow direct use of pthread_mutex_* / pthread_cond_* */
@@ -45,6 +46,22 @@
 #undef pthread_cond_wait
 #undef pthread_cond_timedwait
 
+#if defined(DEBUG_THREADS) && defined(HAVE_BKTR)
+static void __dump_backtrace(struct ast_bt *bt, int canlog)
+{
+	char **strings;
+	ssize_t i;
+
+	strings = backtrace_symbols(bt->addresses, bt->num_frames);
+
+	for (i = 0; i < bt->num_frames; i++) {
+		__ast_mutex_logger("%s\n", strings[i]);
+	}
+
+	ast_std_free(strings);
+}
+#endif	/* defined(DEBUG_THREADS) && defined(HAVE_BKTR) */
+
 int __ast_pthread_mutex_init(int tracking, const char *filename, int lineno, const char *func,
 						const char *mutex_name, ast_mutex_t *t)
 {
@@ -191,12 +208,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t, bt);
 #else
 		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t);
@@ -323,12 +348,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t, bt);
 #else
 		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t);
@@ -480,10 +513,8 @@
 
 #ifdef DEBUG_THREADS
 	struct ast_lock_track *lt;
+	struct ast_lock_track lt_orig;
 	int canlog = strcmp(filename, "logger.c") & t->tracking;
-#ifdef HAVE_BKTR
-	struct ast_bt *bt = NULL;
-#endif
 
 #if defined(AST_MUTEX_INIT_W_CONSTRUCTORS) && defined(CAN_COMPARE_MUTEX_TO_INIT_VALUE)
 	if ((t->mutex) == ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)) {
@@ -514,33 +545,20 @@
 			__dump_backtrace(&lt->backtrace[ROFFSET], canlog);
 #endif
 			DO_THREAD_CRASH;
+		} else if (lt->reentrancy <= 0) {
+			__ast_mutex_logger("%s line %d (%s): attempted to wait on an unlocked mutex '%s'\n",
+					   filename, lineno, func, mutex_name);
+			DO_THREAD_CRASH;
 		}
 
-		if (--lt->reentrancy < 0) {
-			__ast_mutex_logger("%s line %d (%s): mutex '%s' freed more times than we've locked!\n",
-				   filename, lineno, func, mutex_name);
-			lt->reentrancy = 0;
-		}
-
-		if (lt->reentrancy < AST_MAX_REENTRANCY) {
-			lt->file[lt->reentrancy] = NULL;
-			lt->lineno[lt->reentrancy] = 0;
-			lt->func[lt->reentrancy] = NULL;
-			lt->thread[lt->reentrancy] = 0;
-		}
-
-#ifdef HAVE_BKTR
-		if (lt->reentrancy) {
-			bt = &lt->backtrace[lt->reentrancy - 1];
-		}
-#endif
+		/* Waiting on a condition completely suspends a recursive mutex,
+		 * even if it's been recursively locked multiple times. Make a
+		 * copy of the lock tracking, and reset reentrancy to zero */
+		lt_orig = *lt;
+		lt->reentrancy = 0;
 		ast_reentrancy_unlock(lt);
 
-#ifdef HAVE_BKTR
-		ast_remove_lock_info(t, bt);
-#else
-		ast_remove_lock_info(t);
-#endif
+		ast_suspend_lock_info(t);
 	}
 #endif /* DEBUG_THREADS */
 
@@ -552,28 +570,16 @@
 				   filename, lineno, func, strerror(res));
 		DO_THREAD_CRASH;
 	} else if (t->tracking) {
+		pthread_mutex_t reentr_mutex_orig;
 		ast_reentrancy_lock(lt);
-		if (lt->reentrancy < AST_MAX_REENTRANCY) {
-			lt->file[lt->reentrancy] = filename;
-			lt->lineno[lt->reentrancy] = lineno;
-			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
-#ifdef HAVE_BKTR
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
-			bt = &lt->backtrace[lt->reentrancy];
-#endif
-			lt->reentrancy++;
-		} else {
-			__ast_mutex_logger("%s line %d (%s): '%s' really deep reentrancy!\n",
-							   filename, lineno, func, mutex_name);
-		}
+		/* Restore lock tracking to what it was prior to the wait */
+		reentr_mutex_orig = lt->reentr_mutex;
+		*lt = lt_orig;
+		/* un-trash the mutex we just copied over */
+		lt->reentr_mutex = reentr_mutex_orig;
 		ast_reentrancy_unlock(lt);
 
-#ifdef HAVE_BKTR
-		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t, bt);
-#else
-		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t);
-#endif
+		ast_restore_lock_info(t);
 	}
 #endif /* DEBUG_THREADS */
 
@@ -588,10 +594,8 @@
 
 #ifdef DEBUG_THREADS
 	struct ast_lock_track *lt;
+	struct ast_lock_track lt_orig;
 	int canlog = strcmp(filename, "logger.c") & t->tracking;
-#ifdef HAVE_BKTR
-	struct ast_bt *bt = NULL;
-#endif
 
 #if defined(AST_MUTEX_INIT_W_CONSTRUCTORS) && defined(CAN_COMPARE_MUTEX_TO_INIT_VALUE)
 	if ((t->mutex) == ((pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER)) {
@@ -622,32 +626,20 @@
 			__dump_backtrace(&lt->backtrace[ROFFSET], canlog);
 #endif
 			DO_THREAD_CRASH;
-		}
-
-		if (--lt->reentrancy < 0) {
-			__ast_mutex_logger("%s line %d (%s): mutex '%s' freed more times than we've locked!\n",
+		} else if (lt->reentrancy <= 0) {
+			__ast_mutex_logger("%s line %d (%s): attempted to wait on an unlocked mutex '%s'\n",
 					   filename, lineno, func, mutex_name);
-			lt->reentrancy = 0;
+			DO_THREAD_CRASH;
 		}
 
-		if (lt->reentrancy < AST_MAX_REENTRANCY) {
-			lt->file[lt->reentrancy] = NULL;
-			lt->lineno[lt->reentrancy] = 0;
-			lt->func[lt->reentrancy] = NULL;
-			lt->thread[lt->reentrancy] = 0;
-		}
-#ifdef HAVE_BKTR
-		if (lt->reentrancy) {
-			bt = &lt->backtrace[lt->reentrancy - 1];
-		}
-#endif
+		/* Waiting on a condition completely suspends a recursive mutex,
+		 * even if it's been recursively locked multiple times. Make a
+		 * copy of the lock tracking, and reset reentrancy to zero */
+		lt_orig = *lt;
+		lt->reentrancy = 0;
 		ast_reentrancy_unlock(lt);
 
-#ifdef HAVE_BKTR
-		ast_remove_lock_info(t, bt);
-#else
-		ast_remove_lock_info(t);
-#endif
+		ast_suspend_lock_info(t);
 	}
 #endif /* DEBUG_THREADS */
 
@@ -659,28 +651,16 @@
 				   filename, lineno, func, strerror(res));
 		DO_THREAD_CRASH;
 	} else if (t->tracking) {
+		pthread_mutex_t reentr_mutex_orig;
 		ast_reentrancy_lock(lt);
-		if (lt->reentrancy < AST_MAX_REENTRANCY) {
-			lt->file[lt->reentrancy] = filename;
-			lt->lineno[lt->reentrancy] = lineno;
-			lt->func[lt->reentrancy] = func;
-			lt->thread[lt->reentrancy] = pthread_self();
-#ifdef HAVE_BKTR
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
-			bt = &lt->backtrace[lt->reentrancy];
-#endif
-			lt->reentrancy++;
-		} else {
-			__ast_mutex_logger("%s line %d (%s): '%s' really deep reentrancy!\n",
-							   filename, lineno, func, mutex_name);
-		}
+		/* Restore lock tracking to what it was prior to the wait */
+		reentr_mutex_orig = lt->reentr_mutex;
+		*lt = lt_orig;
+		/* un-trash the mutex we just copied over */
+		lt->reentr_mutex = reentr_mutex_orig;
 		ast_reentrancy_unlock(lt);
 
-#ifdef HAVE_BKTR
-		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t, bt);
-#else
-		ast_store_lock_info(AST_MUTEX, filename, lineno, func, mutex_name, t);
-#endif
+		ast_suspend_lock_info(t);
 	}
 #endif /* DEBUG_THREADS */
 
@@ -882,12 +862,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_RDLOCK, filename, line, func, name, t, bt);
 #else
 		ast_store_lock_info(AST_RDLOCK, filename, line, func, name, t);
@@ -1001,12 +989,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t, bt);
 #else
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t);
@@ -1124,12 +1120,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t, bt);
 #else
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t);
@@ -1227,12 +1231,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t, bt);
 #else
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t);
@@ -1333,12 +1345,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_RDLOCK, filename, line, func, name, t, bt);
 #else
 		ast_store_lock_info(AST_RDLOCK, filename, line, func, name, t);
@@ -1403,12 +1423,20 @@
 
 	if (t->tracking) {
 #ifdef HAVE_BKTR
+		struct ast_bt tmp;
+
+		/* The implementation of backtrace() may have its own locks.
+		 * Capture the backtrace outside of the reentrancy lock to
+		 * avoid deadlocks. See ASTERISK-22455. */
+		ast_bt_get_addresses(&tmp);
+
 		ast_reentrancy_lock(lt);
 		if (lt->reentrancy != AST_MAX_REENTRANCY) {
-			ast_bt_get_addresses(&lt->backtrace[lt->reentrancy]);
+			lt->backtrace[lt->reentrancy] = tmp;
 			bt = &lt->backtrace[lt->reentrancy];
 		}
 		ast_reentrancy_unlock(lt);
+
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t, bt);
 #else
 		ast_store_lock_info(AST_WRLOCK, filename, line, func, name, t);
--- main/logger.c
+++ main/logger.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 389677 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397948 $")
 
 /* When we include logger.h again it will trample on some stuff in syslog.h, but
  * nothing we care about in here. */
@@ -1542,7 +1542,11 @@
 	callid = ast_read_threadstorage_callid();
 
 	va_start(ap, fmt);
-	ast_log_full(level, file, line, function, callid, fmt, ap);
+	if (level == __LOG_VERBOSE) {
+		__ast_verbose_ap(file, line, function, 0, callid, fmt, ap);
+	} else {
+		ast_log_full(level, file, line, function, callid, fmt, ap);
+	}
 	va_end(ap);
 
 	if (callid) {
@@ -1593,7 +1597,7 @@
 
 char **ast_bt_get_symbols(void **addresses, size_t num_frames)
 {
-	char **strings = NULL;
+	char **strings;
 #if defined(BETTER_BACKTRACES)
 	int stackfr;
 	bfd *bfdobj;           /* bfd.h */
@@ -1613,9 +1617,12 @@
 
 #if defined(BETTER_BACKTRACES)
 	strings_size = num_frames * sizeof(*strings);
-	eachlen = ast_calloc(num_frames, sizeof(*eachlen));
 
-	if (!(strings = ast_calloc(num_frames, sizeof(*strings)))) {
+	eachlen = ast_calloc(num_frames, sizeof(*eachlen));
+	strings = ast_std_calloc(num_frames, sizeof(*strings));
+	if (!eachlen || !strings) {
+		ast_free(eachlen);
+		ast_std_free(strings);
 		return NULL;
 	}
 
@@ -1630,6 +1637,7 @@
 
 		if (strcmp(dli.dli_fname, "asterisk") == 0) {
 			char asteriskpath[256];
+
 			if (!(dli.dli_fname = ast_utils_which("asterisk", asteriskpath, sizeof(asteriskpath)))) {
 				/* This will fail to find symbols */
 				ast_debug(1, "Failed to find asterisk binary for debug symbols.\n");
@@ -1638,11 +1646,11 @@
 		}
 
 		lastslash = strrchr(dli.dli_fname, '/');
-		if (	(bfdobj = bfd_openr(dli.dli_fname, NULL)) &&
-				bfd_check_format(bfdobj, bfd_object) &&
-				(allocsize = bfd_get_symtab_upper_bound(bfdobj)) > 0 &&
-				(syms = ast_malloc(allocsize)) &&
-				(symbolcount = bfd_canonicalize_symtab(bfdobj, syms))) {
+		if ((bfdobj = bfd_openr(dli.dli_fname, NULL)) &&
+			bfd_check_format(bfdobj, bfd_object) &&
+			(allocsize = bfd_get_symtab_upper_bound(bfdobj)) > 0 &&
+			(syms = ast_malloc(allocsize)) &&
+			(symbolcount = bfd_canonicalize_symtab(bfdobj, syms))) {
 
 			if (bfdobj->flags & DYNAMIC) {
 				offset = addresses[stackfr] - dli.dli_fbase;
@@ -1651,9 +1659,9 @@
 			}
 
 			for (section = bfdobj->sections; section; section = section->next) {
-				if (	!bfd_get_section_flags(bfdobj, section) & SEC_ALLOC ||
-						section->vma > offset ||
-						section->size + section->vma < offset) {
+				if (!bfd_get_section_flags(bfdobj, section) & SEC_ALLOC ||
+					section->vma > offset ||
+					section->size + section->vma < offset) {
 					continue;
 				}
 
@@ -1668,7 +1676,9 @@
 				found++;
 				if ((lastslash = strrchr(file, '/'))) {
 					const char *prevslash;
-					for (prevslash = lastslash - 1; *prevslash != '/' && prevslash >= file; prevslash--);
+
+					for (prevslash = lastslash - 1; *prevslash != '/' && prevslash >= file; prevslash--) {
+					}
 					if (prevslash >= file) {
 						lastslash = prevslash;
 					}
@@ -1690,9 +1700,7 @@
 		}
 		if (bfdobj) {
 			bfd_close(bfdobj);
-			if (syms) {
-				ast_free(syms);
-			}
+			ast_free(syms);
 		}
 
 		/* Default output, if we cannot find the information within BFD */
@@ -1712,27 +1720,31 @@
 
 		if (!ast_strlen_zero(msg)) {
 			char **tmp;
-			eachlen[stackfr] = strlen(msg);
-			if (!(tmp = ast_realloc(strings, strings_size + eachlen[stackfr] + 1))) {
-				ast_free(strings);
+
+			eachlen[stackfr] = strlen(msg) + 1;
+			if (!(tmp = ast_std_realloc(strings, strings_size + eachlen[stackfr]))) {
+				ast_std_free(strings);
 				strings = NULL;
 				break; /* out of stack frame iteration */
 			}
 			strings = tmp;
 			strings[stackfr] = (char *) strings + strings_size;
-			ast_copy_string(strings[stackfr], msg, eachlen[stackfr] + 1);
-			strings_size += eachlen[stackfr] + 1;
+			strcpy(strings[stackfr], msg);/* Safe since we just allocated the room. */
+			strings_size += eachlen[stackfr];
 		}
 	}
 
 	if (strings) {
-		/* Recalculate the offset pointers */
+		/* Recalculate the offset pointers because of the reallocs. */
 		strings[0] = (char *) strings + num_frames * sizeof(*strings);
 		for (stackfr = 1; stackfr < num_frames; stackfr++) {
-			strings[stackfr] = strings[stackfr - 1] + eachlen[stackfr - 1] + 1;
+			strings[stackfr] = strings[stackfr - 1] + eachlen[stackfr - 1];
 		}
 	}
+	ast_free(eachlen);
+
 #else /* !defined(BETTER_BACKTRACES) */
+
 	strings = backtrace_symbols(addresses, num_frames);
 #endif /* defined(BETTER_BACKTRACES) */
 	return strings;
@@ -1758,9 +1770,7 @@
 			ast_debug(1, "#%d: [%p] %s\n", i - 3, bt->addresses[i], strings[i]);
 		}
 
-		/* MALLOC_DEBUG will erroneously report an error here, unless we undef the macro. */
-#undef free
-		free(strings);
+		ast_std_free(strings);
 	} else {
 		ast_debug(1, "Could not allocate memory for backtrace\n");
 	}
@@ -1999,4 +2009,3 @@
 		AST_RWLIST_UNLOCK(&logchannels);
 	}
 }
-
--- main/manager.c
+++ main/manager.c
@@ -47,7 +47,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388478 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398061 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use various ast_config_AST_* */
@@ -1652,17 +1652,22 @@
 			if (!strcasecmp(cur->action, a->argv[num])) {
 #ifdef AST_XML_DOCS
 				if (cur->docsrc == AST_XML_DOC) {
+					char *syntax = ast_xmldoc_printable(S_OR(cur->syntax, "Not available"), 1);
+					char *synopsis = ast_xmldoc_printable(S_OR(cur->synopsis, "Not available"), 1);
+					char *description = ast_xmldoc_printable(S_OR(cur->description, "Not available"), 1);
+					char *arguments = ast_xmldoc_printable(S_OR(cur->arguments, "Not available"), 1);
+					char *seealso = ast_xmldoc_printable(S_OR(cur->seealso, "Not available"), 1);
 					ast_cli(a->fd, "%s%s\n\n%s%s\n\n%s%s\n\n%s%s\n\n%s%s\n\n",
-						syntax_title,
-						ast_xmldoc_printable(S_OR(cur->syntax, "Not available"), 1),
-						synopsis_title,
-						ast_xmldoc_printable(S_OR(cur->synopsis, "Not available"), 1),
-						description_title,
-						ast_xmldoc_printable(S_OR(cur->description, "Not available"), 1),
-						arguments_title,
-						ast_xmldoc_printable(S_OR(cur->arguments, "Not available"), 1),
-						seealso_title,
-						ast_xmldoc_printable(S_OR(cur->seealso, "Not available"), 1));
+						syntax_title, syntax,
+						synopsis_title, synopsis,
+						description_title, description,
+						arguments_title, arguments,
+						seealso_title, seealso);
+					ast_free(syntax);
+					ast_free(synopsis);
+					ast_free(description);
+					ast_free(arguments);
+					ast_free(seealso);
 				} else
 #endif
 				{
@@ -7261,29 +7266,29 @@
 	ast_cli(a->fd, "Event: %s\n", a->argv[3]);
 	for (temp = item; temp; temp = temp->next) {
 		if (!ast_strlen_zero(ast_str_buffer(temp->synopsis))) {
-			ast_cli(a->fd, "%s%s\n\n",
-				synopsis_title,
-				ast_xmldoc_printable(ast_str_buffer(temp->synopsis), 1));
+			char *synopsis = ast_xmldoc_printable(ast_str_buffer(temp->synopsis), 1);
+			ast_cli(a->fd, "%s%s\n\n", synopsis_title, synopsis);
+			ast_free(synopsis);
 		}
 		if (!ast_strlen_zero(ast_str_buffer(temp->syntax))) {
-			ast_cli(a->fd, "%s%s\n\n",
-				syntax_title,
-				ast_xmldoc_printable(ast_str_buffer(temp->syntax), 1));
+			char *syntax = ast_xmldoc_printable(ast_str_buffer(temp->syntax), 1);
+			ast_cli(a->fd, "%s%s\n\n", syntax_title, syntax);
+			ast_free(syntax);
 		}
 		if (!ast_strlen_zero(ast_str_buffer(temp->description))) {
-			ast_cli(a->fd, "%s%s\n\n",
-				description_title,
-				ast_xmldoc_printable(ast_str_buffer(temp->description), 1));
+			char *description = ast_xmldoc_printable(ast_str_buffer(temp->description), 1);
+			ast_cli(a->fd, "%s%s\n\n", description_title, description);
+			ast_free(description);
 		}
 		if (!ast_strlen_zero(ast_str_buffer(temp->arguments))) {
-			ast_cli(a->fd, "%s%s\n\n",
-				arguments_title,
-				ast_xmldoc_printable(ast_str_buffer(temp->arguments), 1));
+			char *arguments = ast_xmldoc_printable(ast_str_buffer(temp->arguments), 1);
+			ast_cli(a->fd, "%s%s\n\n", arguments_title, arguments);
+			ast_free(arguments);
 		}
 		if (!ast_strlen_zero(ast_str_buffer(temp->seealso))) {
-			ast_cli(a->fd, "%s%s\n\n",
-				seealso_title,
-				ast_xmldoc_printable(ast_str_buffer(temp->seealso), 1));
+			char *seealso = ast_xmldoc_printable(ast_str_buffer(temp->seealso), 1);
+			ast_cli(a->fd, "%s%s\n\n", seealso_title, seealso);
+			ast_free(seealso);
 		}
 	}
 
--- main/named_acl.c
+++ main/named_acl.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377340 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $")
 
 #include "asterisk/config.h"
 #include "asterisk/config_options.h"
@@ -555,10 +555,20 @@
 	AST_CLI_DEFINE(handle_show_named_acl_cmd, "Show a named ACL or list all named ACLs"),
 };
 
+static void named_acl_cleanup(void)
+{
+	ast_cli_unregister_multiple(cli_named_acl, ARRAY_LEN(cli_named_acl));
+
+	aco_info_destroy(&cfg_info);
+	ao2_global_obj_release(globals);
+}
+
 int ast_named_acl_init()
 {
 	ast_cli_register_multiple(cli_named_acl, ARRAY_LEN(cli_named_acl));
 
+	ast_register_atexit(named_acl_cleanup);
+
 	if (aco_info_init(&cfg_info)) {
 		return 0;
 	}
--- main/pbx.c
+++ main/pbx.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388578 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_SYSTEM_NAME */
@@ -11332,10 +11332,9 @@
 		headp = &globals;
 	}
 
-	if (value) {
+	if (value && (newvariable = ast_var_assign(name, value))) {
 		if (headp == &globals)
 			ast_verb(2, "Setting global variable '%s' to '%s'\n", name, value);
-		newvariable = ast_var_assign(name, value);
 		AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 	}
 
@@ -11382,10 +11381,9 @@
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 
-	if (value) {
+	if (value && (newvariable = ast_var_assign(name, value))) {
 		if (headp == &globals)
 			ast_verb(2, "Setting global variable '%s' to '%s'\n", name, value);
-		newvariable = ast_var_assign(name, value);
 		AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 		/*** DOCUMENTATION
 			<managerEventInstance>
--- main/threadstorage.c
+++ main/threadstorage.c
@@ -38,7 +38,7 @@
 
 #else /* !defined(DEBUG_THREADLOCALS) */
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370655 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397107 $")
 
 #include "asterisk/strings.h"
 #include "asterisk/utils.h"
@@ -249,10 +249,16 @@
 	AST_CLI_DEFINE(handle_cli_threadstorage_show_summary,     "Summarize outstanding memory allocations")
 };
 
+static void threadstorage_shutdown(void)
+{
+	ast_cli_unregister_multiple(cli, ARRAY_LEN(cli));
+}
+
 void threadstorage_init(void)
 {
 	pthread_mutex_init(&threadstoragelock, NULL);
 	ast_cli_register_multiple(cli, ARRAY_LEN(cli));
+	ast_register_atexit(threadstorage_shutdown);
 }
 
 #endif /* !defined(DEBUG_THREADLOCALS) */
--- main/translate.c
+++ main/translate.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 370055 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $")
 
 #include <sys/time.h>
 #include <sys/resource.h>
@@ -1396,11 +1396,27 @@
 	ast_format_cap_iter_end(src);
 }
 
+static void translate_shutdown(void)
+{
+	int x;
+	ast_cli_unregister_multiple(cli_translate, ARRAY_LEN(cli_translate));
+
+	ast_rwlock_wrlock(&tablelock);
+	for (x = 0; x < index_size; x++) {
+		ast_free(__matrix[x]);
+	}
+	ast_free(__matrix);
+	ast_free(__indextable);
+	ast_rwlock_unlock(&tablelock);
+	ast_rwlock_destroy(&tablelock);
+}
+
 int ast_translate_init(void)
 {
 	int res = 0;
 	ast_rwlock_init(&tablelock);
 	res = matrix_resize(1);
 	res |= ast_cli_register_multiple(cli_translate, ARRAY_LEN(cli_translate));
+	ast_register_atexit(translate_shutdown);
 	return res;
 }
--- main/udptl.c
+++ main/udptl.c
@@ -54,7 +54,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377849 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397365 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -1419,8 +1419,15 @@
 
 static void __ast_udptl_reload(int reload)
 {
+	RAII_VAR(struct udptl_config *, udptl_cfg, udptl_snapshot_alloc(), ao2_cleanup);
+
 	if (aco_process_config(&cfg_info, reload) == ACO_PROCESS_ERROR) {
-		ast_log(LOG_WARNING, "Could not reload udptl config\n");
+		if (!reload) {
+			if (!aco_set_defaults(&general_option, "general", udptl_cfg->general)) {
+				ast_log(LOG_WARNING, "Could not load udptl config; using defaults\n");
+				ao2_global_obj_replace(globals, udptl_cfg);
+			}
+		}
 	}
 }
 
--- main/utils.c
+++ main/utils.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 387295 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398649 $")
 
 #include <ctype.h>
 #include <sys/stat.h>
@@ -603,6 +603,8 @@
 		enum ast_lock_type type;
 		/*! This thread is waiting on this lock */
 		int pending:2;
+		/*! A condition has suspended this lock */
+		int suspended:1;
 #ifdef HAVE_BKTR
 		struct ast_bt *backtrace;
 #endif
@@ -789,6 +791,60 @@
 	return 0;
 }
 
+void ast_suspend_lock_info(void *lock_addr)
+{
+	struct thr_lock_info *lock_info;
+	int i = 0;
+
+	if (!(lock_info = ast_threadstorage_get(&thread_lock_info, sizeof(*lock_info)))) {
+		return;
+	}
+
+	pthread_mutex_lock(&lock_info->lock);
+
+	for (i = lock_info->num_locks - 1; i >= 0; i--) {
+		if (lock_info->locks[i].lock_addr == lock_addr)
+			break;
+	}
+
+	if (i == -1) {
+		/* Lock not found :( */
+		pthread_mutex_unlock(&lock_info->lock);
+		return;
+	}
+
+	lock_info->locks[i].suspended = 1;
+
+	pthread_mutex_unlock(&lock_info->lock);
+}
+
+void ast_restore_lock_info(void *lock_addr)
+{
+	struct thr_lock_info *lock_info;
+	int i = 0;
+
+	if (!(lock_info = ast_threadstorage_get(&thread_lock_info, sizeof(*lock_info))))
+		return;
+
+	pthread_mutex_lock(&lock_info->lock);
+
+	for (i = lock_info->num_locks - 1; i >= 0; i--) {
+		if (lock_info->locks[i].lock_addr == lock_addr)
+			break;
+	}
+
+	if (i == -1) {
+		/* Lock not found :( */
+		pthread_mutex_unlock(&lock_info->lock);
+		return;
+	}
+
+	lock_info->locks[i].suspended = 0;
+
+	pthread_mutex_unlock(&lock_info->lock);
+}
+
+
 #ifdef HAVE_BKTR
 void ast_remove_lock_info(void *lock_addr, struct ast_bt *bt)
 #else
@@ -869,7 +925,7 @@
 			ast_str_append(str, 0, "\t%s\n", symbols[frame_iterator]);
 		}
 
-		free(symbols);
+		ast_std_free(symbols);
 	} else {
 		ast_str_append(str, 0, "\tCouldn't retrieve backtrace symbols\n");
 	}
@@ -882,7 +938,7 @@
 	ast_mutex_t *lock;
 	struct ast_lock_track *lt;
 
-	ast_str_append(str, 0, "=== ---> %sLock #%d (%s): %s %d %s %s %p (%d)\n",
+	ast_str_append(str, 0, "=== ---> %sLock #%d (%s): %s %d %s %s %p (%d%s)\n",
 				   lock_info->locks[i].pending > 0 ? "Waiting for " :
 				   lock_info->locks[i].pending < 0 ? "Tried and failed to get " : "", i,
 				   lock_info->locks[i].file,
@@ -890,7 +946,8 @@
 				   lock_info->locks[i].line_num,
 				   lock_info->locks[i].func, lock_info->locks[i].lock_name,
 				   lock_info->locks[i].lock_addr,
-				   lock_info->locks[i].times_locked);
+				   lock_info->locks[i].times_locked,
+				   lock_info->locks[i].suspended ? " - suspended" : "");
 #ifdef HAVE_BKTR
 	append_backtrace_information(str, lock_info->locks[i].backtrace);
 #endif
@@ -999,20 +1056,32 @@
 	pthread_mutex_lock(&lock_infos_lock.mutex);
 	AST_LIST_TRAVERSE(&lock_infos, lock_info, entry) {
 		int i;
-		if (lock_info->num_locks) {
-			ast_str_append(&str, 0, "=== Thread ID: 0x%lx (%s)\n", (long) lock_info->thread_id,
-				lock_info->thread_name);
-			pthread_mutex_lock(&lock_info->lock);
-			for (i = 0; str && i < lock_info->num_locks; i++) {
-				append_lock_information(&str, lock_info, i);
+		int header_printed = 0;
+		pthread_mutex_lock(&lock_info->lock);
+		for (i = 0; str && i < lock_info->num_locks; i++) {
+			/* Don't show suspended locks */
+			if (lock_info->locks[i].suspended) {
+				continue;
 			}
-			pthread_mutex_unlock(&lock_info->lock);
-			if (!str)
-				break;
+
+			if (!header_printed) {
+				ast_str_append(&str, 0, "=== Thread ID: 0x%lx (%s)\n", (long) lock_info->thread_id,
+					lock_info->thread_name);
+				header_printed = 1;
+			}
+
+			append_lock_information(&str, lock_info, i);
+		}
+		pthread_mutex_unlock(&lock_info->lock);
+		if (!str) {
+			break;
+		}
+		if (header_printed) {
 			ast_str_append(&str, 0, "=== -------------------------------------------------------------------\n"
-			               "===\n");
-			if (!str)
-				break;
+				"===\n");
+		}
+		if (!str) {
+			break;
 		}
 	}
 	pthread_mutex_unlock(&lock_infos_lock.mutex);
--- main/xmldoc.c
+++ main/xmldoc.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 377511 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"
@@ -578,8 +578,11 @@
  */
 static void __attribute__((format(printf, 4, 5))) xmldoc_reverse_helper(int reverse, int *len, char **syntax, const char *fmt, ...)
 {
-	int totlen, tmpfmtlen;
-	char *tmpfmt, tmp;
+	int totlen;
+	int tmpfmtlen;
+	char *tmpfmt;
+	char *new_syntax;
+	char tmp;
 	va_list ap;
 
 	va_start(ap, fmt);
@@ -592,12 +595,12 @@
 	tmpfmtlen = strlen(tmpfmt);
 	totlen = *len + tmpfmtlen + 1;
 
-	*syntax = ast_realloc(*syntax, totlen);
-
-	if (!*syntax) {
+	new_syntax = ast_realloc(*syntax, totlen);
+	if (!new_syntax) {
 		ast_free(tmpfmt);
 		return;
 	}
+	*syntax = new_syntax;
 
 	if (reverse) {
 		memmove(*syntax + tmpfmtlen, *syntax, *len);
@@ -759,6 +762,7 @@
 				if ((paramtype = ast_xml_get_attribute(node, "required"))) {
 					if (!ast_true(paramtype)) {
 						optmidnode = 1;
+						ast_xml_free_attr(paramtype);
 						break;
 					}
 					ast_xml_free_attr(paramtype);
--- pbx/pbx_dundi.c
+++ pbx/pbx_dundi.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388378 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/network.h"
 #include <sys/ioctl.h>
@@ -598,14 +598,18 @@
 			ast_eid_to_str(dr[anscnt].eid_str, sizeof(dr[anscnt].eid_str), &dr[anscnt].eid);
 			if (ast_test_flag(&flags, DUNDI_FLAG_EXISTS)) {
 				AST_LIST_HEAD_INIT_NOLOCK(&headp);
-				newvariable = ast_var_assign("NUMBER", called_number);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-				newvariable = ast_var_assign("EID", dr[anscnt].eid_str);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-				newvariable = ast_var_assign("SECRET", cursecret);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-				newvariable = ast_var_assign("IPADDR", ipaddr);
-				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				if ((newvariable = ast_var_assign("NUMBER", called_number))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
+				if ((newvariable = ast_var_assign("EID", dr[anscnt].eid_str))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
+				if ((newvariable = ast_var_assign("SECRET", cursecret))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
+				if ((newvariable = ast_var_assign("IPADDR", ipaddr))) {
+					AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+				}
 				pbx_substitute_variables_varshead(&headp, map->dest, dr[anscnt].dest, sizeof(dr[anscnt].dest));
 				dr[anscnt].weight = get_mapping_weight(map, &headp);
 				while ((newvariable = AST_LIST_REMOVE_HEAD(&headp, entries)))
--- pbx/pbx_loopback.c
+++ pbx/pbx_loopback.c
@@ -28,7 +28,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 361155 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396287 $")
 
 #include "asterisk/file.h"
 #include "asterisk/logger.h"
@@ -91,12 +91,15 @@
 
 	snprintf(tmp, sizeof(tmp), "%d", priority);
 	AST_LIST_HEAD_INIT_NOLOCK(&headp);
-	newvariable = ast_var_assign("EXTEN", exten);
-	AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-	newvariable = ast_var_assign("CONTEXT", context);
-	AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
-	newvariable = ast_var_assign("PRIORITY", tmp);
-	AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	if ((newvariable = ast_var_assign("EXTEN", exten))) {
+		AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	}
+	if ((newvariable = ast_var_assign("CONTEXT", context))) {
+		AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	}
+	if ((newvariable = ast_var_assign("PRIORITY", tmp))) {
+		AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
+	}
 	/* Substitute variables */
 	pbx_substitute_variables_varshead(&headp, data, buf, buflen);
 	/* free the list */
--- res/Makefile
+++ res/Makefile
@@ -9,7 +9,7 @@
 # the GNU General Public License
 #
 
--include $(ASTTOPDIR)/menuselect.makeopts $(ASTTOPDIR)/menuselect.makedeps
+-include $(ASTTOPDIR)/menuselect.makeopts $(ASTTOPDIR)/menuselect.makedeps $(ASTTOPDIR)/build_tools/menuselect-deps
 
 MODULE_PREFIX=res
 MENUSELECT_CATEGORY=RES
@@ -86,7 +86,10 @@
 $(PJ_LIB_FILES): FORCE
 	$(MAKE) -C $(patsubst %/lib/,%,$(dir $@))/build/ ../lib/$(notdir $@)
 
+ifeq ($(subst 1:0,1,$(UUID)), 1)
 res_rtp_asterisk.o: $(PJ_LIB_FILES)
+res_rtp_asterisk.o: _ASTCFLAGS+=-DUSE_PJPROJECT
 res_rtp_asterisk.o: _ASTCFLAGS+=$(PJ_CFLAGS)
 res_rtp_asterisk.so: _ASTLDFLAGS+=$(PJ_LDFLAGS)
 res_rtp_asterisk.so: LIBS+=$(PJ_LDLIBS)
+endif
\ No newline at end of file
--- res/res_agi.c
+++ res/res_agi.c
@@ -31,7 +31,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 381893 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398061 $")
 
 #include <math.h>
 #include <signal.h>
@@ -2007,8 +2007,8 @@
 	}
 
 	if (!(fs = ast_openstream(chan, argv[2], ast_channel_language(chan)))) {
-		ast_agi_send(agi->fd, chan, "200 result=%d endpos=%ld\n", 0, sample_offset);
-		return RESULT_SUCCESS;
+		ast_agi_send(agi->fd, chan, "200 result=-1 endpos=%ld\n", sample_offset);
+		return RESULT_FAILURE;
 	}
 
 	if ((vfs = ast_openvstream(chan, argv[2], ast_channel_language(chan)))) {
@@ -2065,9 +2065,9 @@
 	}
 
 	if (!(fs = ast_openstream(chan, argv[2], ast_channel_language(chan)))) {
-		ast_agi_send(agi->fd, chan, "200 result=%d endpos=%ld\n", 0, sample_offset);
+		ast_agi_send(agi->fd, chan, "200 result=-1 endpos=%ld\n", sample_offset);
 		ast_log(LOG_WARNING, "Unable to open %s\n", argv[2]);
-		return RESULT_SUCCESS;
+		return RESULT_FAILURE;
 	}
 
 	if ((vfs = ast_openvstream(chan, argv[2], ast_channel_language(chan))))
@@ -3841,9 +3841,6 @@
 
 	AST_RWLIST_RDLOCK(&agi_commands);
 	AST_RWLIST_TRAVERSE(&agi_commands, command, list) {
-#ifdef AST_XML_DOCS
-		char *stringptmp;
-#endif
 		char *tempstr, *stringp;
 
 		if (!command->cmda[0])	/* end ? */
@@ -3856,8 +3853,7 @@
 		fprintf(htmlfile, "<TR><TD><TABLE BORDER=\"1\" CELLPADDING=\"5\" WIDTH=\"100%%\">\n");
 		fprintf(htmlfile, "<TR><TH ALIGN=\"CENTER\"><B>%s - %s</B></TH></TR>\n", fullcmd, command->summary);
 #ifdef AST_XML_DOCS
-		stringptmp = ast_xmldoc_printable(command->usage, 0);
-		stringp = ast_strdup(stringptmp);
+		stringp = ast_xmldoc_printable(command->usage, 0);
 #else
 		stringp = ast_strdup(command->usage);
 #endif
@@ -3875,9 +3871,6 @@
 		fprintf(htmlfile, "</TD></TR>\n");
 		fprintf(htmlfile, "</TABLE></TD></TR>\n\n");
 		ast_free(stringp);
-#ifdef AST_XML_DOCS
-		ast_free(stringptmp);
-#endif
 	}
 	AST_RWLIST_UNLOCK(&agi_commands);
 	fprintf(htmlfile, "</TABLE>\n</BODY>\n</HTML>\n");
--- res/res_calendar.c
+++ res/res_calendar.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 378321 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 392810 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/calendar.h"
@@ -1810,6 +1810,8 @@
 
 	/* Remove all calendars */
 	ao2_callback(calendars, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
+	ao2_cleanup(calendars);
+	calendars = NULL;
 
 	ast_mutex_lock(&refreshlock);
 	module_unloading = 1;
--- res/res_http_websocket.c
+++ res/res_http_websocket.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 376561 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391560 $")
 
 #include "asterisk/module.h"
 #include "asterisk/http.h"
@@ -544,9 +544,18 @@
 		/* Version 7 defined in specification http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07 */
 		/* Version 8 defined in specification http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10 */
 		/* Version 13 defined in specification http://tools.ietf.org/html/rfc6455 */
-		char combined[strlen(key) + strlen(WEBSOCKET_GUID) + 1], base64[64];
+		char *combined, base64[64];
+		unsigned combined_length;
 		uint8_t sha[20];
 
+		combined_length = (key ? strlen(key) : 0) + strlen(WEBSOCKET_GUID) + 1;
+		if (!key || combined_length > 8192) { /* no stack overflows please */
+			fputs("HTTP/1.1 400 Bad Request\r\n"
+			      "Sec-WebSocket-Version: 7, 8, 13\r\n\r\n", ser->f);
+			ao2_ref(protocol_handler, -1);
+			return 0;
+		}
+
 		if (!(session = ao2_alloc(sizeof(*session), session_destroy_fn))) {
 			ast_log(LOG_WARNING, "WebSocket connection from '%s' could not be accepted\n",
 				ast_sockaddr_stringify(&ser->remote_address));
@@ -556,7 +565,8 @@
 			return 0;
 		}
 
-		snprintf(combined, sizeof(combined), "%s%s", key, WEBSOCKET_GUID);
+		combined = ast_alloca(combined_length);
+		snprintf(combined, combined_length, "%s%s", key, WEBSOCKET_GUID);
 		ast_sha1_hash_uint(sha, combined);
 		ast_base64encode(base64, (const unsigned char*)sha, 20, sizeof(base64));
 
--- res/res_jabber.c
+++ res/res_jabber.c
@@ -40,7 +40,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 385917 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398577 $")
 
 #include <ctype.h>
 #include <iksemel.h>
@@ -3319,7 +3319,7 @@
  */
 static int aji_handle_pubsub_event(void *data, ikspak *pak)
 {
-	char *item_id, *device_state, *context, *cachable_str;
+	char *item_id, *device_state, *mailbox, *cachable_str;
 	int oldmsgs, newmsgs;
 	iks *item, *item_content;
 	struct ast_eid pubsub_eid;
@@ -3352,15 +3352,16 @@
 			return IKS_FILTER_EAT;
 		}
 	} else if (!strcasecmp(iks_name(item_content), "mailbox")) {
-		context = strsep(&item_id, "@");
+		mailbox = strsep(&item_id, "@");
 		sscanf(iks_find_cdata(item_content, "OLDMSGS"), "%10d", &oldmsgs);
 		sscanf(iks_find_cdata(item_content, "NEWMSGS"), "%10d", &newmsgs);
-		if (!(event = ast_event_new(AST_EVENT_MWI, AST_EVENT_IE_MAILBOX,
-			AST_EVENT_IE_PLTYPE_STR, item_id, AST_EVENT_IE_CONTEXT,
-			AST_EVENT_IE_PLTYPE_STR, context, AST_EVENT_IE_OLDMSGS,
-			AST_EVENT_IE_PLTYPE_UINT, oldmsgs, AST_EVENT_IE_NEWMSGS,
-			AST_EVENT_IE_PLTYPE_UINT, newmsgs, AST_EVENT_IE_EID, AST_EVENT_IE_PLTYPE_RAW,
-			&pubsub_eid, sizeof(pubsub_eid), AST_EVENT_IE_END))) {
+		if (!(event = ast_event_new(AST_EVENT_MWI,
+			AST_EVENT_IE_MAILBOX, AST_EVENT_IE_PLTYPE_STR, mailbox,
+			AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, item_id,
+			AST_EVENT_IE_OLDMSGS, AST_EVENT_IE_PLTYPE_UINT, oldmsgs,
+			AST_EVENT_IE_NEWMSGS, AST_EVENT_IE_PLTYPE_UINT, newmsgs,
+			AST_EVENT_IE_EID, AST_EVENT_IE_PLTYPE_RAW, &pubsub_eid, sizeof(pubsub_eid),
+			AST_EVENT_IE_END))) {
 			return IKS_FILTER_EAT;
 		}
 	} else {
--- res/res_musiconhold.c
+++ res/res_musiconhold.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 375895 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
 
 #include <ctype.h>
 #include <signal.h>
@@ -1047,20 +1047,26 @@
 static int moh_add_file(struct mohclass *class, const char *filepath)
 {
 	if (!class->allowed_files) {
-		if (!(class->filearray = ast_calloc(1, INITIAL_NUM_FILES * sizeof(*class->filearray))))
+		class->filearray = ast_calloc(1, INITIAL_NUM_FILES * sizeof(*class->filearray));
+		if (!class->filearray) {
 			return -1;
+		}
 		class->allowed_files = INITIAL_NUM_FILES;
 	} else if (class->total_files == class->allowed_files) {
-		if (!(class->filearray = ast_realloc(class->filearray, class->allowed_files * sizeof(*class->filearray) * 2))) {
-			class->allowed_files = 0;
-			class->total_files = 0;
+		char **new_array;
+
+		new_array = ast_realloc(class->filearray, class->allowed_files * sizeof(*class->filearray) * 2);
+		if (!new_array) {
 			return -1;
 		}
+		class->filearray = new_array;
 		class->allowed_files *= 2;
 	}
 
-	if (!(class->filearray[class->total_files] = ast_strdup(filepath)))
+	class->filearray[class->total_files] = ast_strdup(filepath);
+	if (!class->filearray[class->total_files]) {
 		return -1;
+	}
 
 	class->total_files++;
 
--- res/res_rtp_asterisk.c
+++ res/res_rtp_asterisk.c
@@ -29,13 +29,13 @@
  */
 
 /*** MODULEINFO
-	<depend>uuid</depend>
+	<use type="external">uuid</use>
 	<support_level>core</support_level>
  ***/
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 388112 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 397604 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -47,6 +47,7 @@
 #include <openssl/bio.h>
 #endif
 
+#ifdef USE_PJPROJECT
 /* Asterisk discourages the use of bzero in favor of memset, in fact if you try to use bzero it will tell you to use memset. As a result bzero has to be undefined
  * here since it is used internally by pjlib. The only other option would be to modify pjlib... which won't happen. */
 #undef bzero
@@ -54,6 +55,7 @@
 #include "pjlib.h"
 #include "pjlib-util.h"
 #include "pjnath.h"
+#endif
 
 #include "asterisk/stun.h"
 #include "asterisk/pbx.h"
@@ -136,6 +138,8 @@
 static int learning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL; /*< Number of sequential RTP frames needed from a single source during learning mode to accept new source. */
 static int icesupport = DEFAULT_ICESUPPORT;
 static struct sockaddr_in stunaddr;
+
+#ifdef USE_PJPROJECT
 static pj_str_t turnaddr;
 static int turnport = DEFAULT_TURN_PORT;
 static pj_str_t turnusername;
@@ -158,6 +162,7 @@
 
 /*! \brief Notification that the ICE/TURN worker thread should stop */
 static int worker_terminate;
+#endif
 
 #define FLAG_3389_WARNING               (1 << 0)
 #define FLAG_NAT_ACTIVE                 (3 << 1)
@@ -255,6 +260,7 @@
 
 	struct rtp_red *red;
 
+#ifdef USE_PJPROJECT
 	pj_ice_sess *ice;           /*!< ICE session */
 	pj_turn_sock *turn_rtp;     /*!< RTP TURN relay */
 	pj_turn_sock *turn_rtcp;    /*!< RTCP TURN relay */
@@ -272,6 +278,7 @@
 
 	struct ao2_container *local_candidates;   /*!< The local ICE candidates */
 	struct ao2_container *remote_candidates;  /*!< The remote ICE candidates */
+#endif
 
 #ifdef HAVE_OPENSSL_SRTP
 	SSL_CTX *ssl_ctx; /*!< SSL context */
@@ -399,6 +406,7 @@
 
 static int __rtp_sendto(struct ast_rtp_instance *instance, void *buf, size_t size, int flags, struct ast_sockaddr *sa, int rtcp, int *ice, int use_srtp);
 
+#ifdef USE_PJPROJECT
 /*! \brief Destructor for locally created ICE candidates */
 static void ast_rtp_ice_candidate_destroy(void *obj)
 {
@@ -697,6 +705,7 @@
 	.get_local_candidates = ast_rtp_ice_get_local_candidates,
 	.ice_lite = ast_rtp_ice_lite,
 };
+#endif
 
 #ifdef HAVE_OPENSSL_SRTP
 static void dtls_info_callback(const SSL *ssl, int where, int ret)
@@ -1024,7 +1033,9 @@
 	.stop = ast_rtp_stop,
 	.qos = ast_rtp_qos_set,
 	.sendcng = ast_rtp_sendcng,
+#ifdef USE_PJPROJECT
 	.ice = &ast_rtp_ice,
+#endif
 #ifdef HAVE_OPENSSL_SRTP
 	.dtls = &ast_rtp_dtls,
 	.activate = ast_rtp_activate,
@@ -1033,6 +1044,7 @@
 
 static void rtp_learning_seq_init(struct rtp_learning_info *info, uint16_t seq);
 
+#ifdef USE_PJPROJECT
 static void ast_rtp_on_ice_complete(pj_ice_sess *ice, pj_status_t status)
 {
 	struct ast_rtp *rtp = ice->user_data;
@@ -1200,6 +1212,7 @@
 
 	return 0;
 }
+#endif
 
 static inline int rtp_debug_test_addr(struct ast_sockaddr *addr)
 {
@@ -1454,6 +1467,7 @@
 	}
 #endif
 
+#ifdef USE_PJPROJECT
 	if (rtp->ice) {
 		pj_str_t combined = pj_str(ast_sockaddr_stringify(sa));
 		pj_sockaddr address;
@@ -1479,6 +1493,7 @@
 		}
 		rtp->passthrough = 0;
 	}
+#endif
 
 	if ((*in & 0xC0) && res_srtp && srtp && res_srtp->unprotect(srtp, buf, &len, rtcp) < 0) {
 	   return -1;
@@ -1510,6 +1525,7 @@
 		return -1;
 	}
 
+#ifdef USE_PJPROJECT
 	if (rtp->ice) {
 		pj_thread_register_check();
 
@@ -1518,6 +1534,7 @@
 			return 0;
 		}
 	}
+#endif
 
 	return ast_sendto(rtcp ? rtp->rtcp->s : rtp->s, temp, len, flags, sa);
 }
@@ -1635,6 +1652,7 @@
 	return (info->packets == 0);
 }
 
+#ifdef USE_PJPROJECT
 static void rtp_add_candidates_to_ice(struct ast_rtp_instance *instance, struct ast_rtp *rtp, struct ast_sockaddr *addr, int port, int component,
 				      int transport, const pj_turn_sock_cb *turn_cb, pj_turn_sock **turn_sock)
 {
@@ -1699,6 +1717,7 @@
 		}
 	}
 }
+#endif
 
 static int ast_rtp_new(struct ast_rtp_instance *instance,
 		       struct ast_sched_context *sched, struct ast_sockaddr *addr,
@@ -1706,17 +1725,21 @@
 {
 	struct ast_rtp *rtp = NULL;
 	int x, startplace;
+#ifdef USE_PJPROJECT
 	pj_stun_config stun_config;
 	pj_str_t ufrag, passwd;
+#endif
 
 	/* Create a new RTP structure to hold all of our data */
 	if (!(rtp = ast_calloc(1, sizeof(*rtp)))) {
 		return -1;
 	}
 
+#ifdef USE_PJPROJECT
 	/* Initialize synchronization aspects */
 	ast_mutex_init(&rtp->lock);
 	ast_cond_init(&rtp->cond, NULL);
+#endif
 
 	/* Set default parameters on the newly created RTP structure */
 	rtp->ssrc = ast_random();
@@ -1765,6 +1788,9 @@
 		}
 	}
 
+	ast_rtp_instance_set_data(instance, rtp);
+
+#ifdef USE_PJPROJECT
 	pj_thread_register_check();
 
 	pj_stun_config_init(&stun_config, &cachingpool.factory, 0, ioqueue, timerheap);
@@ -1774,8 +1800,6 @@
 	generate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));
 	passwd = pj_str(rtp->local_passwd);
 
-	ast_rtp_instance_set_data(instance, rtp);
-
 	/* Create an ICE session for ICE negotiation */
 	if (icesupport && pj_ice_sess_create(&stun_config, NULL, PJ_ICE_SESS_ROLE_UNKNOWN, 2, &ast_rtp_ice_sess_cb, &ufrag, &passwd, &rtp->ice) == PJ_SUCCESS) {
 		/* Make this available for the callbacks */
@@ -1784,6 +1808,7 @@
 		/* Add all of the available candidates to the ICE session */
 		rtp_add_candidates_to_ice(instance, rtp, addr, x, COMPONENT_RTP, TRANSPORT_SOCKET_RTP, &ast_rtp_turn_rtp_sock_cb, &rtp->turn_rtp);
 	}
+#endif
 
 	/* Record any information we may need */
 	rtp->sched = sched;
@@ -1826,6 +1851,7 @@
 		ast_free(rtp->red);
 	}
 
+#ifdef USE_PJPROJECT
 	pj_thread_register_check();
 
 	/* Destroy the ICE session if being used */
@@ -1854,6 +1880,11 @@
 		ao2_ref(rtp->remote_candidates, -1);
 	}
 
+	/* Destroy synchronization items */
+	ast_mutex_destroy(&rtp->lock);
+	ast_cond_destroy(&rtp->cond);
+#endif
+
 #ifdef HAVE_OPENSSL_SRTP
 	/* Destroy the SSL context if present */
 	if (rtp->ssl_ctx) {
@@ -1866,10 +1897,6 @@
 	}
 #endif
 
-	/* Destroy synchronization items */
-	ast_mutex_destroy(&rtp->lock);
-	ast_cond_destroy(&rtp->cond);
-
 	/* Finally destroy ourselves */
 	ast_free(rtp);
 
@@ -1943,7 +1970,9 @@
 				ast_sockaddr_stringify(&remote_address),
 				strerror(errno));
 		}
+#ifdef USE_PJPROJECT
 		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+#endif
 		if (rtp_debug_test_addr(&remote_address)) {
 			ast_verbose("Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
 				    ast_sockaddr_stringify(&remote_address),
@@ -1993,7 +2022,9 @@
 			strerror(errno));
 	}
 
+#ifdef USE_PJPROJECT
 	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+#endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
 		ast_verbose("Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
@@ -2068,7 +2099,9 @@
 				strerror(errno));
 		}
 
+#ifdef USE_PJPROJECT
 		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+#endif
 
 		if (rtp_debug_test_addr(&remote_address)) {
 			ast_verbose("Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
@@ -2251,7 +2284,9 @@
 
 	rtp->rtcp->rr_count++;
 
+#ifdef USE_PJPROJECT
 	update_address_with_ice_candidate(rtp, COMPONENT_RTCP, &remote_address);
+#endif
 
 	if (rtcp_debug_test_addr(&remote_address)) {
 		ast_verbose("\n* Sending RTCP RR to %s%s\n"
@@ -2362,7 +2397,9 @@
 
 	rtp->rtcp->lastsrtxcount = rtp->txcount;
 
+#ifdef USE_PJPROJECT
 	update_address_with_ice_candidate(rtp, COMPONENT_RTCP, &remote_address);
+#endif
 
 	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
 		ast_verbose("* Sent RTCP SR to %s%s\n", ast_sockaddr_stringify(&remote_address), ice ? " (via ICE)" : "");
@@ -2551,7 +2588,9 @@
 			}
 		}
 
+#ifdef USE_PJPROJECT
 		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+#endif
 
 		if (rtp_debug_test_addr(&remote_address)) {
 			ast_verbose("Sent RTP packet to      %s%s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
@@ -3430,7 +3469,9 @@
 		return 0;
 	}
 
+#ifdef USE_PJPROJECT
 	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+#endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
 		ast_verbose("Sent RTP P2P packet to %s%s (type %-2.2d, len %-6.6u)\n",
@@ -3879,10 +3920,12 @@
 			ast_debug(1, "Setup RTCP on RTP instance '%p'\n", instance);
 			rtp->rtcp->schedid = -1;
 
+#ifdef USE_PJPROJECT
 			if (rtp->ice) {
 				rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP,
 							  &ast_rtp_turn_rtcp_sock_cb, &rtp->turn_rtcp);
 			}
+#endif
 
 			return;
 		} else {
@@ -4171,7 +4214,9 @@
 		return res;
 	}
 
+#ifdef USE_PJPROJECT
 	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+#endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
 		ast_verbose("Sent Comfort Noise RTP packet to %s%s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
@@ -4361,11 +4406,13 @@
 	 */
 
 	icesupport = DEFAULT_ICESUPPORT;
-	turnport = DEFAULT_TURN_PORT;
 	memset(&stunaddr, 0, sizeof(stunaddr));
+#ifdef USE_PJPROJECT
+	turnport = DEFAULT_TURN_PORT;
 	turnaddr = pj_str(NULL);
 	turnusername = pj_str(NULL);
 	turnpassword = pj_str(NULL);
+#endif
 
 	if (cfg) {
 		if ((s = ast_variable_retrieve(cfg, "general", "rtpstart"))) {
@@ -4425,6 +4472,7 @@
 				ast_log(LOG_WARNING, "Invalid STUN server address: %s\n", s);
 			}
 		}
+#ifdef USE_PJPROJECT
 		if ((s = ast_variable_retrieve(cfg, "general", "turnaddr"))) {
 			struct sockaddr_in addr;
 			addr.sin_port = htons(DEFAULT_TURN_PORT);
@@ -4443,6 +4491,7 @@
 		if ((s = ast_variable_retrieve(cfg, "general", "turnpassword"))) {
 			pj_strdup2(pool, &turnpassword, s);
 		}
+#endif
 		ast_config_destroy(cfg);
 	}
 	if (rtpstart >= rtpend) {
@@ -4462,6 +4511,7 @@
 
 static int load_module(void)
 {
+#ifdef USE_PJPROJECT
 	pj_lock_t *lock;
 
 	pj_log_set_level(0);
@@ -4509,23 +4559,28 @@
 		pj_shutdown();
 		return AST_MODULE_LOAD_DECLINE;
 	}
+#endif
 
 	if (ast_rtp_engine_register(&asterisk_rtp_engine)) {
+#ifdef USE_PJPROJECT
 		worker_terminate = 1;
 		pj_thread_join(thread);
 		pj_thread_destroy(thread);
 		pj_caching_pool_destroy(&cachingpool);
 		pj_shutdown();
+#endif
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
 	if (ast_cli_register_multiple(cli_rtp, ARRAY_LEN(cli_rtp))) {
+#ifdef USE_PJPROJECT
 		worker_terminate = 1;
 		pj_thread_join(thread);
 		pj_thread_destroy(thread);
 		ast_rtp_engine_unregister(&asterisk_rtp_engine);
 		pj_caching_pool_destroy(&cachingpool);
 		pj_shutdown();
+#endif
 		return AST_MODULE_LOAD_DECLINE;
 	}
 
@@ -4539,6 +4594,7 @@
 	ast_rtp_engine_unregister(&asterisk_rtp_engine);
 	ast_cli_unregister_multiple(cli_rtp, ARRAY_LEN(cli_rtp));
 
+#ifdef USE_PJPROJECT
 	worker_terminate = 1;
 
 	pj_thread_register_check();
@@ -4548,6 +4604,7 @@
 
 	pj_caching_pool_destroy(&cachingpool);
 	pj_shutdown();
+#endif
 
 	return 0;
 }
--- res/res_security_log.c
+++ res/res_security_log.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 328259 $");
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $");
 
 #include "asterisk/module.h"
 #include "asterisk/logger.h"
@@ -159,6 +159,8 @@
 		security_event_sub = ast_event_unsubscribe(security_event_sub);
 	}
 
+	ast_logger_unregister_level(LOG_SECURITY_NAME);
+
 	ast_verb(3, "Security Logging Disabled\n");
 
 	return 0;
--- res/res_xmpp.c
+++ res/res_xmpp.c
@@ -39,7 +39,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 385938 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398618 $")
 
 #include <ctype.h>
 #include <iksemel.h>
@@ -1309,7 +1309,7 @@
  */
 static int xmpp_pubsub_handle_event(void *data, ikspak *pak)
 {
-	char *item_id, *device_state, *context, *cachable_str;
+	char *item_id, *device_state, *mailbox, *cachable_str;
 	int oldmsgs, newmsgs;
 	iks *item, *item_content;
 	struct ast_eid pubsub_eid;
@@ -1341,15 +1341,16 @@
 			return IKS_FILTER_EAT;
 		}
 	} else if (!strcasecmp(iks_name(item_content), "mailbox")) {
-		context = strsep(&item_id, "@");
+		mailbox = strsep(&item_id, "@");
 		sscanf(iks_find_cdata(item_content, "OLDMSGS"), "%10d", &oldmsgs);
 		sscanf(iks_find_cdata(item_content, "NEWMSGS"), "%10d", &newmsgs);
-		if (!(event = ast_event_new(AST_EVENT_MWI, AST_EVENT_IE_MAILBOX,
-					    AST_EVENT_IE_PLTYPE_STR, item_id, AST_EVENT_IE_CONTEXT,
-					    AST_EVENT_IE_PLTYPE_STR, context, AST_EVENT_IE_OLDMSGS,
-					    AST_EVENT_IE_PLTYPE_UINT, oldmsgs, AST_EVENT_IE_NEWMSGS,
-					    AST_EVENT_IE_PLTYPE_UINT, newmsgs, AST_EVENT_IE_EID, AST_EVENT_IE_PLTYPE_RAW,
-					    &pubsub_eid, sizeof(pubsub_eid), AST_EVENT_IE_END))) {
+		if (!(event = ast_event_new(AST_EVENT_MWI,
+			AST_EVENT_IE_MAILBOX, AST_EVENT_IE_PLTYPE_STR, mailbox,
+			AST_EVENT_IE_CONTEXT, AST_EVENT_IE_PLTYPE_STR, item_id,
+			AST_EVENT_IE_OLDMSGS, AST_EVENT_IE_PLTYPE_UINT, oldmsgs,
+			AST_EVENT_IE_NEWMSGS, AST_EVENT_IE_PLTYPE_UINT, newmsgs,
+			AST_EVENT_IE_EID, AST_EVENT_IE_PLTYPE_RAW, &pubsub_eid, sizeof(pubsub_eid),
+			AST_EVENT_IE_END))) {
 			return IKS_FILTER_EAT;
 		}
 	} else {
@@ -2418,13 +2419,7 @@
 	}
 
 	if (!incoming) {
-		if (strlen(xmpp) == 1) {
-			if (option_debug > 2  && xmpp[0] == ' ') {
-				ast_verbose("\n<--- XMPP keep alive from '%s' --->\n", client->name);
-			}
-		} else {
-			ast_verbose("\n<--- XMPP sent to '%s' --->\n%s\n<------------->\n", client->name, xmpp);
-		}
+		ast_verbose("\n<--- XMPP sent to '%s' --->\n%s\n<------------->\n", client->name, xmpp);
 	} else {
 		ast_verbose("\n<--- XMPP received from '%s' --->\n%s\n<------------->\n", client->name, xmpp);
 	}
@@ -3109,6 +3104,40 @@
 	return res;
 }
 
+/*! \brief Helper function which sends a ping request to a server */
+static int xmpp_ping_request(struct ast_xmpp_client *client, const char *to, const char *from)
+{
+	iks *iq, *ping;
+	int res;
+	
+	ast_debug(2, "JABBER: Sending Keep-Alive Ping for client '%s'\n", client->name);
+
+	if (!(iq = iks_new("iq")) || !(ping = iks_new("ping"))) {
+		iks_delete(iq);
+		return -1;
+	}
+	
+	iks_insert_attrib(iq, "type", "get");
+	iks_insert_attrib(iq, "to", to);
+	iks_insert_attrib(iq, "from", from);
+	
+	ast_xmpp_client_lock(client);
+	iks_insert_attrib(iq, "id", client->mid);
+	ast_xmpp_increment_mid(client->mid);
+	ast_xmpp_client_unlock(client);
+	
+	iks_insert_attrib(ping, "xmlns", "urn:xmpp:ping");
+	iks_insert_node(iq, ping);
+	
+	res = ast_xmpp_client_send(client, iq);
+	
+	iks_delete(ping);
+	iks_delete(iq);
+
+
+	return res;
+}
+
 /*! \brief Internal function called when a presence message is received */
 static int xmpp_pak_presence(struct ast_xmpp_client *client, struct ast_xmpp_client_config *cfg, iks *node, ikspak *pak)
 {
@@ -3405,6 +3434,7 @@
 /*! \brief Internal function used to reconnect an XMPP client to its server */
 static int xmpp_client_reconnect(struct ast_xmpp_client *client)
 {
+	struct timeval tv = { .tv_sec = 5, .tv_usec = 0 };
 	RAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);
 	RAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);
 	int res = IKS_NET_NOCONN;
@@ -3427,6 +3457,9 @@
 	res = iks_connect_via(client->parser, S_OR(clientcfg->server, client->jid->server), clientcfg->port,
 			      ast_test_flag(&clientcfg->flags, XMPP_COMPONENT) ? clientcfg->user : client->jid->server);
 
+	/* Set socket timeout options */
+	setsockopt(iks_fd(client->parser), SOL_SOCKET, SO_RCVTIMEO, (char *)&tv,sizeof(struct timeval));
+	
 	if (res == IKS_NET_NOCONN) {
 		ast_log(LOG_ERROR, "No XMPP connection available when trying to connect client '%s'\n", client->name);
 		return -1;
@@ -3511,6 +3544,14 @@
 		/* Log the message here, because iksemel's logHook is
 		   unaccessible */
 		xmpp_log_hook(client, buf, len, 1);
+		
+		if(buf[0] == ' ') {
+			ast_debug(1, "JABBER: Detected Google Keep Alive. "
+				"Sending out Ping request for client '%s'\n", client->name);
+			/* If we just send out the ping here then we will have socket
+			 * read errors because the socket will timeout */
+			xmpp_ping_request(client, client->jid->server, client->jid->full);
+		}
 
 		/* let iksemel deal with the string length,
 		   and reset our buffer */
@@ -3544,6 +3585,7 @@
 
 	do {
 		if (client->state == XMPP_STATE_DISCONNECTING) {
+			ast_debug(1, "JABBER: Disconnecting client '%s'\n", client->name);
 			break;
 		}
 
@@ -3572,8 +3614,12 @@
 			RAII_VAR(struct xmpp_config *, cfg, ao2_global_obj_ref(globals), ao2_cleanup);
 			RAII_VAR(struct ast_xmpp_client_config *, clientcfg, NULL, ao2_cleanup);
 
-			if (cfg && cfg->clients && (clientcfg = xmpp_config_find(cfg->clients, client->name))) {
-				res = ast_test_flag(&clientcfg->flags, XMPP_KEEPALIVE) ? xmpp_client_send_raw_message(client, " ") : IKS_OK;
+			if (cfg && cfg->clients) {
+				clientcfg = xmpp_config_find(cfg->clients, client->name);
+			}
+
+			if (clientcfg && ast_test_flag(&clientcfg->flags, XMPP_KEEPALIVE)) {
+				res = xmpp_ping_request(client, client->jid->server, client->jid->full);
 			} else {
 				res = IKS_OK;
 			}
@@ -3585,6 +3631,18 @@
 			}
 		} else if (res == IKS_NET_RWERR) {
 			ast_log(LOG_WARNING, "JABBER: socket read error\n");
+		} else if (res == IKS_NET_NOSOCK) {
+			ast_log(LOG_WARNING, "JABBER: No Socket\n");
+		} else if (res == IKS_NET_NOCONN) {
+			ast_log(LOG_WARNING, "JABBER: No Connection\n");
+		} else if (res == IKS_NET_NODNS) {
+			ast_log(LOG_WARNING, "JABBER: No DNS\n");
+		} else if (res == IKS_NET_NOTSUPP) {
+			ast_log(LOG_WARNING, "JABBER: Not Supported\n");
+		} else if (res == IKS_NET_DROPPED) {
+			ast_log(LOG_WARNING, "JABBER: Dropped?\n");
+		} else {
+			ast_debug(5, "JABBER: Unknown\n");
 		}
 
 	} while (1);
--- tests/test_hashtab_thrash.c
+++ tests/test_hashtab_thrash.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 376339 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 396657 $")
 #include <pthread.h>
 #include "asterisk/hashtab.h"
 #include "asterisk/lock.h"
@@ -197,8 +197,10 @@
 		ast_hashtab_end_traversal(it);
 
 		if (last_count == count) {
-			/* Allow other threads to run. */
-			sched_yield();
+			/* Give other threads ample chance to run, note that using sched_yield here does not
+			 * provide enough of a chance and can cause this thread to starve others.
+			 */
+			usleep(1);
 		} else if (last_count > count) {
 			/* Make sure the hashtable never shrinks */
 			return "hashtab unexpectedly shrank";
--- tests/test_substitution.c
+++ tests/test_substitution.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 357542 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398019 $")
 
 #include "asterisk/file.h"
 #include "asterisk/channel.h"
@@ -53,16 +53,17 @@
 	char workspace[4096];
 	struct ast_str *str = ast_str_create(16);
 
-	ast_test_status_update(test, "Testing '%s' . . . . . %s\n", expression, okay ? "passed" : "FAILED");
 	for (i = 0; i < 256; i++) {
 		*ifield = i;
 		ast_str_substitute_variables(&str, 0, c, expression);
 		pbx_substitute_variables_helper(c, expression, workspace, sizeof(workspace));
+
 		if (sscanf(workspace, "%d", &value1) != 1 || value1 != i || sscanf(ast_str_buffer(str), "%d", &value2) != 1 || value2 != i) {
 			ast_test_status_update(test, "%s != %s and/or %d != %d != %d\n", ast_str_buffer(str), workspace, value1, value2, i);
 			okay = 0;
 		}
 	}
+	ast_test_status_update(test, "Tested '%s' . . . . . %s\n", expression, okay ? "passed" : "FAILED");
 
 	ast_free(str);
 
@@ -76,16 +77,17 @@
 	char workspace[4096];
 	struct ast_str *str = ast_str_create(16);
 
-	ast_test_status_update(test, "Testing '%s' . . . . . %s\n", expression, okay ? "passed" : "FAILED");
 	for (i = 0; i < 256; i++) {
 		setter(c, i);
 		ast_str_substitute_variables(&str, 0, c, expression);
 		pbx_substitute_variables_helper(c, expression, workspace, sizeof(workspace));
+
 		if (sscanf(workspace, "%d", &value1) != 1 || value1 != i || sscanf(ast_str_buffer(str), "%d", &value2) != 1 || value2 != i) {
 			ast_test_status_update(test, "%s != %s and/or %d != %d != %d\n", ast_str_buffer(str), workspace, value1, value2, i);
 			okay = 0;
 		}
 	}
+	ast_test_status_update(test, "Tested '%s' . . . . . %s\n", expression, okay ? "passed" : "FAILED");
 
 	ast_free(str);
 
@@ -105,13 +107,14 @@
 		setter(c, values[i]);
 		ast_str_substitute_variables(&str, 0, c, expression);
 		pbx_substitute_variables_helper(c, expression, workspace, sizeof(workspace));
-		ast_test_status_update(test, "Testing '%s' . . . . . %s\n",
-				expression, okay ? "passed" : "FAILED");
+
 		if (strcmp(getter(c), ast_str_buffer(str)) != 0 || strcmp(getter(c), workspace) != 0) {
 			ast_test_status_update(test, "%s != %s != %s\n", getter(c), ast_str_buffer(str), workspace);
 			okay = 0;
 		}
 	}
+	ast_test_status_update(test, "Tested '%s' . . . . . %s\n",
+		expression, okay ? "passed" : "FAILED");
 
 	ast_free(str);
 
@@ -132,14 +135,15 @@
 		pbx_builtin_setvar_helper(c, varname, values[i]);
 		ast_str_substitute_variables(&str, 0, c, ast_str_buffer(var));
 		pbx_substitute_variables_helper(c, ast_str_buffer(var), workspace, sizeof(workspace));
-		ast_test_status_update(test, "Testing '%s' . . . . . %s\n",
-				ast_str_buffer(var), okay ? "passed" : "FAILED");
+
 		if (strcmp(values[i], ast_str_buffer(str)) != 0 || strcmp(values[i], workspace) != 0) {
 			ast_test_status_update(test, "%s != %s != %s\n",
 					values[i], ast_str_buffer(str), workspace);
 			okay = 0;
 		}
 	}
+	ast_test_status_update(test, "Tested '%s' . . . . . %s\n",
+		ast_str_buffer(var), okay ? "passed" : "FAILED");
 
 	ast_free(str);
 	ast_free(var);
@@ -156,13 +160,14 @@
 
 	ast_str_substitute_variables(&str, 0, c, expression);
 	pbx_substitute_variables_helper(c, expression, workspace, sizeof(workspace));
-	ast_test_status_update(test, "Testing '%s' . . . . . %s\n",
-			expression, okay ? "passed" : "FAILED");
+
 	if (strcmp(workspace, ast_str_buffer(str)) != 0) {
-		ast_test_status_update(test, "test_chan_function, expr: '%s' ... %s != %s\n",
+		ast_test_status_update(test, "expr: '%s' ... %s != %s\n",
 				expression, ast_str_buffer(str), workspace);
 		okay = 0;
 	}
+	ast_test_status_update(test, "Tested '%s' . . . . . %s\n",
+		expression, okay ? "passed" : "FAILED");
 
 	ast_free(str);
 
@@ -182,15 +187,13 @@
 	ast_str_substitute_variables(&str, 0, c, ast_str_buffer(expression));
 
 	okay = !strcmp(ast_str_buffer(str), "foobarbaz");
-
-	ast_test_status_update(test, "Testing '%s%s' and '%s%s' . . . . . %s\n",
-			encode1, encode2, decode1, decode2,
-			okay ? "passed" : "FAILED");
-
 	if (!okay) {
-		ast_test_status_update(test, "  '%s' != 'foobarbaz'\n",
+		ast_test_status_update(test, "'%s' != 'foobarbaz'\n",
 				ast_str_buffer(str));
 	}
+	ast_test_status_update(test, "Tested '%s%s' and '%s%s' . . . . . %s\n",
+		encode1, encode2, decode1, decode2,
+		okay ? "passed" : "FAILED");
 
 	ast_free(str);
 
@@ -204,16 +207,15 @@
 	int okay;
 
 	ast_str_substitute_variables(&str, 0, c, expression);
-	okay = !strcmp(ast_str_buffer(str), result);
-
-	ast_test_status_update(test, "Testing '%s' ('%s') == '%s' . . . . . %s\n",
-			ast_str_buffer(str), expression, result,
-			okay ? "passed" : "FAILED");
 
+	okay = !strcmp(ast_str_buffer(str), result);
 	if (!okay) {
-		ast_test_status_update(test, "test_expected_result: '%s' != '%s'\n",
+		ast_test_status_update(test, "'%s' != '%s'\n",
 				ast_str_buffer(str), result);
 	}
+	ast_test_status_update(test, "Tested '%s' ('%s') == '%s' . . . . . %s\n",
+		ast_str_buffer(str), expression, result,
+		okay ? "passed" : "FAILED");
 
 	ast_free(str);
 
@@ -287,6 +289,7 @@
 	TEST(test_expected_result(test, c, "${LISTFILTER(list1,&,cd)}", "ab&ef"));
 	TEST(test_expected_result(test, c, "${SHELL(printf '%d' 123)},${SHELL(printf '%d' 456)}", "123,456"));
 	TEST(test_expected_result(test, c, "${foo},${CDR(answer)},${SHELL(printf '%d' 456)}", "123,,456"));
+	TEST(test_expected_result(test, c, "${foo},${CDR(answer,u)},${SHELL(printf '%d' 456)}", "123,0.000000,456"));
 	TEST(test_expected_result(test, c, "${foo},${this_does_not_exist},${THIS_DOES_NOT_EXIST(either)}", "123,,"));
 #undef TEST
 
--- utils/ael_main.c
+++ utils/ael_main.c
@@ -18,7 +18,7 @@
 #include <regex.h>
 #include <limits.h>
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 358812 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398749 $")
 
 #include "asterisk/channel.h"
 #include "asterisk/ast_expr.h"
@@ -647,5 +647,11 @@
 {
 }
 #endif /* HAVE_BKTR */
+void ast_suspend_lock_info(void *lock_addr)
+{
+}
+void ast_restore_lock_info(void *lock_addr)
+{
+}
 #endif /* !defined(LOW_MEMORY) */
 #endif /* DEBUG_THREADS */
--- utils/check_expr.c
+++ utils/check_expr.c
@@ -21,7 +21,7 @@
  ***/
 
 #include "asterisk.h"
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 328259 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398753 $")
 
 #include "asterisk/ast_expr.h"
 
@@ -55,6 +55,7 @@
 }
 #endif
 
+#ifdef DEBUG_THREADS
 #if !defined(LOW_MEMORY)
 #ifdef HAVE_BKTR
 void ast_store_lock_info(enum ast_lock_type type, const char *filename,
@@ -105,12 +106,20 @@
 }
 #endif /* HAVE_BKTR */
 
+void ast_suspend_lock_info(void *lock_addr)
+{
+}
+void ast_restore_lock_info(void *lock_addr)
+{
+}
 void ast_mark_lock_acquired(void *);
 void ast_mark_lock_acquired(void *foo)
 {
     /* not a lot to do in a standalone w/o threading! */
 }
 #endif
+#endif /* DEBUG_THREADS */
+
 
 static int global_lineno = 1;
 static int global_expr_count=0;
--- utils/conf2ael.c
+++ utils/conf2ael.c
@@ -28,7 +28,7 @@
  ***/
 
 #include "asterisk.h"
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 358812 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398749 $")
 
 #include "asterisk/paths.h"	/* CONFIG_DIR */
 #include <locale.h>
@@ -777,5 +777,11 @@
 {
 }
 #endif /* HAVE_BKTR */
+void ast_suspend_lock_info(void *lock_addr)
+{
+}
+void ast_restore_lock_info(void *lock_addr)
+{
+}
 #endif /* !defined(LOW_MEMORY) */
 #endif /* DEBUG_THREADS */
--- utils/extconf.c
+++ utils/extconf.c
@@ -3149,10 +3149,9 @@
 		}
 	}
 
-	if (value) {
+	if (value && (newvariable = ast_var_assign(name, value))) {
 		if ((option_verbose > 1) && (headp == &globals))
 			ast_verbose(VERBOSE_PREFIX_2 "Setting global variable '%s' to '%s'\n", name, value);
-		newvariable = ast_var_assign(name, value);
 		AST_LIST_INSERT_HEAD(headp, newvariable, entries);
 	}
 
