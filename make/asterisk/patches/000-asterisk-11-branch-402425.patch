--- apps/app_confbridge.c
+++ apps/app_confbridge.c
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 400741 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402425 $")
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -960,6 +960,32 @@
 	return 0;
 }
 
+void conf_update_user_mute(struct conference_bridge_user *user)
+{
+	int mute_user;
+	int mute_system;
+	int mute_effective;
+
+	/* User level mute request. */
+	mute_user = user->muted;
+
+	/* System level mute request. */
+	mute_system = user->playing_moh
+		/*
+		 * Do not allow waitmarked users to talk to anyone unless there
+		 * is a marked user present.
+		 */
+		|| (!user->conference_bridge->markedusers
+			&& ast_test_flag(&user->u_profile, USER_OPT_WAITMARKED));
+
+	mute_effective = mute_user || mute_system;
+
+	ast_debug(1, "User %s is %s: user:%d system:%d.\n",
+		ast_channel_name(user->chan), mute_effective ? "muted" : "unmuted",
+		mute_user, mute_system);
+	user->features.mute = mute_effective;
+}
+
 void conf_moh_stop(struct conference_bridge_user *user)
 {
 	user->playing_moh = 0;
@@ -1105,9 +1131,7 @@
 	if (ast_test_flag(&first_participant->u_profile, USER_OPT_MUSICONHOLD)) {
 		conf_moh_stop(first_participant);
 	}
-	if (!ast_test_flag(&first_participant->u_profile, USER_OPT_STARTMUTED)) {
-		first_participant->features.mute = 0;
-	}
+	conf_update_user_mute(first_participant);
 }
 
 void conf_ended(struct conference_bridge *conference_bridge)
@@ -1652,7 +1676,8 @@
 
 	/* If the caller should be joined already muted, make it so */
 	if (ast_test_flag(&conference_bridge_user.u_profile, USER_OPT_STARTMUTED)) {
-		conference_bridge_user.features.mute = 1;
+		/* Set user level mute request. */
+		conference_bridge_user.muted = 1;
 	}
 
 	if (ast_test_flag(&conference_bridge_user.u_profile, USER_OPT_DROP_SILENCE)) {
@@ -1769,12 +1794,23 @@
 	struct conference_bridge_user *conference_bridge_user,
 	struct ast_channel *chan)
 {
-	/* Mute or unmute yourself, note we only allow manipulation if they aren't waiting for a marked user or if marked users exist */
-	if (!ast_test_flag(&conference_bridge_user->u_profile, USER_OPT_WAITMARKED) || conference_bridge->markedusers) {
-		conference_bridge_user->features.mute = (!conference_bridge_user->features.mute ? 1 : 0);
-		ast_test_suite_event_notify("CONF_MUTE", "Message: participant %s %s\r\nConference: %s\r\nChannel: %s", ast_channel_name(chan), conference_bridge_user->features.mute ? "muted" : "unmuted", conference_bridge_user->b_profile.name, ast_channel_name(chan));
-	}
-	return ast_stream_and_wait(chan, (conference_bridge_user->features.mute ?
+	int mute;
+
+	/* Toggle user level mute request. */
+	mute = !conference_bridge_user->muted;
+	conference_bridge_user->muted = mute;
+
+	conf_update_user_mute(conference_bridge_user);
+	ast_test_suite_event_notify("CONF_MUTE",
+		"Message: participant %s %s\r\n"
+		"Conference: %s\r\n"
+		"Channel: %s",
+		ast_channel_name(chan),
+		mute ? "muted" : "unmuted",
+		conference_bridge_user->b_profile.name,
+		ast_channel_name(chan));
+
+	return ast_stream_and_wait(chan, (mute ?
 		conf_get_sound(CONF_SOUND_MUTED, conference_bridge_user->b_profile.sounds) :
 		conf_get_sound(CONF_SOUND_UNMUTED, conference_bridge_user->b_profile.sounds)),
 		"");
@@ -1784,22 +1820,27 @@
 {
 	struct conference_bridge_user *participant = NULL;
 	const char *sound_to_play;
+	int mute;
 
 	ao2_lock(conference_bridge);
 
-	/* If already muted, then unmute */
-	conference_bridge->muted = conference_bridge->muted ? 0 : 1;
-	sound_to_play = conf_get_sound((conference_bridge->muted ? CONF_SOUND_PARTICIPANTS_MUTED : CONF_SOUND_PARTICIPANTS_UNMUTED),
-		conference_bridge_user->b_profile.sounds);
+	/* Toggle bridge level mute request. */
+	mute = !conference_bridge->muted;
+	conference_bridge->muted = mute;
 
 	AST_LIST_TRAVERSE(&conference_bridge->active_list, participant, list) {
 		if (!ast_test_flag(&participant->u_profile, USER_OPT_ADMIN)) {
-			participant->features.mute = conference_bridge->muted;
+			/* Set user level to bridge level mute request. */
+			participant->muted = mute;
+			conf_update_user_mute(participant);
 		}
 	}
 
 	ao2_unlock(conference_bridge);
 
+	sound_to_play = conf_get_sound((mute ? CONF_SOUND_PARTICIPANTS_MUTED : CONF_SOUND_PARTICIPANTS_UNMUTED),
+		conference_bridge_user->b_profile.sounds);
+
 	/* The host needs to hear it seperately, as they don't get the audio from play_sound_helper */
 	ast_stream_and_wait(conference_bridge_user->chan, sound_to_play, "");
 
@@ -2219,12 +2260,14 @@
 
 static void handle_cli_confbridge_list_item(struct ast_cli_args *a, struct conference_bridge_user *participant)
 {
-	ast_cli(a->fd, "%-29s ", ast_channel_name(participant->chan));
-	ast_cli(a->fd, "%-17s", participant->u_profile.name);
-	ast_cli(a->fd, "%-17s", participant->b_profile.name);
-	ast_cli(a->fd, "%-17s", participant->menu_name);
-	ast_cli(a->fd, "%-17s", S_COR(ast_channel_caller(participant->chan)->id.number.valid, ast_channel_caller(participant->chan)->id.number.str, "<unknown>"));
-	ast_cli(a->fd, "\n");
+	ast_cli(a->fd, "%-30s %-16s %-16s %-16s %-16s %s\n",
+		ast_channel_name(participant->chan),
+		participant->u_profile.name,
+		participant->b_profile.name,
+		participant->menu_name,
+		S_COR(ast_channel_caller(participant->chan)->id.number.valid,
+			ast_channel_caller(participant->chan)->id.number.str, "<unknown>"),
+		AST_CLI_YESNO(participant->muted));
 }
 
 static char *handle_cli_confbridge_list(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
@@ -2267,8 +2310,8 @@
 			ast_cli(a->fd, "No conference bridge named '%s' found!\n", a->argv[2]);
 			return CLI_SUCCESS;
 		}
-		ast_cli(a->fd, "Channel                       User Profile     Bridge Profile   Menu             CallerID\n");
-		ast_cli(a->fd, "============================= ================ ================ ================ ================\n");
+		ast_cli(a->fd, "Channel                        User Profile     Bridge Profile   Menu             CallerID         Muted\n");
+		ast_cli(a->fd, "============================== ================ ================ ================ ================ =====\n");
 		ao2_lock(bridge);
 		AST_LIST_TRAVERSE(&bridge->active_list, participant, list) {
 			handle_cli_confbridge_list_item(a, participant);
@@ -2335,8 +2378,18 @@
 		}
 	}
 	if (participant) {
-		participant->features.mute = mute;
-		ast_test_suite_event_notify("CONF_MUTE", "Message: participant %s %s\r\nConference: %s\r\nChannel: %s", ast_channel_name(participant->chan), participant->features.mute ? "muted" : "unmuted", bridge->b_profile.name, ast_channel_name(participant->chan));
+		/* Set user level mute request. */
+		participant->muted = mute ? 1 : 0;
+
+		conf_update_user_mute(participant);
+		ast_test_suite_event_notify("CONF_MUTE",
+			"Message: participant %s %s\r\n"
+			"Conference: %s\r\n"
+			"Channel: %s",
+			ast_channel_name(participant->chan),
+			mute ? "muted" : "unmuted",
+			bridge->b_profile.name,
+			ast_channel_name(participant->chan));
 	} else {
 		res = -2;;
 	}
@@ -2596,6 +2649,7 @@
 		"Channel: %s\r\n"
 		"Admin: %s\r\n"
 		"MarkedUser: %s\r\n"
+		"Muted: %s\r\n"
 		"\r\n",
 		id_text,
 		bridge->name,
@@ -2603,7 +2657,8 @@
 		S_COR(ast_channel_caller(participant->chan)->id.name.valid, ast_channel_caller(participant->chan)->id.name.str, "<no name>"),
 		ast_channel_name(participant->chan),
 		ast_test_flag(&participant->u_profile, USER_OPT_ADMIN) ? "Yes" : "No",
-		ast_test_flag(&participant->u_profile, USER_OPT_MARKEDUSER) ? "Yes" : "No");
+		ast_test_flag(&participant->u_profile, USER_OPT_MARKEDUSER) ? "Yes" : "No",
+		participant->muted ? "Yes" : "No");
 }
 
 static int action_confbridgelist(struct mansession *s, const struct message *m)
@@ -3051,11 +3106,11 @@
 {
 	struct conference_bridge_user *only_participant = AST_LIST_FIRST(&conference_bridge->active_list);
 
-	/* Turn on MOH/mute if the single participant is set up for it */
+	/* Turn on MOH if the single participant is set up for it */
 	if (ast_test_flag(&only_participant->u_profile, USER_OPT_MUSICONHOLD)) {
-		only_participant->features.mute = 1;
 		conf_moh_start(only_participant);
 	}
+	conf_update_user_mute(only_participant);
 }
 
 void conf_remove_user_waiting(struct conference_bridge *conference_bridge, struct conference_bridge_user *cbu)
--- apps/confbridge/conf_state.c
+++ apps/confbridge/conf_state.c
@@ -57,12 +57,11 @@
  */
 static void conf_mute_moh_inactive_waitmarked(struct conference_bridge_user *user)
 {
-	/* Be sure we are muted so we can't talk to anybody else waiting */
-	user->features.mute = 1;
 	/* Start music on hold if needed */
 	if (ast_test_flag(&user->u_profile, USER_OPT_MUSICONHOLD)) {
 		conf_moh_start(user);
 	}
+	conf_update_user_mute(user);
 }
 
 void conf_default_join_waitmarked(struct conference_bridge_user *cbu)
--- apps/confbridge/conf_state_inactive.c
+++ apps/confbridge/conf_state_inactive.c
@@ -61,7 +61,7 @@
 static void join_marked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
-	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/conf_state_multi.c
+++ apps/confbridge/conf_state_multi.c
@@ -54,11 +54,13 @@
 static void join_unmarked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 }
 
 static void join_marked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/conf_state_multi_marked.c
+++ apps/confbridge/conf_state_multi_marked.c
@@ -60,11 +60,13 @@
 static void join_active(struct conference_bridge_user *cbu)
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 }
 
 static void join_marked(struct conference_bridge_user *cbu)
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
+	conf_update_user_mute(cbu);
 }
 
 static void leave_active(struct conference_bridge_user *cbu)
@@ -95,8 +97,8 @@
 		AST_LIST_TRAVERSE_SAFE_BEGIN(&cbu->conference_bridge->active_list, cbu_iter, list) {
 			/* Kick ENDMARKED cbu_iters */
 			if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_ENDMARKED)) {
-				if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED) &&
-						  !ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
+				if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED)
+					&& !ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
 					AST_LIST_REMOVE_CURRENT(list);
 					cbu_iter->conference_bridge->activeusers--;
 					AST_LIST_INSERT_TAIL(&cbu_iter->conference_bridge->waiting_list, cbu_iter, list);
@@ -104,17 +106,18 @@
 				}
 				cbu_iter->kicked = 1;
 				ast_bridge_remove(cbu_iter->conference_bridge->bridge, cbu_iter->chan);
-			} else if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED) &&
-					!ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
+			} else if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_WAITMARKED)
+				&& !ast_test_flag(&cbu_iter->u_profile, USER_OPT_MARKEDUSER)) {
 				AST_LIST_REMOVE_CURRENT(list);
 				cbu_iter->conference_bridge->activeusers--;
 				AST_LIST_INSERT_TAIL(&cbu_iter->conference_bridge->waiting_list, cbu_iter, list);
 				cbu_iter->conference_bridge->waitingusers++;
-				/* Handle muting/moh of cbu_iter if necessary */
+
+				/* Handle moh of cbu_iter if necessary */
 				if (ast_test_flag(&cbu_iter->u_profile, USER_OPT_MUSICONHOLD)) {
-					cbu_iter->features.mute = 1;
 					conf_moh_start(cbu_iter);
 				}
+				conf_update_user_mute(cbu_iter);
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
@@ -170,7 +173,7 @@
 		conf_handle_first_marked_common(cbu);
 	}
 
-	/* Move all waiting users to active, stopping MOH and umuting if necessary */
+	/* Move all waiting users to active, stopping MOH and unmuting if necessary */
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&cbu->conference_bridge->waiting_list, cbu_iter, list) {
 		AST_LIST_REMOVE_CURRENT(list);
 		cbu->conference_bridge->waitingusers--;
@@ -179,10 +182,7 @@
 		if (cbu_iter->playing_moh) {
 			conf_moh_stop(cbu_iter);
 		}
-		/* only unmute them if they are not supposed to start muted */
-		if (!ast_test_flag(&cbu_iter->u_profile, USER_OPT_STARTMUTED)) {
-			cbu_iter->features.mute = 0;
-		}
+		conf_update_user_mute(cbu_iter);
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
 }
--- apps/confbridge/conf_state_single.c
+++ apps/confbridge/conf_state_single.c
@@ -55,6 +55,7 @@
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI);
 }
@@ -63,6 +64,7 @@
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/conf_state_single_marked.c
+++ apps/confbridge/conf_state_single_marked.c
@@ -54,6 +54,7 @@
 {
 	conf_add_user_active(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
@@ -62,6 +63,7 @@
 {
 	conf_add_user_marked(cbu->conference_bridge, cbu);
 	conf_handle_second_active(cbu->conference_bridge);
+	conf_update_user_mute(cbu);
 
 	conf_change_state(cbu, CONF_STATE_MULTI_MARKED);
 }
--- apps/confbridge/include/confbridge.h
+++ apps/confbridge/include/confbridge.h
@@ -210,7 +210,7 @@
 	unsigned int markedusers;                                         /*!< Number of marked users present */
 	unsigned int waitingusers;                                        /*!< Number of waiting users present */
 	unsigned int locked:1;                                            /*!< Is this conference bridge locked? */
-	unsigned int muted:1;                                            /*!< Is this conference bridge muted? */
+	unsigned int muted:1;                                             /*!< Is this conference bridge muted? */
 	unsigned int record_state:2;                                      /*!< Whether recording is started, stopped, or should exit */
 	struct ast_channel *playback_chan;                                /*!< Channel used for playback into the conference bridge */
 	struct ast_channel *record_chan;                                  /*!< Channel used for recording the conference */
@@ -238,6 +238,7 @@
 	struct ast_bridge_features features;         /*!< Bridge features structure */
 	struct ast_bridge_tech_optimizations tech_args; /*!< Bridge technology optimizations for talk detection */
 	unsigned int suspended_moh;                  /*!< Count of active suspended MOH actions. */
+	unsigned int muted:1;                        /*!< Has the user requested to be muted? */
 	unsigned int kicked:1;                       /*!< User has been kicked from the conference */
 	unsigned int playing_moh:1;                  /*!< MOH is currently being played to the user */
 	AST_LIST_HEAD_NOLOCK(, post_join_action) post_join_list; /*!< List of sounds to play after joining */;
@@ -364,6 +365,15 @@
 void conf_ended(struct conference_bridge *conference_bridge);
 
 /*!
+ * \brief Update the actual mute status of the user and set it on the bridge.
+ *
+ * \param user User to update the mute status.
+ *
+ * \return Nothing
+ */
+void conf_update_user_mute(struct conference_bridge_user *user);
+
+/*!
  * \brief Stop MOH for the conference user.
  *
  * \param user Conference user to stop MOH on.
--- channels/chan_sip.c
+++ channels/chan_sip.c
@@ -210,7 +210,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401884 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402345 $")
 
 #include <signal.h>
 #include <sys/signal.h>
@@ -12616,7 +12616,13 @@
 	while ((candidate = ao2_iterator_next(&i))) {
 		ast_str_append(a_buf, 0, "a=candidate:%s %d %s %d ", candidate->foundation, candidate->id, candidate->transport, candidate->priority);
 		ast_str_append(a_buf, 0, "%s ", ast_sockaddr_stringify_host(&candidate->address));
-		ast_str_append(a_buf, 0, "%s typ ", ast_sockaddr_stringify_port(&candidate->address));
+
+		if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_SRFLX
+			&& candidate->id == AST_RTP_ICE_COMPONENT_RTCP) {
+			ast_str_append(a_buf, 0, "%d typ ", ast_sockaddr_port(&candidate->address) + 1);
+		} else {
+			ast_str_append(a_buf, 0, "%s typ ", ast_sockaddr_stringify_port(&candidate->address));
+		}
 
 		if (candidate->type == AST_RTP_ICE_CANDIDATE_TYPE_HOST) {
 			ast_str_append(a_buf, 0, "host");
@@ -19019,7 +19025,7 @@
 }
 
 /* the last argument is left-aligned, so we don't need a size anyways */
-#define PEERS_FORMAT2 "%-25.25s %-39.39s %-3.3s %-10.10s %-3.3s %-8s %-11s %-32.32s %s\n"
+#define PEERS_FORMAT2 "%-25.25s %-39.39s %-3.3s %-10.10s %-10.10s %-3.3s %-8s %-11s %-32.32s %s\n"
 
 /*! \brief Used in the sip_show_peers functions to pass parameters */
 struct show_peers_context {
@@ -19081,7 +19087,7 @@
 
 	if (!s) {
 		/* Normal list */
-		ast_cli(fd, PEERS_FORMAT2, "Name/username", "Host", "Dyn", "Forcerport", "ACL", "Port", "Status", "Description", (cont.realtimepeers ? "Realtime" : ""));
+		ast_cli(fd, PEERS_FORMAT2, "Name/username", "Host", "Dyn", "Forcerport", "Comedia", "ACL", "Port", "Status", "Description", (cont.realtimepeers ? "Realtime" : ""));
 	}
 
 	ao2_lock(peers);
@@ -19197,9 +19203,8 @@
 		ast_cli(fd, PEERS_FORMAT2, name,
 		tmp_host,
 		peer->host_dynamic ? " D " : "   ",	/* Dynamic or not? */
-		ast_test_flag(&peer->flags[2], SIP_PAGE3_NAT_AUTO_RPORT) ?
-			ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? " A " : " a " :
-			ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? " N " : "   ",	/* NAT=yes? */
+		force_rport_string(peer->flags),
+		comedia_string(peer->flags),
 		(!ast_acl_list_is_empty(peer->acl)) ? " A " : "   ",       /* permit/deny */
 		tmp_port, status,
 		peer->description ? peer->description : "",
@@ -19230,7 +19235,7 @@
 		ast_sockaddr_isnull(&peer->addr) ? "0" : tmp_port,
 		peer->host_dynamic ? "yes" : "no",	/* Dynamic or not? */
 		ast_test_flag(&peer->flags[2], SIP_PAGE3_NAT_AUTO_RPORT) ? "yes" : "no",
-		ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? "yes" : "no",	/* NAT=yes? */
+		ast_test_flag(&peer->flags[0], SIP_NAT_FORCE_RPORT) ? "yes" : "no",
 		ast_test_flag(&peer->flags[2], SIP_PAGE3_NAT_AUTO_COMEDIA) ? "yes" : "no",
 		ast_test_flag(&peer->flags[1], SIP_PAGE2_SYMMETRICRTP) ? "yes" : "no",
 		ast_test_flag(&peer->flags[1], SIP_PAGE2_VIDEOSUPPORT) ? "yes" : "no",	/* VIDEOSUPPORT=yes? */
--- configs/confbridge.conf.sample
+++ configs/confbridge.conf.sample
@@ -62,7 +62,7 @@
                             ;    loose the user will hear themselves briefly each
                             ;    time they begin talking until the dsp has time to
                             ;    establish that they are in fact talking.
-                            ; 2. When talk detection AMI events are enabled, this value 
+                            ; 2. When talk detection AMI events are enabled, this value
                             ;    determines when talking has begun which results in
                             ;    an AMI event to fire.  If this value is set too tight
                             ;    AMI events may be falsely triggered by variants in
@@ -248,6 +248,11 @@
 ; Below is a list of menu actions that can be assigned
 ; to a DTMF sequence.
 ;
+; To have the first DTMF digit in a sequence be the '#' character, you need to
+; escape it.  If it is not escaped then normal config file processing will
+; think it is a directive like #include.  For example:
+; \#1=toggle_mute                      ; Pressing #1 will toggle the mute setting.
+;
 ; A single DTMF sequence can have multiple actions associated with it. This is
 ; accomplished by stringing the actions together and using a ',' as the delimiter.
 ; Example:  Both listening and talking volume is reset when '5' is pressed.
@@ -270,7 +275,7 @@
                                        ; using the '&' character as a delimiter.
 ; toggle_mute      ; Toggle turning on and off mute.  Mute will make the user silent
                    ; to everyone else, but the user will still be able to listen in.
-                   ; continue to collect the dtmf sequence.
+
 ; no_op ; This action does nothing (No Operation). Its only real purpose exists for
         ; being able to reserve a sequence in the config as a menu exit sequence.
 ; decrease_listening_volume ; Decreases the channel's listening volume.
--- include/asterisk/rtp_engine.h
+++ include/asterisk/rtp_engine.h
@@ -322,10 +322,16 @@
 	AST_RTP_ICE_CANDIDATE_TYPE_RELAYED, /*!< ICE relayed candidate, which represents the address allocated in TURN server. */
 };
 
+/*! \brief ICE component types */
+enum ast_rtp_ice_component_type {
+	AST_RTP_ICE_COMPONENT_RTP = 1,
+	AST_RTP_ICE_COMPONENT_RTCP = 2,
+};
+
 /*! \brief Structure for an ICE candidate */
 struct ast_rtp_engine_ice_candidate {
 	char *foundation;                     /*!< Foundation identifier */
-	unsigned int id;                      /*!< Component identifier */
+	enum ast_rtp_ice_component_type id;   /*!< Component identifier */
 	char *transport;                      /*!< Transport for the media */
 	int priority;                         /*!< Priority which is used if multiple candidates can be used */
 	struct ast_sockaddr address;          /*!< Address of the candidate */
--- main/channel.c
+++ main/channel.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401179 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402151 $")
 
 #include "asterisk/_private.h"
 
@@ -6493,18 +6493,19 @@
 			newvar = ast_var_assign(&varname[1], ast_var_value(current));
 			if (newvar) {
 				AST_LIST_INSERT_TAIL(ast_channel_varshead(child), newvar, entries);
-				ast_debug(1, "Copying soft-transferable variable %s.\n", ast_var_name(newvar));
+				ast_debug(1, "Inheriting variable %s from %s to %s.\n",
+					ast_var_name(newvar), ast_channel_name(parent), ast_channel_name(child));
 			}
 			break;
 		case 2:
 			newvar = ast_var_assign(varname, ast_var_value(current));
 			if (newvar) {
 				AST_LIST_INSERT_TAIL(ast_channel_varshead(child), newvar, entries);
-				ast_debug(1, "Copying hard-transferable variable %s.\n", ast_var_name(newvar));
+				ast_debug(1, "Inheriting variable %s from %s to %s.\n",
+					ast_var_name(newvar), ast_channel_name(parent), ast_channel_name(child));
 			}
 			break;
 		default:
-			ast_debug(1, "Not copying variable %s.\n", ast_var_name(current));
 			break;
 		}
 	}
--- main/config.c
+++ main/config.c
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398103 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402407 $")
 
 #include "asterisk/paths.h"	/* use ast_config_AST_CONFIG_DIR */
 #include "asterisk/network.h"	/* we do some sockaddr manipulation here */
@@ -1419,14 +1419,26 @@
 	} else {
 		/* Just a line (variable = value) */
 		int object = 0;
+		int is_escaped;
+
 		if (!(*cat)) {
 			ast_log(LOG_WARNING,
 				"parse error: No category context for line %d of %s\n", lineno, configfile);
 			return -1;
 		}
-		c = strchr(cur, '=');
 
-		if (c && c > cur && (*(c - 1) == '+')) {
+		is_escaped = cur[0] == '\\';
+		if (is_escaped) {
+			/* First character is escaped. */
+			++cur;
+			if (cur[0] < 33) {
+				ast_log(LOG_ERROR, "Invalid escape in line %d of %s\n", lineno, configfile);
+				return -1;
+			}
+		}
+		c = strchr(cur + is_escaped, '=');
+
+		if (c && c > cur + is_escaped && (*(c - 1) == '+')) {
 			struct ast_variable *var, *replace = NULL;
 			struct ast_str **str = ast_threadstorage_get(&appendbuf, sizeof(*str));
 
@@ -1462,8 +1474,11 @@
 				object = 1;
 				c++;
 			}
+			cur = ast_strip(cur);
 set_new_variable:
-			if ((v = ast_variable_new(ast_strip(cur), ast_strip(c), S_OR(suggested_include_file, cfg->include_level == 1 ? "" : configfile)))) {
+			if (ast_strlen_zero(cur)) {
+				ast_log(LOG_WARNING, "No variable name in line %d of %s\n", lineno, configfile);
+			} else if ((v = ast_variable_new(cur, ast_strip(c), S_OR(suggested_include_file, cfg->include_level == 1 ? "" : configfile)))) {
 				v->lineno = lineno;
 				v->object = object;
 				*last_cat = 0;
--- main/loader.c
+++ main/loader.c
@@ -33,7 +33,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 391507 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402288 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_MODULE_DIR */
@@ -377,6 +377,24 @@
 }
 
 #ifdef LOADABLE_MODULES
+
+static void close_lib(const char *name, void *lib)
+{
+	char *error;
+
+	if (!lib) {
+		return;
+	}
+
+	/* Clear any existing error */
+	dlerror();
+	if (dlclose(lib)) {
+		error = dlerror();
+		ast_log(AST_LOG_ERROR, "Failure in dlclose for module '%s': %s\n",
+			S_OR(name, "unknown"), S_OR(error, "Unknown error"));
+	}
+}
+
 static void unload_dynamic_module(struct ast_module *mod)
 {
 	void *lib = mod->lib;
@@ -384,9 +402,7 @@
 	/* WARNING: the structure pointed to by mod is going to
 	   disappear when this operation succeeds, so we can't
 	   dereference it */
-
-	if (lib)
-		while (!dlclose(lib));
+	close_lib(ast_module_name(mod), lib);
 }
 
 static enum ast_module_load_result load_resource(const char *resource_name, unsigned int global_symbols_only, struct ast_heap *resource_heap, int required);
@@ -435,7 +451,7 @@
 	if (resource_being_loaded != (mod = AST_LIST_LAST(&module_list))) {
 		ast_log(LOG_WARNING, "Module '%s' did not register itself during load\n", resource_in);
 		/* no, it did not, so close it and return */
-		while (!dlclose(lib));
+		close_lib(resource_in, lib);
 		/* note that the module's destructor will call ast_module_unregister(),
 		   which will free the structure we allocated in resource_being_loaded */
 		return NULL;
@@ -446,7 +462,7 @@
 	/* if we are being asked only to load modules that provide global symbols,
 	   and this one does not, then close it and return */
 	if (global_symbols_only && !wants_global) {
-		while (!dlclose(lib));
+		close_lib(resource_in, lib);
 		return NULL;
 	}
 
@@ -471,7 +487,7 @@
 	}
 #endif
 
-	while (!dlclose(lib));
+	close_lib(resource_in, lib);
 	resource_being_loaded = NULL;
 
 	/* start the load process again */
--- main/pbx.c
+++ main/pbx.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401960 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402151 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"	/* use ast_config_AST_SYSTEM_NAME */
@@ -4268,7 +4268,7 @@
 						ast_log(LOG_ERROR, "Unable to allocate bogus channel for variable substitution.  Function results may be blank.\n");
 					}
 				}
-				ast_debug(2, "Function result is '%s'\n", cp4 ? cp4 : "(null)");
+				ast_debug(2, "Function %s result is '%s'\n", finalvars, cp4 ? cp4 : "(null)");
 			} else {
 				/* Retrieve variable value */
 				ast_str_retrieve_variable(&substr3, 0, c, headp, finalvars);
@@ -4467,7 +4467,7 @@
 						ast_log(LOG_ERROR, "Unable to allocate bogus channel for variable substitution.  Function results may be blank.\n");
 					}
 				}
-				ast_debug(2, "Function result is '%s'\n", cp4 ? cp4 : "(null)");
+				ast_debug(2, "Function %s result is '%s'\n", vars, cp4 ? cp4 : "(null)");
 			} else {
 				/* Retrieve variable value */
 				pbx_retrieve_variable(c, vars, &cp4, workspace, VAR_BUF_SIZE, headp);
--- main/translate.c
+++ main/translate.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401620 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402151 $")
 
 #include <sys/time.h>
 #include <sys/resource.h>
@@ -774,7 +774,7 @@
 						matrix_get(x, z)->table_cost = newtablecost;
 						matrix_get(x, z)->multistep = 1;
 						changed++;
-						ast_debug(3, "Discovered %d cost path from %s to %s, via %s\n",
+						ast_debug(10, "Discovered %d cost path from %s to %s, via %s\n",
 							matrix_get(x, z)->table_cost,
 							ast_getformatname(ast_format_set(&tmpx, index2format(x), 0)),
 							ast_getformatname(ast_format_set(&tmpy, index2format(z), 0)),
--- main/xmldoc.c
+++ main/xmldoc.c
@@ -29,7 +29,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 398758 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402151 $")
 
 #include "asterisk/_private.h"
 #include "asterisk/paths.h"
@@ -2010,7 +2010,6 @@
 	node = ast_xml_find_element(ast_xml_node_get_children(node), var, NULL, NULL);
 
 	if (!node || !ast_xml_node_get_children(node)) {
-		ast_debug(1, "Cannot find variable '%s' in tree\n", var);
 		return ret;
 	}
 
--- res/res_rtp_asterisk.c
+++ res/res_rtp_asterisk.c
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 401620 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 402345 $")
 
 #include <sys/time.h>
 #include <signal.h>
@@ -177,9 +177,6 @@
 #define TRANSPORT_TURN_RTP 3
 #define TRANSPORT_TURN_RTCP 4
 
-#define COMPONENT_RTP 1
-#define COMPONENT_RTCP 2
-
 /*! \brief RTP learning mode tracking information */
 struct rtp_learning_info {
 	int max_seq;	/*!< The highest sequence number received */
@@ -541,9 +538,9 @@
 			candidates[cand_cnt].type = PJ_ICE_CAND_TYPE_RELAYED;
 		}
 
-		if (candidate->id == COMPONENT_RTP && rtp->turn_rtp) {
+		if (candidate->id == AST_RTP_ICE_COMPONENT_RTP && rtp->turn_rtp) {
 			pj_turn_sock_set_perm(rtp->turn_rtp, 1, &candidates[cand_cnt].addr, 1);
-		} else if (candidate->id == COMPONENT_RTCP && rtp->turn_rtcp) {
+		} else if (candidate->id == AST_RTP_ICE_COMPONENT_RTCP && rtp->turn_rtcp) {
 			pj_turn_sock_set_perm(rtp->turn_rtcp, 1, &candidates[cand_cnt].addr, 1);
 		}
 
@@ -1478,7 +1475,7 @@
 
 		pj_sockaddr_parse(pj_AF_UNSPEC(), 0, &combined, &address);
 
-		status = pj_ice_sess_on_rx_pkt(rtp->ice, rtcp ? COMPONENT_RTCP : COMPONENT_RTP,
+		status = pj_ice_sess_on_rx_pkt(rtp->ice, rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP,
 			rtcp ? TRANSPORT_SOCKET_RTCP : TRANSPORT_SOCKET_RTP, buf, len, &address,
 			pj_sockaddr_get_len(&address));
 		if (status != PJ_SUCCESS) {
@@ -1530,7 +1527,7 @@
 	if (rtp->ice) {
 		pj_thread_register_check();
 
-		if (pj_ice_sess_send_data(rtp->ice, rtcp ? COMPONENT_RTCP : COMPONENT_RTP, temp, len) == PJ_SUCCESS) {
+		if (pj_ice_sess_send_data(rtp->ice, rtcp ? AST_RTP_ICE_COMPONENT_RTCP : AST_RTP_ICE_COMPONENT_RTP, temp, len) == PJ_SUCCESS) {
 			*ice = 1;
 			return 0;
 		}
@@ -1842,7 +1839,7 @@
 		rtp->ice->user_data = rtp;
 
 		/* Add all of the available candidates to the ICE session */
-		rtp_add_candidates_to_ice(instance, rtp, addr, x, COMPONENT_RTP, TRANSPORT_SOCKET_RTP, &ast_rtp_turn_rtp_sock_cb, &rtp->turn_rtp);
+		rtp_add_candidates_to_ice(instance, rtp, addr, x, AST_RTP_ICE_COMPONENT_RTP, TRANSPORT_SOCKET_RTP, &ast_rtp_turn_rtp_sock_cb, &rtp->turn_rtp);
 	}
 #endif
 
@@ -2008,7 +2005,7 @@
 				strerror(errno));
 		}
 #ifdef USE_PJPROJECT
-		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+		update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 		if (rtp_debug_test_addr(&remote_address)) {
 			ast_verbose("Sent RTP DTMF packet to %s%s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
@@ -2060,7 +2057,7 @@
 	}
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
@@ -2138,7 +2135,7 @@
 		}
 
 #ifdef USE_PJPROJECT
-		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+		update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 		if (rtp_debug_test_addr(&remote_address)) {
@@ -2304,7 +2301,7 @@
 	rtp->rtcp->rr_count++;
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTCP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTCP, &remote_address);
 #endif
 
 	if (rtcp_debug_test_addr(&remote_address)) {
@@ -2417,7 +2414,7 @@
 	rtp->rtcp->lastsrtxcount = rtp->txcount;
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTCP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTCP, &remote_address);
 #endif
 
 	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
@@ -2608,7 +2605,7 @@
 		}
 
 #ifdef USE_PJPROJECT
-		update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+		update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 		if (rtp_debug_test_addr(&remote_address)) {
@@ -3489,7 +3486,7 @@
 	}
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
@@ -3949,7 +3946,7 @@
 
 #ifdef USE_PJPROJECT
 			if (rtp->ice) {
-				rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP,
+				rtp_add_candidates_to_ice(instance, rtp, &rtp->rtcp->us, ast_sockaddr_port(&rtp->rtcp->us), AST_RTP_ICE_COMPONENT_RTCP, TRANSPORT_SOCKET_RTCP,
 							  &ast_rtp_turn_rtcp_sock_cb, &rtp->turn_rtcp);
 			}
 #endif
@@ -4242,7 +4239,7 @@
 	}
 
 #ifdef USE_PJPROJECT
-	update_address_with_ice_candidate(rtp, COMPONENT_RTP, &remote_address);
+	update_address_with_ice_candidate(rtp, AST_RTP_ICE_COMPONENT_RTP, &remote_address);
 #endif
 
 	if (rtp_debug_test_addr(&remote_address)) {
